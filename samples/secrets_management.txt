Secrets Management Best Practices

Secrets management involves securely storing, accessing, and rotating sensitive credentials like API keys, database passwords, encryption keys, and certificates. Hardcoded secrets in source code are a leading cause of security breaches, as code repositories are frequently exposed through misconfiguration or insider threats.

Environment variables separate secrets from code but have limitations. They're visible to all processes in the same environment and often logged accidentally. Container orchestration platforms may expose environment variables in configuration. Environment variables work for simple deployments but don't scale well.

Dedicated secrets managers like HashiCorp Vault, AWS Secrets Manager, and Azure Key Vault provide centralized, audited secrets storage. They offer encryption at rest, fine-grained access control, and automatic rotation. Applications authenticate to retrieve secrets at runtime rather than storing them locally.

Git history preservation means secrets committed even briefly remain discoverable. Tools like git-secrets, truffleHog, and detect-secrets scan repositories for accidentally committed credentials. Pre-commit hooks prevent secrets from being committed in the first place. If secrets are exposed, they must be rotated immediately.

Secret rotation limits the window of opportunity for compromised credentials. Automated rotation changes secrets on a schedule without manual intervention. Zero-downtime rotation ensures applications always have valid credentials. Short-lived credentials like JWT tokens naturally expire, forcing regular renewal.

Principle of least privilege applies to secrets: applications should only access the secrets they need. Separate secrets per environment prevent development credentials from accessing production data. Service accounts with minimal permissions limit blast radius if compromised. Audit logs track all secret access for forensic analysis.
