{
  "hash": "59ee0423731ca0e274b17ec6066ddf488af4d036",
  "message": "Fix critical bigram separator bugs in analysis.py and query.py",
  "author": "Claude",
  "timestamp": "2025-12-10 12:47:09 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "TASK_LIST.md",
    "cortical/analysis.py",
    "cortical/query.py",
    "tests/test_processor.py"
  ],
  "insertions": 112,
  "deletions": 32,
  "hunks": [
    {
      "file": "TASK_LIST.md",
      "function": "All 6 functions now use this helper, reducing code duplication by ~100 lines.",
      "start_line": 1305,
      "lines_added": [
        "**Status:** [x] Completed (2025-12-10)"
      ],
      "lines_removed": [
        "**Status:** [ ] Not Started"
      ],
      "context_before": [
        "---",
        "",
        "## Critical Bug Fixes (2025-12-10)",
        "",
        "The following critical bugs were identified during code review and must be fixed:",
        "",
        "### 34. Fix Bigram Separator Mismatch in Analogy Completion",
        "",
        "**File:** `cortical/query.py`",
        "**Lines:** 1442-1468"
      ],
      "context_after": [
        "**Priority:** Critical",
        "",
        "**Problem:**",
        "The `complete_analogy_simple()` function uses underscore separators for bigram lookup and parsing, but bigrams are stored with **space** separators (defined in `tokenizer.py:179`).",
        "",
        "**Affected Code:**",
        "```python",
        "# Line 1442-1443: WRONG - uses underscore",
        "ab_bigram = f\"{term_a}_{term_b}\"  # Creates \"neural_networks\"",
        "ba_bigram = f\"{term_b}_{term_a}\""
      ],
      "change_type": "modify"
    },
    {
      "file": "TASK_LIST.md",
      "function": "parts = bigram.split(' ')",
      "start_line": 1349,
      "lines_added": [
        "**Status:** [x] Completed (2025-12-10)"
      ],
      "lines_removed": [
        "**Status:** [ ] Not Started"
      ],
      "context_before": [
        "**Files to Modify:**",
        "- `cortical/query.py` - Fix separator in lines 1442, 1443, 1452",
        "- `tests/test_processor.py` - Add tests for bigram-based analogy completion",
        "",
        "---",
        "",
        "### 35. Fix Bigram Separator Mismatch in Bigram Connections",
        "",
        "**File:** `cortical/analysis.py`",
        "**Line:** 927"
      ],
      "context_after": [
        "**Priority:** Critical",
        "",
        "**Problem:**",
        "The `compute_bigram_connections()` function splits bigram content by underscore, but bigrams are stored with **space** separators.",
        "",
        "**Affected Code:**",
        "```python",
        "# Line 927: WRONG - splits by underscore",
        "for bigram in bigrams:",
        "    parts = bigram.content.split('_')"
      ],
      "change_type": "modify"
    },
    {
      "file": "TASK_LIST.md",
      "function": "BIGRAM_SEPARATOR = ' '",
      "start_line": 1428,
      "lines_added": [
        "| **Critical** | **Fix bigram separator in analogy completion** | [x] Completed | **Bug Fix** |",
        "| **Critical** | **Fix bigram separator in bigram connections** | [x] Completed | **Bug Fix** |",
        "**Total Tests:** 340 (all passing)"
      ],
      "lines_removed": [
        "| **Critical** | **Fix bigram separator in analogy completion** | [ ] Not Started | **Bug Fix** |",
        "| **Critical** | **Fix bigram separator in bigram connections** | [ ] Not Started | **Bug Fix** |",
        "**Total Tests:** 337 (all passing)"
      ],
      "context_before": [
        "bigram = BIGRAM_SEPARATOR.join([term_a, term_b])",
        "parts = bigram.split(BIGRAM_SEPARATOR)",
        "```",
        "",
        "---",
        "",
        "## Updated Summary",
        "",
        "| Priority | Task | Status | Category |",
        "|----------|------|--------|----------|"
      ],
      "context_after": [
        "| Low | Inconsistent bigram separator convention | [ ] Future Enhancement | Code Quality |",
        "",
        "",
        "---",
        "",
        "*Updated from code review on 2025-12-10*"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/analysis.py",
      "function": "def compute_bigram_connections(",
      "start_line": 913,
      "lines_added": [
        "    # Note: Bigrams use space separators (e.g., \"neural networks\")",
        "        parts = bigram.content.split(' ')"
      ],
      "lines_removed": [
        "        parts = bigram.content.split('_')"
      ],
      "context_before": [
        "            'component_connections': 0,",
        "            'chain_connections': 0,",
        "            'cooccurrence_connections': 0",
        "        }",
        "",
        "    bigrams = list(layer1.minicolumns.values())",
        "",
        "    # Build indexes for efficient lookup",
        "    # left_component_index: {\"neural\": [bigram1, bigram2, ...]}",
        "    # right_component_index: {\"networks\": [bigram1, bigram3, ...]}"
      ],
      "context_after": [
        "    left_index: Dict[str, List[Minicolumn]] = defaultdict(list)",
        "    right_index: Dict[str, List[Minicolumn]] = defaultdict(list)",
        "",
        "    for bigram in bigrams:",
        "        if len(parts) == 2:",
        "            left_index[parts[0]].append(bigram)",
        "            right_index[parts[1]].append(bigram)",
        "",
        "    # Track connection types for statistics",
        "    component_connections = 0",
        "    chain_connections = 0",
        "    cooccurrence_connections = 0",
        "",
        "    # Track which pairs we've already connected (avoid duplicates)"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query.py",
      "function": "def complete_analogy_simple(",
      "start_line": 1431,
      "lines_added": [
        "        # Find bigrams containing \"a b\" pattern (bigrams use space separators)",
        "        ab_bigram = f\"{term_a} {term_b}\"",
        "        ba_bigram = f\"{term_b} {term_a}\"",
        "        # If \"a b\" is a bigram, look for \"c ?\" bigrams",
        "                parts = bigram.split(' ')"
      ],
      "lines_removed": [
        "        # Find bigrams containing a_b pattern",
        "        ab_bigram = f\"{term_a}_{term_b}\"",
        "        ba_bigram = f\"{term_b}_{term_a}\"",
        "        # If a_b is a bigram, look for c_? bigrams",
        "                parts = bigram.split('_')"
      ],
      "context_before": [
        "",
        "    col_a = layer0.get_minicolumn(term_a)",
        "    col_b = layer0.get_minicolumn(term_b)",
        "    col_c = layer0.get_minicolumn(term_c)",
        "",
        "    if not col_a or not col_b or not col_c:",
        "        return []",
        "",
        "    # Strategy 1: Bigram pattern matching",
        "    if layer1:"
      ],
      "context_after": [
        "",
        "        ab_col = layer1.get_minicolumn(ab_bigram)",
        "        ba_col = layer1.get_minicolumn(ba_bigram)",
        "",
        "        if ab_col or ba_col:",
        "            for bigram_col in layer1.minicolumns.values():",
        "                bigram = bigram_col.content",
        "                if len(parts) != 2:",
        "                    continue",
        "",
        "                first, second = parts",
        "",
        "                # Look for bigrams starting with c",
        "                if first == term_c and second not in {term_a, term_b, term_c}:",
        "                    score = bigram_col.pagerank * 0.8",
        "                    if second not in candidates or candidates[second] < score:",
        "                        candidates[second] = score"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestBigramConnections(unittest.TestCase):",
      "start_line": 1612,
      "lines_added": [
        "        # \"neural networks\" and \"neural processing\" share \"neural\"",
        "        # Note: bigrams use space separators (tokenizer.py:179)",
        "        neural_networks = layer1.get_minicolumn(\"neural networks\")",
        "        neural_processing = layer1.get_minicolumn(\"neural processing\")",
        "        # Verify bigrams exist",
        "        self.assertIsNotNone(neural_networks, \"Bigram 'neural networks' should exist\")",
        "        self.assertIsNotNone(neural_processing, \"Bigram 'neural processing' should exist\")",
        "",
        "        # They should be connected via shared \"neural\" component",
        "        self.assertIn(neural_processing.id, neural_networks.lateral_connections)",
        "        self.assertIn(neural_networks.id, neural_processing.lateral_connections)",
        "        # \"machine learning\" and \"deep learning\" share \"learning\"",
        "        machine_learning = layer1.get_minicolumn(\"machine learning\")",
        "        deep_learning = layer1.get_minicolumn(\"deep learning\")",
        "",
        "        # Verify bigrams exist",
        "        self.assertIsNotNone(machine_learning, \"Bigram 'machine learning' should exist\")",
        "        self.assertIsNotNone(deep_learning, \"Bigram 'deep learning' should exist\")",
        "        # They should be connected via shared \"learning\" component",
        "        self.assertIn(deep_learning.id, machine_learning.lateral_connections)",
        "        self.assertIn(machine_learning.id, deep_learning.lateral_connections)",
        "        # \"machine learning\" and \"learning algorithms\" form a chain",
        "        machine_learning = layer1.get_minicolumn(\"machine learning\")",
        "        learning_algorithms = layer1.get_minicolumn(\"learning algorithms\")",
        "",
        "        # Verify bigrams exist",
        "        self.assertIsNotNone(machine_learning, \"Bigram 'machine learning' should exist\")",
        "        self.assertIsNotNone(learning_algorithms, \"Bigram 'learning algorithms' should exist\")",
        "        # They should be connected via chain relationship",
        "        self.assertIn(learning_algorithms.id, machine_learning.lateral_connections)",
        "        self.assertIn(machine_learning.id, learning_algorithms.lateral_connections)"
      ],
      "lines_removed": [
        "        # \"neural_networks\" and \"neural_processing\" share \"neural\"",
        "        neural_networks = layer1.get_minicolumn(\"neural_networks\")",
        "        neural_processing = layer1.get_minicolumn(\"neural_processing\")",
        "        if neural_networks and neural_processing:",
        "            # They should be connected via shared \"neural\" component",
        "            self.assertIn(neural_processing.id, neural_networks.lateral_connections)",
        "            self.assertIn(neural_networks.id, neural_processing.lateral_connections)",
        "        # \"machine_learning\" and \"deep_learning\" share \"learning\"",
        "        machine_learning = layer1.get_minicolumn(\"machine_learning\")",
        "        deep_learning = layer1.get_minicolumn(\"deep_learning\")",
        "        if machine_learning and deep_learning:",
        "            # They should be connected via shared \"learning\" component",
        "            self.assertIn(deep_learning.id, machine_learning.lateral_connections)",
        "            self.assertIn(machine_learning.id, deep_learning.lateral_connections)",
        "        # \"machine_learning\" and \"learning_algorithms\" form a chain",
        "        machine_learning = layer1.get_minicolumn(\"machine_learning\")",
        "        learning_algorithms = layer1.get_minicolumn(\"learning_algorithms\")",
        "        if machine_learning and learning_algorithms:",
        "            # They should be connected via chain relationship",
        "            self.assertIn(learning_algorithms.id, machine_learning.lateral_connections)",
        "            self.assertIn(machine_learning.id, learning_algorithms.lateral_connections)"
      ],
      "context_before": [
        "        stats = processor.compute_bigram_connections(verbose=False)",
        "",
        "        self.assertIn('connections_created', stats)",
        "        self.assertIn('bigrams', stats)",
        "        self.assertIn('component_connections', stats)",
        "        self.assertIn('chain_connections', stats)",
        "        self.assertIn('cooccurrence_connections', stats)",
        "",
        "    def test_shared_left_component_connection(self):",
        "        \"\"\"Test that bigrams sharing left component are connected.\"\"\""
      ],
      "context_after": [
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "",
        "",
        "    def test_shared_right_component_connection(self):",
        "        \"\"\"Test that bigrams sharing right component are connected.\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "",
        "",
        "    def test_chain_connections(self):",
        "        \"\"\"Test that chain bigrams are connected (right of one = left of other).\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "",
        "",
        "    def test_cooccurrence_connections(self):",
        "        \"\"\"Test that bigrams co-occurring in documents are connected.\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        # Bigrams that appear in same documents should have co-occurrence connections",
        "        for bigram in layer1.minicolumns.values():",
        "            if bigram.document_ids and len(bigram.lateral_connections) > 0:",
        "                # If a bigram has connections, some should be from co-occurrence",
        "                # This is a general check that connections exist"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestBigramConnections(unittest.TestCase):",
      "start_line": 1734,
      "lines_added": [
        "    def test_component_and_chain_connections_nonzero(self):",
        "        \"\"\"Test that component and chain connections are created (verifies bigram separator fix).\"\"\"",
        "        # Create fresh processor with bigrams that share components",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(",
        "            \"doc1\",",
        "            \"Neural networks are powerful. Neural processing enables deep learning. \"",
        "            \"Machine learning is related to deep learning approaches.\"",
        "        )",
        "        processor.compute_tfidf(verbose=False)",
        "",
        "        stats = processor.compute_bigram_connections(verbose=False)",
        "",
        "        # With the bigram separator fix, component_connections should be > 0",
        "        # because \"neural networks\" and \"neural processing\" share \"neural\"",
        "        self.assertGreater(",
        "            stats['component_connections'], 0,",
        "            \"Component connections should be > 0 when bigrams share components. \"",
        "            \"If this fails, check that bigram.content.split(' ') is used (not split('_')).\"",
        "        )",
        "",
        "    def test_bigram_separator_is_space(self):",
        "        \"\"\"Test that bigrams use space separator (regression test for separator bug).\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Neural networks process data\")",
        "        processor.compute_all(verbose=False)",
        "",
        "        layer1 = processor.layers[CorticalLayer.BIGRAMS]",
        "",
        "        # Bigrams should use space separators",
        "        self.assertIsNotNone(",
        "            layer1.get_minicolumn(\"neural networks\"),",
        "            \"Bigram 'neural networks' (with space) should exist\"",
        "        )",
        "        self.assertIsNone(",
        "            layer1.get_minicolumn(\"neural_networks\"),",
        "            \"Bigram 'neural_networks' (with underscore) should NOT exist\"",
        "        )",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        \"\"\"Test that connection weights accumulate for multiple reasons.\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        # Find bigrams that could be connected by multiple reasons",
        "        # (shared component AND co-occurrence)",
        "        for bigram in layer1.minicolumns.values():",
        "            for target_id, weight in bigram.lateral_connections.items():",
        "                # Weights should be positive",
        "                self.assertGreater(weight, 0)",
        ""
      ],
      "context_after": [
        "",
        "class TestSemanticPageRank(unittest.TestCase):",
        "    \"\"\"Test semantic PageRank functionality.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        \"\"\"Set up processor with documents for semantic PageRank testing.\"\"\"",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(",
        "            \"doc1\","
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestAnalogyCompletion(unittest.TestCase):",
      "start_line": 2388,
      "lines_added": [
        "    def test_complete_analogy_simple_uses_bigram_patterns(self):",
        "        \"\"\"Test that analogy completion uses bigram patterns (verifies separator fix).\"\"\"",
        "        # Create processor with documents that should create \"a b\" and \"c d\" bigrams",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(",
        "            \"doc1\",",
        "            \"Neural networks are powerful tools for data analysis. \"",
        "            \"Machine learning helps neural networks improve performance.\"",
        "        )",
        "        processor.process_document(",
        "            \"doc2\",",
        "            \"Neural algorithms process neural signals. \"",
        "            \"Machine processing uses machine algorithms.\"",
        "        )",
        "        processor.compute_all(verbose=False)",
        "",
        "        # Verify bigrams exist with space separators",
        "        layer1 = processor.layers[CorticalLayer.BIGRAMS]",
        "        self.assertIsNotNone(",
        "            layer1.get_minicolumn(\"neural networks\"),",
        "            \"Bigram 'neural networks' should exist for bigram strategy\"",
        "        )",
        "",
        "        # The analogy should work using bigram patterns",
        "        # a:b :: c:? where \"a b\" is a bigram and we look for \"c ?\" bigrams",
        "        results = processor.complete_analogy_simple(\"neural\", \"networks\", \"machine\")",
        "",
        "        # Results should be a list (may be empty if no bigram pattern matches)",
        "        self.assertIsInstance(results, list)",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        \"\"\"Test that input terms are excluded from simple results.\"\"\"",
        "        results = self.processor.complete_analogy_simple(",
        "            \"neural\", \"networks\", \"machine\"",
        "        )",
        "",
        "        result_terms = [term for term, _ in results]",
        "        self.assertNotIn(\"neural\", result_terms)",
        "        self.assertNotIn(\"networks\", result_terms)",
        "        self.assertNotIn(\"machine\", result_terms)",
        ""
      ],
      "context_after": [
        "",
        "class TestAnalogyHelperFunctions(unittest.TestCase):",
        "    \"\"\"Test analogy helper functions.\"\"\"",
        "",
        "    def test_find_relation_between(self):",
        "        \"\"\"Test finding relations between terms.\"\"\"",
        "        from cortical.query import find_relation_between",
        "",
        "        relations = [",
        "            (\"dog\", \"IsA\", \"animal\", 1.0),"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 12,
  "day_of_week": "Wednesday",
  "seconds_since_last_commit": -435459,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}