{
  "hash": "ffc9b6ecc77dcbf8e960918755fec225f8618a85",
  "message": "Fix concept cluster document aggregation with voting mechanism",
  "author": "Claude",
  "timestamp": "2025-12-13 06:53:55 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/analysis.py"
  ],
  "insertions": 30,
  "deletions": 11,
  "hunks": [
    {
      "file": "cortical/analysis.py",
      "function": "def cluster_by_louvain(",
      "start_line": 1431,
      "lines_added": [
        "    clusters: Dict[int, List[str]],",
        "    doc_vote_threshold: float = 0.1",
        "",
        "",
        "        doc_vote_threshold: Minimum fraction of cluster members that must",
        "            contain a document for it to be assigned to the concept.",
        "            Default 0.1 (10%) prevents high-frequency tokens from causing",
        "            every concept to contain every document.",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "        # Count document votes across cluster members",
        "        # A document is assigned to the concept only if enough members contain it",
        "        doc_votes: Dict[str, int] = {}",
        "        for col in member_cols:",
        "            for doc_id in col.document_ids:",
        "                doc_votes[doc_id] = doc_votes.get(doc_id, 0) + 1",
        "",
        "        # Calculate vote threshold (minimum votes needed)",
        "        min_votes = max(1, int(len(member_cols) * doc_vote_threshold))",
        "",
        "        # Assign documents that meet the vote threshold",
        "        for doc_id, votes in doc_votes.items():",
        "            if votes >= min_votes:",
        "                concept.document_ids.add(doc_id)",
        ""
      ],
      "lines_removed": [
        "    clusters: Dict[int, List[str]]",
        "    ",
        "    ",
        "    ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "            concept.document_ids.update(col.document_ids)"
      ],
      "context_before": [
        "    for label, members in result.items():",
        "        for content in members:",
        "            if content in layer.minicolumns:",
        "                layer.minicolumns[content].cluster_id = label",
        "",
        "    return result",
        "",
        "",
        "def build_concept_clusters(",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],"
      ],
      "context_after": [
        ") -> None:",
        "    \"\"\"",
        "    Build concept layer from token clusters.",
        "    Creates Layer 2 (Concepts) minicolumns from clustered tokens.",
        "    Each concept is named after its most important members.",
        "    Args:",
        "        layers: Dictionary of all layers",
        "        clusters: Cluster dictionary from label propagation",
        "    \"\"\"",
        "    layer0 = layers[CorticalLayer.TOKENS]",
        "    layer2 = layers[CorticalLayer.CONCEPTS]",
        "    for cluster_id, members in clusters.items():",
        "        if len(members) < 2:",
        "            continue",
        "        # Get member columns and sort by PageRank",
        "        member_cols = []",
        "        for m in members:",
        "            col = layer0.get_minicolumn(m)",
        "            if col:",
        "                member_cols.append(col)",
        "        if not member_cols:",
        "            continue",
        "        member_cols.sort(key=lambda c: c.pagerank, reverse=True)",
        "        # Name concept after top members",
        "        top_names = [c.content for c in member_cols[:3]]",
        "        concept_name = '/'.join(top_names)",
        "        # Create concept minicolumn",
        "        concept = layer2.get_or_create_minicolumn(concept_name)",
        "        concept.cluster_id = cluster_id",
        "        # Aggregate properties from members with weighted connections",
        "        max_pagerank = max(c.pagerank for c in member_cols) if member_cols else 1.0",
        "        for col in member_cols:",
        "            concept.feedforward_sources.add(col.id)",
        "            concept.activation += col.activation * 0.5",
        "            concept.occurrence_count += col.occurrence_count",
        "            # Weighted feedforward: concept → token (weight by normalized PageRank)",
        "            weight = col.pagerank / max_pagerank if max_pagerank > 0 else 1.0",
        "            concept.add_feedforward_connection(col.id, weight)",
        "            # Weighted feedback: token → concept (weight by normalized PageRank)",
        "            col.add_feedback_connection(concept.id, weight)",
        "",
        "        # Set PageRank as average of members",
        "        concept.pagerank = sum(c.pagerank for c in member_cols) / len(member_cols)",
        "",
        "",
        "def compute_concept_connections(",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    semantic_relations: List[Tuple[str, str, str, float]] = None,",
        "    min_shared_docs: int = 1,",
        "    min_jaccard: float = 0.1,",
        "    use_member_semantics: bool = False,"
      ],
      "change_type": "modify"
    }
  ],
  "hour_of_day": 6,
  "day_of_week": "Saturday",
  "seconds_since_last_commit": -197453,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}