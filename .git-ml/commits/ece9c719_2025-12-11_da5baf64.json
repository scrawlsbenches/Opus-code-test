{
  "hash": "ece9c719b8adf86b019f708996ba96da3922e666",
  "message": "Merge pull request #36 from scrawlsbenches/claude/improve-code-coverage-01KuzMmJ6iFXQnbVQdLT71k8",
  "author": "scrawlsbenches",
  "timestamp": "2025-12-11 11:24:50 -0500",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    ".github/workflows/ci.yml",
    "tests/test_analysis.py",
    "tests/test_layers.py",
    "tests/test_persistence.py",
    "tests/test_processor.py",
    "tests/test_query.py"
  ],
  "insertions": 598,
  "deletions": 3,
  "hunks": [
    {
      "file": "workflows/ci.yml b/.github/workflows/ci.yml",
      "function": "jobs:",
      "start_line": 24,
      "lines_added": [
        "        # Fail if coverage is below 90%",
        "        coverage report --fail-under=90"
      ],
      "lines_removed": [
        "        # Fail if coverage is below 80%",
        "        coverage report --fail-under=80"
      ],
      "context_before": [
        "        pip install coverage",
        "",
        "    - name: Run tests with coverage",
        "      run: |",
        "        coverage run -m unittest discover -s tests -v",
        "        coverage report -m",
        "        coverage xml",
        "",
        "    - name: Check coverage threshold",
        "      run: |"
      ],
      "context_after": [
        "",
        "    - name: Upload coverage report",
        "      uses: actions/upload-artifact@v4",
        "      with:",
        "        name: coverage-report",
        "        path: coverage.xml",
        "",
        "    - name: Run showcase",
        "      if: success()",
        "      run: |"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_analysis.py",
      "function": "class TestClusteringQualityRegression(unittest.TestCase):",
      "start_line": 454,
      "lines_added": [
        "class TestLabelPropagationBridgeWeight(unittest.TestCase):",
        "    \"\"\"Test label propagation with bridge_weight parameter.\"\"\"",
        "",
        "    def test_label_propagation_with_bridge_weight(self):",
        "        \"\"\"Test that bridge_weight creates connections between documents.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks learning models\")",
        "        processor.process_document(\"doc2\", \"machine learning algorithms data\")",
        "        processor.process_document(\"doc3\", \"deep neural architecture design\")",
        "        processor.propagate_activation(iterations=3, verbose=False)",
        "        processor.compute_importance(verbose=False)",
        "",
        "        layer0 = processor.layers[CorticalLayer.TOKENS]",
        "        clusters = cluster_by_label_propagation(",
        "            layer0,",
        "            min_cluster_size=2,",
        "            cluster_strictness=0.5,",
        "            bridge_weight=0.3  # Enable bridge connections",
        "        )",
        "",
        "        # Should create some clusters",
        "        self.assertIsInstance(clusters, dict)",
        "",
        "    def test_label_propagation_bridge_weight_zero(self):",
        "        \"\"\"Test label propagation without bridge weight (default).\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks models\")",
        "        processor.process_document(\"doc2\", \"learning algorithms data\")",
        "        processor.propagate_activation(iterations=3, verbose=False)",
        "        processor.compute_importance(verbose=False)",
        "",
        "        layer0 = processor.layers[CorticalLayer.TOKENS]",
        "        clusters = cluster_by_label_propagation(",
        "            layer0,",
        "            min_cluster_size=2,",
        "            bridge_weight=0.0  # No bridge connections",
        "        )",
        "",
        "        self.assertIsInstance(clusters, dict)",
        "",
        "",
        "class TestAdditionalAnalysisEdgeCases(unittest.TestCase):",
        "    \"\"\"Test additional edge cases in analysis module.\"\"\"",
        "",
        "    def test_document_connections_single_doc(self):",
        "        \"\"\"Test document connections with single document.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks learning\")",
        "        processor.propagate_activation(iterations=3, verbose=False)",
        "        processor.compute_importance(verbose=False)",
        "        processor.compute_tfidf(verbose=False)",
        "",
        "        compute_document_connections(",
        "            processor.layers,",
        "            processor.documents,",
        "            min_shared_terms=1",
        "        )",
        "",
        "        # Single doc should have no connections",
        "        layer3 = processor.layers[CorticalLayer.DOCUMENTS]",
        "        doc = layer3.get_minicolumn(\"doc1\")",
        "        self.assertEqual(len(doc.lateral_connections), 0)",
        "",
        "    def test_pagerank_damping_factor(self):",
        "        \"\"\"Test PageRank with different damping factors.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks learning deep models\")",
        "        processor.process_document(\"doc2\", \"neural learning patterns data\")",
        "",
        "        layer0 = processor.layers[CorticalLayer.TOKENS]",
        "",
        "        # Default damping (0.85)",
        "        result1 = compute_pagerank(layer0, damping=0.85, iterations=50)",
        "",
        "        # Lower damping (more uniform)",
        "        result2 = compute_pagerank(layer0, damping=0.5, iterations=50)",
        "",
        "        # Both should return valid results",
        "        self.assertGreater(len(result1), 0)",
        "        self.assertGreater(len(result2), 0)",
        "",
        "        # All values should be positive",
        "        self.assertTrue(all(v > 0 for v in result1.values()))",
        "        self.assertTrue(all(v > 0 for v in result2.values()))",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        layer2 = self.processor.layers[CorticalLayer.CONCEPTS]",
        "",
        "        # Should have some concepts (even if just 1-2)",
        "        self.assertGreater(layer2.column_count(), 0, \"Should have at least 1 concept cluster\")",
        "",
        "        # Each concept should have feedforward connections to tokens",
        "        for concept in layer2.minicolumns.values():",
        "            self.assertIsInstance(concept.feedforward_connections, dict)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main(verbosity=2)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_layers.py",
      "function": "class TestHierarchicalLayer(unittest.TestCase):",
      "start_line": 96,
      "lines_added": [
        "",
        "    def test_contains(self):",
        "        \"\"\"Test __contains__ method.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        layer.get_or_create_minicolumn(\"exists\")",
        "",
        "        self.assertTrue(\"exists\" in layer)",
        "        self.assertFalse(\"missing\" in layer)",
        "",
        "    def test_remove_minicolumn(self):",
        "        \"\"\"Test removing a minicolumn.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        layer.get_or_create_minicolumn(\"test\")",
        "",
        "        # Verify it exists",
        "        self.assertIn(\"test\", layer)",
        "        self.assertEqual(layer.column_count(), 1)",
        "",
        "        # Remove it",
        "        result = layer.remove_minicolumn(\"test\")",
        "        self.assertTrue(result)",
        "        self.assertNotIn(\"test\", layer)",
        "        self.assertEqual(layer.column_count(), 0)",
        "",
        "        # Try removing non-existent",
        "        result = layer.remove_minicolumn(\"missing\")",
        "        self.assertFalse(result)",
        "",
        "    def test_activation_range_non_empty(self):",
        "        \"\"\"Test activation_range with non-empty layer.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        col1 = layer.get_or_create_minicolumn(\"a\")",
        "        col2 = layer.get_or_create_minicolumn(\"b\")",
        "        col3 = layer.get_or_create_minicolumn(\"c\")",
        "",
        "        col1.activation = 1.0",
        "        col2.activation = 5.0",
        "        col3.activation = 3.0",
        "",
        "        min_act, max_act = layer.activation_range()",
        "        self.assertEqual(min_act, 1.0)",
        "        self.assertEqual(max_act, 5.0)",
        "",
        "    def test_top_by_pagerank(self):",
        "        \"\"\"Test top_by_pagerank method.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        col1 = layer.get_or_create_minicolumn(\"a\")",
        "        col2 = layer.get_or_create_minicolumn(\"b\")",
        "        col3 = layer.get_or_create_minicolumn(\"c\")",
        "",
        "        col1.pagerank = 0.1",
        "        col2.pagerank = 0.5",
        "        col3.pagerank = 0.3",
        "",
        "        top = layer.top_by_pagerank(n=2)",
        "        self.assertEqual(len(top), 2)",
        "        self.assertEqual(top[0][0], \"b\")  # Highest pagerank",
        "        self.assertEqual(top[0][1], 0.5)",
        "        self.assertEqual(top[1][0], \"c\")  # Second highest",
        "        self.assertEqual(top[1][1], 0.3)",
        "",
        "    def test_top_by_tfidf(self):",
        "        \"\"\"Test top_by_tfidf method.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        col1 = layer.get_or_create_minicolumn(\"a\")",
        "        col2 = layer.get_or_create_minicolumn(\"b\")",
        "        col3 = layer.get_or_create_minicolumn(\"c\")",
        "",
        "        col1.tfidf = 0.2",
        "        col2.tfidf = 0.8",
        "        col3.tfidf = 0.5",
        "",
        "        top = layer.top_by_tfidf(n=2)",
        "        self.assertEqual(len(top), 2)",
        "        self.assertEqual(top[0][0], \"b\")  # Highest tfidf",
        "        self.assertEqual(top[0][1], 0.8)",
        "        self.assertEqual(top[1][0], \"c\")  # Second highest",
        "        self.assertEqual(top[1][1], 0.5)",
        "",
        "    def test_top_by_activation(self):",
        "        \"\"\"Test top_by_activation method.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        col1 = layer.get_or_create_minicolumn(\"a\")",
        "        col2 = layer.get_or_create_minicolumn(\"b\")",
        "        col3 = layer.get_or_create_minicolumn(\"c\")",
        "",
        "        col1.activation = 1.0",
        "        col2.activation = 10.0",
        "        col3.activation = 5.0",
        "",
        "        top = layer.top_by_activation(n=2)",
        "        self.assertEqual(len(top), 2)",
        "        self.assertEqual(top[0][0], \"b\")  # Highest activation",
        "        self.assertEqual(top[0][1], 10.0)",
        "        self.assertEqual(top[1][0], \"c\")  # Second highest",
        "        self.assertEqual(top[1][1], 5.0)",
        "",
        "    def test_analogy_property(self):",
        "        \"\"\"Test layer analogy property for all layers.\"\"\"",
        "        # Test TOKENS",
        "        self.assertIn(\"V1\", CorticalLayer.TOKENS.analogy)",
        "        self.assertIn(\"token\", CorticalLayer.TOKENS.analogy.lower())",
        "",
        "        # Test BIGRAMS",
        "        self.assertIn(\"V2\", CorticalLayer.BIGRAMS.analogy)",
        "        self.assertIn(\"pattern\", CorticalLayer.BIGRAMS.analogy.lower())",
        "",
        "        # Test CONCEPTS",
        "        self.assertIn(\"V4\", CorticalLayer.CONCEPTS.analogy)",
        "        self.assertIn(\"concept\", CorticalLayer.CONCEPTS.analogy.lower())",
        "",
        "        # Test DOCUMENTS",
        "        self.assertIn(\"IT\", CorticalLayer.DOCUMENTS.analogy)",
        "        self.assertIn(\"document\", CorticalLayer.DOCUMENTS.analogy.lower())",
        ""
      ],
      "lines_removed": [
        "        "
      ],
      "context_before": [
        "        layer.get_or_create_minicolumn(\"a\")",
        "        layer.get_or_create_minicolumn(\"b\")",
        "        layer.get_or_create_minicolumn(\"c\")",
        "        self.assertEqual(layer.column_count(), 3)",
        "    ",
        "    def test_iteration(self):",
        "        \"\"\"Test iterating over layer.\"\"\"",
        "        layer = HierarchicalLayer(CorticalLayer.TOKENS)",
        "        layer.get_or_create_minicolumn(\"a\")",
        "        layer.get_or_create_minicolumn(\"b\")"
      ],
      "context_after": [
        "        contents = [col.content for col in layer]",
        "        self.assertEqual(set(contents), {\"a\", \"b\"})",
        "",
        "",
        "class TestCorticalLayerEnum(unittest.TestCase):",
        "    \"\"\"Test the CorticalLayer enum.\"\"\"",
        "",
        "    def test_values(self):",
        "        \"\"\"Test layer values.\"\"\"",
        "        self.assertEqual(CorticalLayer.TOKENS.value, 0)",
        "        self.assertEqual(CorticalLayer.BIGRAMS.value, 1)",
        "        self.assertEqual(CorticalLayer.CONCEPTS.value, 2)",
        "        self.assertEqual(CorticalLayer.DOCUMENTS.value, 3)",
        "",
        "    def test_description(self):",
        "        \"\"\"Test layer descriptions.\"\"\"",
        "        self.assertIn(\"Token\", CorticalLayer.TOKENS.description)",
        "        self.assertIn(\"Document\", CorticalLayer.DOCUMENTS.description)",
        "",
        "",
        "class TestEdge(unittest.TestCase):",
        "    \"\"\"Test the Edge dataclass.\"\"\"",
        "",
        "    def test_edge_creation(self):",
        "        \"\"\"Test basic Edge creation.\"\"\"",
        "        edge = Edge(\"L0_target\", 0.5)",
        "        self.assertEqual(edge.target_id, \"L0_target\")",
        "        self.assertEqual(edge.weight, 0.5)",
        "        self.assertEqual(edge.relation_type, 'co_occurrence')"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_persistence.py",
      "function": "import os",
      "start_line": 6,
      "lines_added": [
        "    load_embeddings_json,",
        "    export_semantic_relations_json,",
        "    load_semantic_relations_json,"
      ],
      "lines_removed": [],
      "context_before": [
        "import json",
        "import sys",
        "sys.path.insert(0, '..')",
        "",
        "from cortical import CorticalTextProcessor, CorticalLayer",
        "from cortical.persistence import (",
        "    save_processor,",
        "    load_processor,",
        "    export_graph_json,",
        "    export_embeddings_json,"
      ],
      "context_after": [
        "    get_state_summary,",
        "    export_conceptnet_json,",
        "    LAYER_COLORS,",
        "    LAYER_NAMES",
        ")",
        "from cortical.embeddings import compute_graph_embeddings",
        "",
        "",
        "class TestSaveLoad(unittest.TestCase):",
        "    \"\"\"Test save and load functionality.\"\"\""
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_persistence.py",
      "function": "class TestSaveLoad(unittest.TestCase):",
      "start_line": 166,
      "lines_added": [
        "    def test_save_verbose_with_embeddings_and_relations(self):",
        "        \"\"\"Test save with verbose=True when embeddings and relations exist.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Neural networks are computational models.\")",
        "        processor.process_document(\"doc2\", \"Deep learning uses neural networks for analysis.\")",
        "        processor.compute_all(verbose=False)",
        "        processor.compute_graph_embeddings(dimensions=8, verbose=False)",
        "        processor.extract_corpus_semantics(verbose=False)",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"test.pkl\")",
        "",
        "            # Capture stdout",
        "            captured = io.StringIO()",
        "            sys.stdout = captured",
        "            try:",
        "                save_processor(",
        "                    filepath, processor.layers, processor.documents,",
        "                    processor.document_metadata, processor.embeddings,",
        "                    processor.semantic_relations, verbose=True",
        "                )",
        "            finally:",
        "                sys.stdout = sys.__stdout__",
        "",
        "            output = captured.getvalue()",
        "            # Check verbose output mentions embeddings and relations",
        "            self.assertIn(\"Saved processor\", output)",
        "            self.assertIn(\"embeddings\", output)",
        "            self.assertIn(\"semantic relations\", output)",
        "",
        "    def test_load_verbose_with_embeddings_and_relations(self):",
        "        \"\"\"Test load with verbose=True when embeddings and relations exist.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Neural networks are computational models.\")",
        "        processor.process_document(\"doc2\", \"Deep learning uses neural networks for analysis.\")",
        "        processor.compute_all(verbose=False)",
        "        processor.compute_graph_embeddings(dimensions=8, verbose=False)",
        "        processor.extract_corpus_semantics(verbose=False)",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"test.pkl\")",
        "            save_processor(",
        "                filepath, processor.layers, processor.documents,",
        "                processor.document_metadata, processor.embeddings,",
        "                processor.semantic_relations, verbose=False",
        "            )",
        "",
        "            # Capture stdout",
        "            captured = io.StringIO()",
        "            sys.stdout = captured",
        "            try:",
        "                load_processor(filepath, verbose=True)",
        "            finally:",
        "                sys.stdout = sys.__stdout__",
        "",
        "            output = captured.getvalue()",
        "            # Check verbose output mentions embeddings and relations",
        "            self.assertIn(\"Loaded processor\", output)",
        "            self.assertIn(\"embeddings\", output)",
        "            self.assertIn(\"semantic relations\", output)",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        processor.extract_corpus_semantics(verbose=False)",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"test.pkl\")",
        "            processor.save(filepath, verbose=False)",
        "",
        "            loaded = CorticalTextProcessor.load(filepath, verbose=False)",
        "",
        "            self.assertEqual(len(loaded.semantic_relations), len(processor.semantic_relations))",
        ""
      ],
      "context_after": [
        "",
        "class TestExportGraphJSON(unittest.TestCase):",
        "    \"\"\"Test graph JSON export.\"\"\"",
        "",
        "    def test_export_graph_json(self):",
        "        \"\"\"Test exporting graph to JSON.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks learning\")",
        "        processor.process_document(\"doc2\", \"machine learning algorithms\")",
        "        processor.compute_all(verbose=False)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_persistence.py",
      "function": "class TestExportEmbeddingsJSON(unittest.TestCase):",
      "start_line": 302,
      "lines_added": [
        "    def test_load_embeddings_json(self):",
        "        \"\"\"Test loading embeddings from JSON.\"\"\"",
        "        embeddings = {'term1': [1.0, 2.0, 3.0], 'term2': [4.0, 5.0, 6.0]}",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"embeddings.json\")",
        "            export_embeddings_json(filepath, embeddings)",
        "",
        "            loaded = load_embeddings_json(filepath)",
        "            self.assertEqual(len(loaded), 2)",
        "            self.assertEqual(loaded['term1'], [1.0, 2.0, 3.0])",
        "            self.assertEqual(loaded['term2'], [4.0, 5.0, 6.0])",
        "",
        "",
        "class TestSemanticRelationsJSON(unittest.TestCase):",
        "    \"\"\"Test semantic relations JSON export/import.\"\"\"",
        "",
        "    def test_export_semantic_relations_json(self):",
        "        \"\"\"Test exporting semantic relations to JSON.\"\"\"",
        "        relations = [",
        "            ('neural', 'RelatedTo', 'network', 0.8),",
        "            ('machine', 'IsA', 'learning', 0.9),",
        "        ]",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"relations.json\")",
        "            export_semantic_relations_json(filepath, relations)",
        "",
        "            self.assertTrue(os.path.exists(filepath))",
        "",
        "            with open(filepath) as f:",
        "                data = json.load(f)",
        "            self.assertIn('relations', data)",
        "            self.assertEqual(data['count'], 2)",
        "",
        "    def test_load_semantic_relations_json(self):",
        "        \"\"\"Test loading semantic relations from JSON.\"\"\"",
        "        relations = [",
        "            ('neural', 'RelatedTo', 'network', 0.8),",
        "            ('deep', 'RelatedTo', 'learning', 0.7),",
        "        ]",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"relations.json\")",
        "            export_semantic_relations_json(filepath, relations)",
        "",
        "            loaded = load_semantic_relations_json(filepath)",
        "            self.assertEqual(len(loaded), 2)",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        metadata = {'custom_key': 'custom_value'}",
        "",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"embeddings.json\")",
        "            export_embeddings_json(filepath, embeddings, metadata)",
        "",
        "            with open(filepath) as f:",
        "                data = json.load(f)",
        "            self.assertIn('custom_key', data['metadata'])",
        ""
      ],
      "context_after": [
        "",
        "class TestGetStateSummary(unittest.TestCase):",
        "    \"\"\"Test state summary functionality.\"\"\"",
        "",
        "    def test_get_state_summary(self):",
        "        \"\"\"Test getting state summary.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"neural networks learning\")",
        "        processor.process_document(\"doc2\", \"machine learning algorithms\")",
        "        processor.compute_all(verbose=False)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestQueryCache(unittest.TestCase):",
      "start_line": 2834,
      "lines_added": [
        "class TestRecomputeStaleItems(unittest.TestCase):",
        "    \"\"\"Test recompute method with stale item tracking.\"\"\"",
        "",
        "    def setUp(self):",
        "        self.processor = CorticalTextProcessor()",
        "        self.processor.process_document(\"doc1\", \"Neural networks process information.\")",
        "        self.processor.process_document(\"doc2\", \"Machine learning algorithms.\")",
        "        self.processor.compute_all(verbose=False)",
        "",
        "    def test_recompute_stale_with_embeddings(self):",
        "        \"\"\"Test recomputing when embeddings are stale.\"\"\"",
        "        self.processor._stale_computations.add(CorticalTextProcessor.COMP_EMBEDDINGS)",
        "        recomputed = self.processor.recompute(level='stale', verbose=False)",
        "        self.assertIn(CorticalTextProcessor.COMP_EMBEDDINGS, recomputed)",
        "",
        "    def test_recompute_stale_with_semantics(self):",
        "        \"\"\"Test recomputing when semantics are stale.\"\"\"",
        "        self.processor._stale_computations.add(CorticalTextProcessor.COMP_SEMANTICS)",
        "        recomputed = self.processor.recompute(level='stale', verbose=False)",
        "        self.assertIn(CorticalTextProcessor.COMP_SEMANTICS, recomputed)",
        "",
        "    def test_recompute_stale_with_concepts(self):",
        "        \"\"\"Test recomputing when concepts are stale.\"\"\"",
        "        self.processor._stale_computations.add(CorticalTextProcessor.COMP_CONCEPTS)",
        "        recomputed = self.processor.recompute(level='stale', verbose=False)",
        "        self.assertIn(CorticalTextProcessor.COMP_CONCEPTS, recomputed)",
        "",
        "    def test_recompute_stale_with_doc_connections(self):",
        "        \"\"\"Test recomputing when document connections are stale.\"\"\"",
        "        self.processor._stale_computations.add(CorticalTextProcessor.COMP_DOC_CONNECTIONS)",
        "        recomputed = self.processor.recompute(level='stale', verbose=False)",
        "        self.assertIn(CorticalTextProcessor.COMP_DOC_CONNECTIONS, recomputed)",
        "",
        "    def test_recompute_stale_with_bigram_connections(self):",
        "        \"\"\"Test recomputing when bigram connections are stale.\"\"\"",
        "        self.processor._stale_computations.add(CorticalTextProcessor.COMP_BIGRAM_CONNECTIONS)",
        "        recomputed = self.processor.recompute(level='stale', verbose=False)",
        "        self.assertIn(CorticalTextProcessor.COMP_BIGRAM_CONNECTIONS, recomputed)",
        "",
        "",
        "class TestVerboseOutputBranches(unittest.TestCase):",
        "    \"\"\"Test verbose output branches for coverage.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(\"doc1\", \"Neural networks are machine learning models.\")",
        "        cls.processor.process_document(\"doc2\", \"Deep learning is a type of neural network.\")",
        "        cls.processor.compute_all(verbose=False)",
        "",
        "    def test_compute_concept_connections_verbose(self):",
        "        \"\"\"Test compute_concept_connections with verbose output.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        captured = io.StringIO()",
        "        sys.stdout = captured",
        "        try:",
        "            self.processor.compute_concept_connections(",
        "                use_semantics=True,",
        "                verbose=True",
        "            )",
        "        finally:",
        "            sys.stdout = sys.__stdout__",
        "",
        "        output = captured.getvalue()",
        "        self.assertIn(\"concept connections\", output.lower())",
        "",
        "    def test_extract_pattern_relations_verbose(self):",
        "        \"\"\"Test extract_pattern_relations with verbose output.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"A neural network is a type of model.\")",
        "        processor.compute_all(verbose=False)",
        "",
        "        captured = io.StringIO()",
        "        sys.stdout = captured",
        "        try:",
        "            processor.extract_pattern_relations(verbose=True)",
        "        finally:",
        "            sys.stdout = sys.__stdout__",
        "",
        "        output = captured.getvalue()",
        "        self.assertGreater(len(output), 0)",
        "",
        "    def test_retrofit_connections_verbose(self):",
        "        \"\"\"Test retrofit_connections with verbose output.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        captured = io.StringIO()",
        "        sys.stdout = captured",
        "        try:",
        "            self.processor.retrofit_connections(iterations=5, alpha=0.3, verbose=True)",
        "        finally:",
        "            sys.stdout = sys.__stdout__",
        "",
        "        output = captured.getvalue()",
        "        self.assertIn(\"Retrofitted\", output)",
        "",
        "    def test_hierarchical_importance_verbose(self):",
        "        \"\"\"Test compute_hierarchical_importance with verbose output.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        captured = io.StringIO()",
        "        sys.stdout = captured",
        "        try:",
        "            self.processor.compute_hierarchical_importance(verbose=True)",
        "        finally:",
        "            sys.stdout = sys.__stdout__",
        "",
        "        output = captured.getvalue()",
        "        self.assertIn(\"PageRank\", output)",
        "",
        "    def test_invalid_clustering_method(self):",
        "        \"\"\"Test build_concept_clusters with invalid method raises error.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Test content here.\")",
        "        processor.propagate_activation(iterations=1, verbose=False)",
        "        processor.compute_importance(verbose=False)",
        "        processor.compute_tfidf(verbose=False)",
        "        processor.compute_document_connections(verbose=False)",
        "        processor.compute_bigram_connections(verbose=False)",
        "",
        "        with self.assertRaises(ValueError) as ctx:",
        "            processor.build_concept_clusters(clustering_method='invalid_method', verbose=False)",
        "        self.assertIn(\"invalid_method\", str(ctx.exception))",
        "",
        "",
        "class TestConceptConnectionVerboseBranches(unittest.TestCase):",
        "    \"\"\"Test verbose branches in compute_concept_connections.\"\"\"",
        "",
        "    def test_verbose_with_semantic_and_embedding_connections(self):",
        "        \"\"\"Test verbose output when both semantic and embedding connections are created.\"\"\"",
        "        import io",
        "        import sys",
        "",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Neural networks are computational models.\")",
        "        processor.process_document(\"doc2\", \"Deep learning uses neural networks.\")",
        "        processor.process_document(\"doc3\", \"Machine learning algorithms learn patterns.\")",
        "        processor.compute_all(verbose=False)",
        "        processor.compute_graph_embeddings(dimensions=8, verbose=False)",
        "        processor.extract_corpus_semantics(verbose=False)",
        "",
        "        captured = io.StringIO()",
        "        sys.stdout = captured",
        "        try:",
        "            processor.compute_concept_connections(",
        "                use_semantics=True,",
        "                use_embedding_similarity=True,",
        "                embedding_threshold=0.1,",
        "                verbose=True",
        "            )",
        "        finally:",
        "            sys.stdout = sys.__stdout__",
        "",
        "        output = captured.getvalue()",
        "        self.assertIn(\"connections\", output.lower())",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        self.processor.expand_query_cached(\"cached_query\")",
        "        self.assertGreater(len(self.processor._query_expansion_cache), 0)",
        "",
        "        # Recompute",
        "        self.processor.compute_all(verbose=False)",
        "",
        "        # Cache should be cleared",
        "        self.assertEqual(len(self.processor._query_expansion_cache), 0)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main(verbosity=2)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_query.py",
      "function": "def utility_function(x, y):",
      "start_line": 1677,
      "lines_added": [
        "class TestExpandQueryWithSemantics(unittest.TestCase):",
        "    \"\"\"Test semantic query expansion.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(\"doc1\", \"Neural networks are learning models.\")",
        "        cls.processor.process_document(\"doc2\", \"Deep learning uses neural networks.\")",
        "        cls.processor.compute_all(verbose=False)",
        "        cls.processor.extract_corpus_semantics(verbose=False)",
        "",
        "    def test_expand_query_semantic_with_relations(self):",
        "        \"\"\"Test semantic expansion with relations.\"\"\"",
        "        from cortical.query import expand_query_semantic",
        "",
        "        relations = [",
        "            ('neural', 'RelatedTo', 'network', 0.8),",
        "            ('neural', 'RelatedTo', 'learning', 0.7),",
        "        ]",
        "",
        "        expanded = expand_query_semantic(",
        "            \"neural\",",
        "            self.processor.layers,",
        "            self.processor.tokenizer,",
        "            relations,",
        "            max_expansions=5",
        "        )",
        "",
        "        self.assertIn('neural', expanded)",
        "        # Should have added some related terms",
        "        self.assertGreaterEqual(len(expanded), 1)",
        "",
        "    def test_expand_query_semantic_empty_relations(self):",
        "        \"\"\"Test semantic expansion with no relations.\"\"\"",
        "        from cortical.query import expand_query_semantic",
        "",
        "        expanded = expand_query_semantic(",
        "            \"neural\",",
        "            self.processor.layers,",
        "            self.processor.tokenizer,",
        "            [],  # Empty relations",
        "            max_expansions=5",
        "        )",
        "",
        "        # Should still have original term",
        "        self.assertIn('neural', expanded)",
        "",
        "",
        "class TestBoostDefinitionDocuments(unittest.TestCase):",
        "    \"\"\"Test definition document boosting.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(\"def_doc\", \"\"\"",
        "            class MyClass:",
        "                def __init__(self):",
        "                    pass",
        "",
        "            def process_data(self):",
        "                return self.data",
        "        \"\"\")",
        "        cls.processor.process_document(\"usage_doc\", \"\"\"",
        "            We use MyClass to process data.",
        "            The results are stored in files.",
        "        \"\"\")",
        "        cls.processor.compute_all(verbose=False)",
        "",
        "    def test_boost_definition_documents_with_definition(self):",
        "        \"\"\"Test boosting documents that contain definitions.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        doc_results = [",
        "            (\"def_doc\", 1.0),",
        "            (\"usage_doc\", 1.0),",
        "        ]",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"where is class MyClass defined?\",",
        "            self.processor.documents,",
        "            2.0",
        "        )",
        "",
        "        # Should still have documents",
        "        self.assertEqual(len(boosted), 2)",
        "",
        "",
        "class TestQueryRelatedDocuments(unittest.TestCase):",
        "    \"\"\"Test related document lookup.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(\"doc1\", \"Neural networks are models.\")",
        "        cls.processor.process_document(\"doc2\", \"Machine learning uses algorithms.\")",
        "        cls.processor.process_document(\"doc3\", \"Neural learning processes data.\")",
        "        cls.processor.compute_all(verbose=False)",
        "",
        "    def test_find_related_documents(self):",
        "        \"\"\"Test finding related documents.\"\"\"",
        "        from cortical.query import find_related_documents",
        "",
        "        related = find_related_documents(",
        "            \"doc1\",",
        "            self.processor.layers",
        "        )",
        "",
        "        # Should return a list",
        "        self.assertIsInstance(related, list)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "",
        "    def test_processor_has_code_chunk_param(self):",
        "        \"\"\"Processor should accept use_code_aware_chunks parameter.\"\"\"",
        "        # Should not raise",
        "        results = self.processor.find_passages_for_query(",
        "            \"utility\",",
        "            use_code_aware_chunks=True",
        "        )",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 16,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -335998,
  "is_merge": true,
  "is_initial": false,
  "parent_count": 2,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}