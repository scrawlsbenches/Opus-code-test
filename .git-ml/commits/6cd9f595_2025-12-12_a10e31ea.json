{
  "hash": "6cd9f5957f238bd1a7a19ffaf10b5eba862638b1",
  "message": "Fix misleading hardcoded values",
  "author": "Claude",
  "timestamp": "2025-12-12 10:42:39 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/layers.py",
    "cortical/query/definitions.py",
    "cortical/query/expansion.py",
    "tests/test_query.py"
  ],
  "insertions": 37,
  "deletions": 25,
  "hunks": [
    {
      "file": "cortical/layers.py",
      "function": "class HierarchicalLayer:",
      "start_line": 170,
      "lines_added": [
        "    def sparsity(self, threshold_fraction: float = 0.5) -> float:",
        "        Calculate sparsity (fraction of columns with below-average activation).",
        "",
        "        more efficient and allow for more distinct patterns. This measures",
        "        the fraction of columns activated below a threshold relative to",
        "        the average activation.",
        "",
        "        Args:",
        "            threshold_fraction: Fraction of average activation to use as threshold.",
        "                Columns with activation < (average * threshold_fraction) count as sparse.",
        "                Default 0.5 means columns below 50% of average activation.",
        "",
        "        avg_activation = self.average_activation()",
        "        if avg_activation == 0:",
        "            return 1.0  # All columns are sparse if no activation",
        "        threshold = avg_activation * threshold_fraction",
        "        low_activation = sum(1 for col in self.minicolumns.values()"
      ],
      "lines_removed": [
        "    def sparsity(self) -> float:",
        "        Calculate sparsity (fraction of columns with low activation).",
        "        ",
        "        more efficient and allow for more distinct patterns.",
        "        ",
        "        threshold = 1.0  # Activation threshold",
        "        low_activation = sum(1 for col in self.minicolumns.values() "
      ],
      "context_before": [
        "            return 0.0",
        "        return sum(col.activation for col in self.minicolumns.values()) / len(self.minicolumns)",
        "    ",
        "    def activation_range(self) -> tuple:",
        "        \"\"\"Return (min, max) activation values.\"\"\"",
        "        if not self.minicolumns:",
        "            return (0.0, 0.0)",
        "        activations = [col.activation for col in self.minicolumns.values()]",
        "        return (min(activations), max(activations))",
        "    "
      ],
      "context_after": [
        "        \"\"\"",
        "        In biological neural networks, sparse representations are",
        "        Returns:",
        "            Fraction of columns with activation below threshold",
        "        \"\"\"",
        "        if not self.minicolumns:",
        "            return 0.0",
        "                            if col.activation < threshold)",
        "        return low_activation / len(self.minicolumns)",
        "    ",
        "    def top_by_pagerank(self, n: int = 10) -> list:",
        "        \"\"\"",
        "        Get top minicolumns by PageRank score.",
        "        ",
        "        Args:",
        "            n: Number of results to return",
        "            "
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/definitions.py",
      "function": "def is_test_file(doc_id: str) -> bool:",
      "start_line": 299,
      "lines_added": [
        "    test_with_definition_penalty: float = 0.5,",
        "    test_without_definition_penalty: float = 0.7",
        "    - Test files with the definition pattern get test_with_definition_penalty (default 0.5x)",
        "    - All other test files get test_without_definition_penalty (default 0.7x)",
        "        test_with_definition_penalty: Multiplier for test files that contain the definition",
        "            (default 0.5). Even test files with definitions are penalized vs source files.",
        "        test_without_definition_penalty: Multiplier for test files without the definition",
        "            (default 0.7). Set to 1.0 to disable test file penalty.",
        "                # Test file with definition: still penalized vs source files",
        "                boosted_docs.append((doc_id, score * test_with_definition_penalty))",
        "            boosted_docs.append((doc_id, score * test_without_definition_penalty))"
      ],
      "lines_removed": [
        "    test_file_boost_factor: float = 0.5,",
        "    test_file_penalty: float = 0.7",
        "    - Test files with the definition pattern get test_file_boost_factor (default 0.5x)",
        "    - All other test files get test_file_penalty (default 0.7x) to deprioritize them",
        "        test_file_boost_factor: Multiplier for test files with definition (default 0.5)",
        "        test_file_penalty: Multiplier for test files without definition (default 0.7)",
        "            Set to 1.0 to disable test file penalty.",
        "                # Test file with definition: apply reduced boost",
        "                boosted_docs.append((doc_id, score * test_file_boost_factor))",
        "            boosted_docs.append((doc_id, score * test_file_penalty))"
      ],
      "context_before": [
        "        return True",
        "",
        "    return False",
        "",
        "",
        "def boost_definition_documents(",
        "    doc_results: List[Tuple[str, float]],",
        "    query_text: str,",
        "    documents: Dict[str, str],",
        "    boost_factor: float = 2.0,"
      ],
      "context_after": [
        ") -> List[Tuple[str, float]]:",
        "    \"\"\"",
        "    Boost documents that contain the actual definition being searched for.",
        "",
        "    This helps ensure the source file containing a class/function definition",
        "    is included in the document candidates, even if test files mention the",
        "    identifier more frequently.",
        "",
        "    For definition queries:",
        "    - Source files with the definition pattern get boost_factor (default 2.0x)",
        "",
        "    Args:",
        "        doc_results: List of (doc_id, score) tuples",
        "        query_text: The original search query",
        "        documents: Dict mapping doc_id to document text",
        "        boost_factor: Multiplier for definition-containing source docs (default 2.0)",
        "",
        "    Returns:",
        "        Re-scored document results with definition boost applied",
        "    \"\"\"",
        "    definition_info = detect_definition_query(query_text)",
        "",
        "    if not definition_info['is_definition_query'] or not definition_info['pattern']:",
        "        return doc_results",
        "",
        "    pattern = re.compile(definition_info['pattern'], re.IGNORECASE)",
        "    boosted_docs = []",
        "",
        "    for doc_id, score in doc_results:",
        "        doc_text = documents.get(doc_id, '')",
        "        has_definition = pattern.search(doc_text)",
        "        is_test = is_test_file(doc_id)",
        "",
        "        if has_definition:",
        "            if is_test:",
        "            else:",
        "                # Source file with definition: apply full boost",
        "                boosted_docs.append((doc_id, score * boost_factor))",
        "        elif is_test:",
        "            # Test file without definition: apply penalty to deprioritize",
        "        else:",
        "            # Source file without definition: keep original score",
        "            boosted_docs.append((doc_id, score))",
        "",
        "    # Re-sort by boosted scores",
        "    boosted_docs.sort(key=lambda x: x[1], reverse=True)",
        "    return boosted_docs"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/expansion.py",
      "function": "This module provides:",
      "start_line": 11,
      "lines_added": [
        "from ..config import DEFAULT_CHAIN_VALIDITY"
      ],
      "lines_removed": [],
      "context_before": [
        "- Multi-hop inference through relation chains",
        "- Code concept expansion (programming synonyms)",
        "\"\"\"",
        "",
        "from typing import Dict, List, Tuple, Optional",
        "from collections import defaultdict",
        "",
        "from ..layers import CorticalLayer, HierarchicalLayer",
        "from ..tokenizer import Tokenizer, CODE_EXPANSION_STOP_WORDS",
        "from ..code_concepts import expand_code_concepts"
      ],
      "context_after": [
        "",
        "",
        "# Valid relation chain patterns for multi-hop inference",
        "# Key: (relation1, relation2) -> validity score (0.0 = invalid, 1.0 = fully valid)",
        "VALID_RELATION_CHAINS = {",
        "    # Transitive hierarchies",
        "    ('IsA', 'IsA'): 1.0,           # dog IsA animal IsA living_thing",
        "    ('PartOf', 'PartOf'): 1.0,     # wheel PartOf car PartOf vehicle",
        "    ('IsA', 'HasProperty'): 0.9,   # dog IsA animal HasProperty alive",
        "    ('PartOf', 'HasProperty'): 0.8,  # wheel PartOf car HasProperty fast"
      ],
      "change_type": "add"
    },
    {
      "file": "cortical/query/expansion.py",
      "function": "def score_relation_path(path: List[str]) -> float:",
      "start_line": 67,
      "lines_added": [
        "        pair_score = VALID_RELATION_CHAINS.get(pair, DEFAULT_CHAIN_VALIDITY)"
      ],
      "lines_removed": [
        "        pair_score = VALID_RELATION_CHAINS.get(pair, 0.4)  # Default: moderate validity"
      ],
      "context_before": [
        "    if not path:",
        "        return 1.0",
        "    if len(path) == 1:",
        "        return 1.0",
        "",
        "    # Compute score as product of consecutive pair validities",
        "    total_score = 1.0",
        "    for i in range(len(path) - 1):",
        "        pair = (path[i], path[i + 1])",
        "        # Check both orderings"
      ],
      "context_after": [
        "        total_score *= pair_score",
        "",
        "    return total_score",
        "",
        "",
        "def expand_query(",
        "    query_text: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    tokenizer: Tokenizer,",
        "    max_expansions: int = 10,"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_query.py",
      "function": "class TestBoostDefinitionDocumentsTestFilePenalty(unittest.TestCase):",
      "start_line": 1869,
      "lines_added": [
        "            test_with_definition_penalty=0.5",
        "        \"\"\"Test that test_with_definition_penalty=1.0 disables the penalty.\"\"\"",
        "            test_with_definition_penalty=1.0  # No penalty",
        "        # Test file doesn't get full boost, it gets test_with_definition_penalty (1.0 here means no change)",
        "        # With test_with_definition_penalty=1.0, test file gets 10.0 * 1.0 = 10.0"
      ],
      "lines_removed": [
        "            test_file_boost_factor=0.5",
        "        \"\"\"Test that test_file_boost_factor=1.0 disables the penalty.\"\"\"",
        "            test_file_boost_factor=1.0  # No penalty",
        "        # Test file doesn't get full boost, it gets test_file_boost_factor (1.0 here means no change)",
        "        # Wait, if test_file_boost_factor=1.0, test file gets 10.0 * 1.0 = 10.0"
      ],
      "context_before": [
        "        documents = {",
        "            \"tests/test_analysis.py\": \"def compute_pagerank(layers, damping=0.85): pass  # mock\",",
        "            \"cortical/analysis.py\": \"def compute_pagerank(layers, damping=0.85):\\n    '''Real implementation'''\\n    result = do_stuff()\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def compute_pagerank\",",
        "            documents,",
        "            boost_factor=2.0,"
      ],
      "context_after": [
        "        )",
        "",
        "        # Source file should be ranked first after boosting",
        "        self.assertEqual(boosted[0][0], \"cortical/analysis.py\")",
        "        # Source file gets 2.0x boost: 10.0 * 2.0 = 20.0",
        "        self.assertEqual(boosted[0][1], 20.0)",
        "        # Test file gets 0.5x penalty: 10.0 * 0.5 = 5.0",
        "        self.assertEqual(boosted[1][1], 5.0)",
        "",
        "    def test_test_file_penalty_can_be_disabled(self):",
        "        from cortical.query import boost_definition_documents",
        "",
        "        doc_results = [",
        "            (\"tests/test_module.py\", 10.0),",
        "            (\"src/module.py\", 10.0),",
        "        ]",
        "",
        "        documents = {",
        "            \"tests/test_module.py\": \"def my_func(): pass\",",
        "            \"src/module.py\": \"def my_func(): return 42\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def my_func\",",
        "            documents,",
        "            boost_factor=2.0,",
        "        )",
        "",
        "        # Both should get the same boost when penalty is disabled",
        "        scores = {doc_id: score for doc_id, score in boosted}",
        "        # Source file gets 10.0 * 2.0 = 20.0",
        "        self.assertEqual(scores[\"src/module.py\"], 20.0)",
        "        self.assertEqual(scores[\"tests/test_module.py\"], 10.0)",
        "",
        "    def test_non_definition_query_unchanged(self):",
        "        \"\"\"Test that non-definition queries are not affected.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        doc_results = [",
        "            (\"tests/test_query.py\", 10.0),"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_query.py",
      "function": "class TestBoostDefinitionDocumentsTestFilePenalty(unittest.TestCase):",
      "start_line": 1955,
      "lines_added": [
        "            test_with_definition_penalty=0.5,",
        "            test_without_definition_penalty=0.7"
      ],
      "lines_removed": [
        "            test_file_boost_factor=0.5,",
        "            test_file_penalty=0.7"
      ],
      "context_before": [
        "        documents = {",
        "            \"tests/test_processor.py\": \"from analysis import compute_pagerank; result = compute_pagerank()\",",
        "            \"cortical/analysis.py\": \"def compute_pagerank(layers, damping=0.85):\\n    return pagerank_impl()\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def compute_pagerank\",",
        "            documents,",
        "            boost_factor=2.0,"
      ],
      "context_after": [
        "        )",
        "",
        "        # Source file with definition should now rank first",
        "        # Source file gets 2.0x: 80.0 * 2.0 = 160.0",
        "        # Test file without definition gets 0.7x penalty: 100.0 * 0.7 = 70.0",
        "        self.assertEqual(boosted[0][0], \"cortical/analysis.py\")",
        "        self.assertEqual(boosted[0][1], 160.0)",
        "        self.assertEqual(boosted[1][1], 70.0)"
      ],
      "change_type": "modify"
    }
  ],
  "hour_of_day": 10,
  "day_of_week": "Friday",
  "seconds_since_last_commit": -270129,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}