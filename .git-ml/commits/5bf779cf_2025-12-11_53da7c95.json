{
  "hash": "5bf779cf8273cacd7cb1d597f695fd2ab933b004",
  "message": "Refactor CLI wrappers for quiet-by-default philosophy",
  "author": "Claude",
  "timestamp": "2025-12-11 17:14:28 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/cli_wrapper.py",
    "scripts/cli_wrappers.py",
    "tests/test_cli_wrapper.py"
  ],
  "insertions": 438,
  "deletions": 291,
  "hunks": [
    {
      "file": "cortical/cli_wrapper.py",
      "function": null,
      "start_line": 1,
      "lines_added": [
        "Design philosophy: QUIET BY DEFAULT, POWERFUL WHEN NEEDED.",
        "",
        "Most of the time you just want to run a command and check if it worked.",
        "The fancy stuff (hooks, tracking, context management) is there when you",
        "need it, invisible when you don't.",
        "",
        "Simple usage (90% of cases):",
        "    from cortical.cli_wrapper import run",
        "",
        "    result = run(\"pytest tests/\")",
        "    if result.success:",
        "        print(\"Tests passed\")",
        "    else:",
        "        print(result.stderr)",
        "",
        "With git context (when you need it):",
        "    result = run(\"git status\", git=True)",
        "    print(result.git.modified_files)",
        "",
        "With session tracking (for complex workflows):",
        "    with Session() as s:",
        "        s.run(\"pytest tests/\")",
        "        s.run(\"git add -A\")",
        "        s.run(\"git commit -m 'fix tests'\")",
        "",
        "        if s.should_reindex():",
        "            s.run(\"python scripts/index_codebase.py --incremental\")",
        "        print(s.summary())",
        "Advanced (hooks for automation):",
        "    @wrapper.on_success(\"pytest\")",
        "    def after_tests(result):",
        "        # Auto-update coverage badge, etc.",
        "        pass"
      ],
      "lines_removed": [
        "This module provides infrastructure for wrapping CLI tools to:",
        "- Collect execution metadata (timing, exit codes, output)",
        "- Gather context (git status, working directory, environment)",
        "- Trigger callbacks on task completion",
        "- Support context window management integration",
        "",
        "Architecture:",
        "    1. CLIWrapper - Base class for wrapping shell commands",
        "    2. ExecutionContext - Dataclass holding all execution metadata",
        "    3. HookRegistry - Register pre/post execution hooks",
        "    4. ContextCollector - Gather environment and git context",
        "",
        "Example usage:",
        "    # Basic wrapper with context collection",
        "    wrapper = CLIWrapper()",
        "    result = wrapper.run(['git', 'status'])",
        "    print(result.context.duration)",
        "    print(result.context.git_branch)",
        "    # With hooks for task completion",
        "    def on_test_complete(ctx: ExecutionContext):",
        "        if ctx.exit_code == 0:",
        "            print(\"Tests passed! Triggering re-index...\")",
        "    wrapper.hooks.register_post('pytest', on_test_complete)",
        "    wrapper.run(['pytest', 'tests/'])",
        "    # Task completion triggers",
        "    manager = TaskCompletionManager()",
        "    manager.on_task_complete('test', lambda ctx: reindex_if_needed(ctx))",
        "    manager.on_task_complete('commit', lambda ctx: update_context_window(ctx))"
      ],
      "context_before": [
        "\"\"\"",
        "CLI wrapper framework for collecting context and triggering actions.",
        ""
      ],
      "context_after": [
        "",
        "",
        "    wrapper = CLIWrapper()",
        "",
        "\"\"\"",
        "",
        "import json",
        "import os",
        "import platform",
        "import subprocess",
        "import time",
        "import uuid",
        "from dataclasses import dataclass, field, asdict",
        "from datetime import datetime"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/cli_wrapper.py",
      "function": "class CLIWrapper:",
      "start_line": 501,
      "lines_added": [
        "    # -------------------------------------------------------------------------",
        "    # Decorator-style hook registration (cleaner API)",
        "    # -------------------------------------------------------------------------",
        "",
        "    def on_success(self, pattern: Optional[str] = None):",
        "        \"\"\"",
        "        Decorator to register a success hook.",
        "",
        "        Example:",
        "            wrapper = CLIWrapper()",
        "",
        "            @wrapper.on_success(\"pytest\")",
        "            def after_tests(result):",
        "                print(f\"Tests passed in {result.duration:.1f}s\")",
        "        \"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_success(pattern, func)",
        "            return func",
        "        return decorator",
        "",
        "    def on_error(self, pattern: Optional[str] = None):",
        "        \"\"\"Decorator to register an error hook.\"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_error(pattern, func)",
        "            return func",
        "        return decorator",
        "",
        "    def on_complete(self, pattern: Optional[str] = None):",
        "        \"\"\"Decorator to register a completion hook (success or failure).\"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_post(pattern, func)",
        "            return func",
        "        return decorator",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        self.hooks.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        # Trigger success/error hooks",
        "        if ctx.success:",
        "            self.hooks.trigger(HookType.ON_SUCCESS, ctx)",
        "        else:",
        "            self.hooks.trigger(HookType.ON_ERROR, ctx)",
        "",
        "        return ctx",
        ""
      ],
      "context_after": [
        "",
        "# =============================================================================",
        "# Task Completion Manager",
        "# =============================================================================",
        "",
        "class TaskCompletionManager:",
        "    \"\"\"",
        "    Manager for task completion triggers and context window management.",
        "",
        "    Provides high-level task completion callbacks that can:"
      ],
      "change_type": "add"
    },
    {
      "file": "cortical/cli_wrapper.py",
      "function": "def run_with_context(",
      "start_line": 782,
      "lines_added": [
        "",
        "",
        "# =============================================================================",
        "# Simple API (the 90% use case)",
        "# =============================================================================",
        "",
        "def run(",
        "    command: Union[str, List[str]],",
        "    git: bool = False,",
        "    timeout: Optional[float] = None,",
        "    cwd: Optional[str] = None,",
        ") -> ExecutionContext:",
        "    \"\"\"",
        "    Run a command. That's it.",
        "",
        "    This is the simple API for the 90% use case. No hooks, no tracking,",
        "    no noise. Just run and get results.",
        "",
        "    Args:",
        "        command: Command to run (string or list)",
        "        git: If True, collect git context (branch, modified files, etc.)",
        "        timeout: Timeout in seconds (None = no timeout)",
        "        cwd: Working directory",
        "",
        "    Returns:",
        "        ExecutionContext with:",
        "        - .success: bool - did it work?",
        "        - .stdout: str - standard output",
        "        - .stderr: str - standard error",
        "        - .exit_code: int - exit code",
        "        - .duration: float - how long it took",
        "        - .git: GitContext - if git=True",
        "",
        "    Example:",
        "        result = run(\"pytest tests/\")",
        "        if result.success:",
        "            print(\"All tests passed\")",
        "        else:",
        "            print(f\"Failed: {result.stderr}\")",
        "    \"\"\"",
        "    wrapper = CLIWrapper(",
        "        collect_git_context=git,",
        "        capture_output=True,",
        "        default_timeout=timeout,",
        "    )",
        "    return wrapper.run(command, cwd=cwd)",
        "",
        "",
        "# =============================================================================",
        "# Session Context Manager",
        "# =============================================================================",
        "",
        "class Session:",
        "    \"\"\"",
        "    Track a sequence of commands as a session.",
        "",
        "    Use this when you want to:",
        "    - Track multiple related commands together",
        "    - Know if you should re-index after changes",
        "    - Get a summary of what happened",
        "",
        "    Example:",
        "        with Session() as s:",
        "            s.run(\"pytest tests/\")",
        "            s.run(\"git add -A\")",
        "            s.run(\"git commit -m 'fix'\")",
        "",
        "            if s.should_reindex():",
        "                s.run(\"python scripts/index_codebase.py -i\")",
        "",
        "            print(s.summary())",
        "    \"\"\"",
        "",
        "    def __init__(self, git: bool = True):",
        "        \"\"\"",
        "        Start a session.",
        "",
        "        Args:",
        "            git: Whether to collect git context for commands (default True)",
        "        \"\"\"",
        "        self._wrapper = CLIWrapper(collect_git_context=git)",
        "        self._manager = TaskCompletionManager()",
        "        self._context_manager = ContextWindowManager()",
        "        self._results: List[ExecutionContext] = []",
        "",
        "        # Wire up tracking (silent - no hooks that print anything)",
        "        self._wrapper.hooks.register_post(None, self._track)",
        "",
        "    def _track(self, ctx: ExecutionContext) -> None:",
        "        \"\"\"Internal: track command completion.\"\"\"",
        "        self._results.append(ctx)",
        "        self._manager.handle_completion(ctx)",
        "        self._context_manager.add_execution(ctx)",
        "",
        "    def __enter__(self) -> 'Session':",
        "        return self",
        "",
        "    def __exit__(self, exc_type, exc_val, exc_tb) -> None:",
        "        pass  # Nothing to clean up",
        "",
        "    def run(",
        "        self,",
        "        command: Union[str, List[str]],",
        "        **kwargs",
        "    ) -> ExecutionContext:",
        "        \"\"\"Run a command within this session.\"\"\"",
        "        return self._wrapper.run(command, **kwargs)",
        "",
        "    def should_reindex(self) -> bool:",
        "        \"\"\"Check if corpus re-indexing is recommended based on session activity.\"\"\"",
        "        return self._manager.should_trigger_reindex()",
        "",
        "    def summary(self) -> Dict[str, Any]:",
        "        \"\"\"Get a summary of this session's activity.\"\"\"",
        "        return self._manager.get_session_summary()",
        "",
        "    @property",
        "    def results(self) -> List[ExecutionContext]:",
        "        \"\"\"All command results from this session.\"\"\"",
        "        return self._results.copy()",
        "",
        "    @property",
        "    def success_rate(self) -> float:",
        "        \"\"\"Fraction of commands that succeeded (0.0 to 1.0).\"\"\"",
        "        if not self._results:",
        "            return 1.0",
        "        return sum(1 for r in self._results if r.success) / len(self._results)",
        "",
        "    @property",
        "    def all_passed(self) -> bool:",
        "        \"\"\"True if all commands in this session succeeded.\"\"\"",
        "        return all(r.success for r in self._results)",
        "",
        "    @property",
        "    def modified_files(self) -> List[str]:",
        "        \"\"\"List of files modified during this session (from git context).\"\"\"",
        "        files = set()",
        "        for r in self._results:",
        "            files.update(r.git.modified_files)",
        "            files.update(r.git.staged_files)",
        "        return list(files)"
      ],
      "lines_removed": [],
      "context_before": [
        "",
        "    Args:",
        "        command: Command to execute",
        "        **kwargs: Additional arguments for CLIWrapper.run()",
        "",
        "    Returns:",
        "        ExecutionContext with all metadata",
        "    \"\"\"",
        "    wrapper = CLIWrapper()",
        "    return wrapper.run(command, **kwargs)"
      ],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "scripts/cli_wrappers.py",
      "function": null,
      "start_line": 1,
      "lines_added": [
        "Philosophy: QUIET BY DEFAULT. These wrappers collect context silently",
        "and only speak when asked.",
        "    # Simple - just use run()",
        "    from cortical.cli_wrapper import run, Session",
        "    result = run(\"pytest tests/\")",
        "    if not result.success:",
        "        print(result.stderr)",
        "",
        "    # Session tracking",
        "    with Session() as s:",
        "        s.run(\"pytest tests/\")",
        "        s.run(\"git commit -m 'fix'\")",
        "        if s.should_reindex():",
        "            print(\"Consider re-indexing\")",
        "    python scripts/cli_wrappers.py run pytest tests/ -v",
        "    python scripts/cli_wrappers.py --summary",
        "    Session,",
        "    run,",
        "    Development-focused CLI wrapper - QUIET BY DEFAULT.",
        "    No emoji. No unsolicited advice. Just runs commands and tracks context.",
        "    Ask for information when you want it.",
        "        log_to_file: bool = False,",
        "        self._session = Session(git=True)",
        "        self.log_to_file = log_to_file",
        "",
        "        if log_to_file:",
        "            if log_dir:",
        "                self.log_dir = Path(log_dir)",
        "            else:",
        "                self.log_dir = Path('.cli_wrapper_logs')",
        "            # Register file logging hook",
        "            @self._session._wrapper.on_complete()",
        "            def log_to_file(ctx: ExecutionContext):",
        "                self._log_result(ctx)",
        "    def _log_result(self, ctx: ExecutionContext):",
        "        \"\"\"Log result to file (if enabled).\"\"\"",
        "        if not self.log_to_file:",
        "            return",
        "        log_file = self.log_dir / 'commands.jsonl'",
        "        \"\"\"Execute a command.\"\"\"",
        "        return self._session.run(command, **kwargs)",
        "    def summary(self) -> dict:",
        "        return self._session.summary()",
        "        return self._session.should_reindex()",
        "    @property",
        "    def all_passed(self) -> bool:",
        "        \"\"\"True if all commands succeeded.\"\"\"",
        "        return self._session.all_passed",
        "    @property",
        "    def results(self) -> List[ExecutionContext]:",
        "        \"\"\"All command results.\"\"\"",
        "        return self._session.results",
        "# CLI Interface (simplified)",
        "    \"\"\"",
        "    CLI entry point - just run commands with optional context.",
        "",
        "    This is mostly for demonstration. In practice, you'd use the",
        "    Python API directly: run() or Session.",
        "    \"\"\"",
        "        description='Run commands with context collection (quiet by default)',",
        "    %(prog)s run pytest tests/ -v",
        "    %(prog)s run git status",
        "    %(prog)s run echo hello --json",
        "        'mode',",
        "        choices=['run'],",
        "        default='run',",
        "        help='Mode (currently only \"run\" is supported)'",
        "        '--git',",
        "        help='Collect git context'",
        "        help='Output result as JSON'",
        "        parser.print_help()",
        "    # Run the command",
        "    result = run(args.command, git=args.git)"
      ],
      "lines_removed": [
        "These wrappers collect context and trigger actions automatically:",
        "- git_wrapper: Track commits, trigger re-indexing",
        "- test_wrapper: Run tests, log results",
        "- dev_wrapper: General development command wrapper",
        "    # As a module",
        "    from scripts.cli_wrappers import git_wrapper, test_wrapper",
        "    result = git_wrapper.run(['git', 'status'])",
        "    result = test_wrapper.run(['pytest', 'tests/', '-v'])",
        "    python scripts/cli_wrappers.py git status",
        "    python scripts/cli_wrappers.py test pytest tests/ -v",
        "    python scripts/cli_wrappers.py run echo hello",
        "    HookType,",
        "    create_wrapper_with_completion_manager,",
        "    Development-focused CLI wrapper with smart defaults.",
        "    Features:",
        "    - Automatic re-index triggering after code changes",
        "    - Test result logging",
        "    - Session activity tracking",
        "    - Context window management hints",
        "        auto_reindex: bool = True,",
        "        verbose: bool = False",
        "        self.wrapper, self.completion_manager = create_wrapper_with_completion_manager()",
        "        self.context_manager = ContextWindowManager()",
        "        self.verbose = verbose",
        "        self.auto_reindex = auto_reindex",
        "",
        "        # Set up logging directory",
        "        if log_dir:",
        "            self.log_dir = Path(log_dir)",
        "            self.log_dir.mkdir(parents=True, exist_ok=True)",
        "        else:",
        "            self.log_dir = Path('.cli_wrapper_logs')",
        "        # Register hooks",
        "        self._register_hooks()",
        "",
        "    def _register_hooks(self):",
        "        \"\"\"Set up default hooks for development workflow.\"\"\"",
        "",
        "        # Pre-execution: log command start",
        "        def log_start(ctx: ExecutionContext):",
        "            if self.verbose:",
        "                print(f\"â†’ {ctx.command_str}\")",
        "",
        "        self.wrapper.hooks.register_pre(None, log_start)",
        "",
        "        # Post-execution: track in context window",
        "        def track_context(ctx: ExecutionContext):",
        "            self.context_manager.add_execution(ctx)",
        "",
        "        self.wrapper.hooks.register_post(None, track_context)",
        "",
        "        # Git commit success: suggest re-indexing",
        "        def on_commit_success(ctx: ExecutionContext):",
        "            if self.auto_reindex and ctx.task_type == 'commit' and ctx.success:",
        "                print(\"\\nðŸ’¡ Code committed. Consider re-indexing:\")",
        "                print(\"   python scripts/index_codebase.py --incremental\")",
        "",
        "        self.wrapper.hooks.register_success('git commit', on_commit_success)",
        "        # Test completion: log results",
        "        def on_test_complete(ctx: ExecutionContext):",
        "            if ctx.task_type == 'test':",
        "                status = \"âœ“ PASS\" if ctx.success else \"âœ— FAIL\"",
        "                print(f\"\\n{status} ({ctx.duration:.2f}s)\")",
        "",
        "                # Log detailed results",
        "                self._log_test_result(ctx)",
        "",
        "        self.wrapper.hooks.register_post('pytest', on_test_complete)",
        "        self.wrapper.hooks.register_post('python -m unittest', on_test_complete)",
        "        self.wrapper.hooks.register_post('python -m pytest', on_test_complete)",
        "",
        "    def _log_test_result(self, ctx: ExecutionContext):",
        "        \"\"\"Log test results to file.\"\"\"",
        "        log_file = self.log_dir / 'test_results.jsonl'",
        "            'output_lines': ctx.output_lines,",
        "            'error_lines': ctx.error_lines,",
        "            'git_commit': ctx.git.commit_hash,",
        "        \"\"\"Execute a command with full context collection.\"\"\"",
        "        return self.wrapper.run(command, **kwargs)",
        "    def get_session_summary(self) -> dict:",
        "        return self.completion_manager.get_session_summary()",
        "",
        "    def get_context_summary(self) -> dict:",
        "        \"\"\"Get context window state summary.\"\"\"",
        "        return self.context_manager.get_context_summary()",
        "        return self.completion_manager.should_trigger_reindex()",
        "",
        "",
        "# =============================================================================",
        "# Specialized Wrappers",
        "# =============================================================================",
        "",
        "class GitWrapper(DevWrapper):",
        "    \"\"\"Git-specific wrapper with additional context collection.\"\"\"",
        "",
        "    def __init__(self, **kwargs):",
        "        super().__init__(**kwargs)",
        "",
        "        # Track files changed per commit",
        "        def track_commit_files(ctx: ExecutionContext):",
        "            if 'commit' in ctx.command_str and ctx.success:",
        "                ctx.metadata['committed_files'] = ctx.git.staged_files.copy()",
        "",
        "        self.wrapper.hooks.register_success('git commit', track_commit_files)",
        "",
        "    def status(self) -> ExecutionContext:",
        "        \"\"\"Run git status.\"\"\"",
        "        return self.run(['git', 'status'])",
        "",
        "    def diff(self, staged: bool = False) -> ExecutionContext:",
        "        \"\"\"Run git diff.\"\"\"",
        "        cmd = ['git', 'diff']",
        "        if staged:",
        "            cmd.append('--staged')",
        "        return self.run(cmd)",
        "",
        "    def log(self, count: int = 5) -> ExecutionContext:",
        "        \"\"\"Run git log.\"\"\"",
        "        return self.run(['git', 'log', f'-{count}', '--oneline'])",
        "",
        "    def add(self, *paths: str) -> ExecutionContext:",
        "        \"\"\"Run git add.\"\"\"",
        "        return self.run(['git', 'add'] + list(paths))",
        "",
        "    def commit(self, message: str) -> ExecutionContext:",
        "        \"\"\"Run git commit.\"\"\"",
        "        return self.run(['git', 'commit', '-m', message])",
        "",
        "",
        "class TestWrapper(DevWrapper):",
        "    \"\"\"Test runner wrapper with result tracking.\"\"\"",
        "",
        "    def __init__(self, **kwargs):",
        "        super().__init__(**kwargs)",
        "        self.test_history: List[ExecutionContext] = []",
        "",
        "        # Track test results",
        "        def track_test(ctx: ExecutionContext):",
        "            if ctx.task_type == 'test':",
        "                self.test_history.append(ctx)",
        "        self.wrapper.hooks.register_post(None, track_test)",
        "    def pytest(self, *args: str, **kwargs) -> ExecutionContext:",
        "        \"\"\"Run pytest with given arguments.\"\"\"",
        "        cmd = ['pytest'] + list(args)",
        "        return self.run(cmd, **kwargs)",
        "",
        "    def unittest(self, pattern: str = 'tests/', **kwargs) -> ExecutionContext:",
        "        \"\"\"Run unittest discover.\"\"\"",
        "        cmd = ['python', '-m', 'unittest', 'discover', '-s', pattern, '-v']",
        "        return self.run(cmd, **kwargs)",
        "",
        "    def get_test_summary(self) -> dict:",
        "        \"\"\"Get summary of test runs in this session.\"\"\"",
        "        if not self.test_history:",
        "            return {'runs': 0, 'passes': 0, 'failures': 0}",
        "",
        "        return {",
        "            'runs': len(self.test_history),",
        "            'passes': sum(1 for t in self.test_history if t.success),",
        "            'failures': sum(1 for t in self.test_history if not t.success),",
        "            'total_duration': sum(t.duration for t in self.test_history),",
        "            'last_run': self.test_history[-1].timestamp if self.test_history else None,",
        "        }",
        "",
        "",
        "# =============================================================================",
        "# Singleton Instances",
        "# =============================================================================",
        "",
        "# Global wrapper instances for convenience",
        "_git_wrapper: Optional[GitWrapper] = None",
        "_test_wrapper: Optional[TestWrapper] = None",
        "_dev_wrapper: Optional[DevWrapper] = None",
        "",
        "",
        "def get_git_wrapper(**kwargs) -> GitWrapper:",
        "    \"\"\"Get or create the global git wrapper.\"\"\"",
        "    global _git_wrapper",
        "    if _git_wrapper is None:",
        "        _git_wrapper = GitWrapper(**kwargs)",
        "    return _git_wrapper",
        "",
        "",
        "def get_test_wrapper(**kwargs) -> TestWrapper:",
        "    \"\"\"Get or create the global test wrapper.\"\"\"",
        "    global _test_wrapper",
        "    if _test_wrapper is None:",
        "        _test_wrapper = TestWrapper(**kwargs)",
        "    return _test_wrapper",
        "",
        "",
        "def get_dev_wrapper(**kwargs) -> DevWrapper:",
        "    \"\"\"Get or create the global development wrapper.\"\"\"",
        "    global _dev_wrapper",
        "    if _dev_wrapper is None:",
        "        _dev_wrapper = DevWrapper(**kwargs)",
        "    return _dev_wrapper",
        "",
        "",
        "# Convenience aliases",
        "git_wrapper = get_git_wrapper",
        "test_wrapper = get_test_wrapper",
        "dev_wrapper = get_dev_wrapper",
        "# CLI Interface",
        "    \"\"\"CLI entry point for wrapped commands.\"\"\"",
        "        description='Context-aware CLI wrapper for development commands',",
        "    %(prog)s git status",
        "    %(prog)s git log -5 --oneline",
        "    %(prog)s test pytest tests/ -v",
        "    %(prog)s run echo \"hello world\"",
        "    %(prog)s --summary",
        "        'wrapper_type',",
        "        choices=['git', 'test', 'run'],",
        "        help='Type of wrapper to use'",
        "        '-v', '--verbose',",
        "        action='store_true',",
        "        help='Verbose output'",
        "    )",
        "    parser.add_argument(",
        "        '--summary',",
        "        help='Show session summary'",
        "        help='Output results as JSON'",
        "    # Handle summary request",
        "    if args.summary:",
        "        wrapper = get_dev_wrapper(verbose=args.verbose)",
        "        summary = {",
        "            'session': wrapper.get_session_summary(),",
        "            'context': wrapper.get_context_summary(),",
        "            'should_reindex': wrapper.should_reindex(),",
        "        }",
        "        if args.json:",
        "            print(json.dumps(summary, indent=2))",
        "        else:",
        "            print(\"Session Summary:\")",
        "            print(f\"  Tasks: {summary['session']['task_count']}\")",
        "            print(f\"  Success Rate: {summary['session']['success_rate']:.1%}\")",
        "            print(f\"  Total Duration: {summary['session']['total_duration']:.2f}s\")",
        "            print(f\"\\nContext Window:\")",
        "            print(f\"  Items: {summary['context']['total_items']}\")",
        "            print(f\"  Files Accessed: {summary['context']['unique_files_accessed']}\")",
        "            if summary['should_reindex']:",
        "                print(\"\\nðŸ’¡ Re-indexing recommended\")",
        "        return 0",
        "",
        "    # Need wrapper type and command",
        "    if not args.wrapper_type:",
        "        parser.print_help()",
        "        return 1",
        "",
        "        print(f\"Error: No command specified for '{args.wrapper_type}' wrapper\")",
        "    # Select wrapper",
        "    if args.wrapper_type == 'git':",
        "        wrapper = get_git_wrapper(verbose=args.verbose)",
        "        cmd = ['git'] + args.command",
        "    elif args.wrapper_type == 'test':",
        "        wrapper = get_test_wrapper(verbose=args.verbose)",
        "        cmd = args.command",
        "    else:  # 'run'",
        "        wrapper = get_dev_wrapper(verbose=args.verbose)",
        "        cmd = args.command",
        "",
        "    # Execute",
        "    result = wrapper.run(cmd)"
      ],
      "context_before": [
        "#!/usr/bin/env python3",
        "\"\"\"",
        "Example CLI wrappers for common development tasks.",
        ""
      ],
      "context_after": [
        "",
        "Usage:",
        "",
        "",
        "    # As CLI",
        "\"\"\"",
        "",
        "import argparse",
        "import json",
        "import os",
        "import sys",
        "from datetime import datetime",
        "from pathlib import Path",
        "from typing import List, Optional",
        "",
        "# Add parent directory for imports",
        "sys.path.insert(0, str(Path(__file__).parent.parent))",
        "",
        "from cortical.cli_wrapper import (",
        "    CLIWrapper,",
        "    ExecutionContext,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        ")",
        "",
        "",
        "# =============================================================================",
        "# Context-Aware Wrapper Configuration",
        "# =============================================================================",
        "",
        "class DevWrapper:",
        "    \"\"\"",
        "",
        "    \"\"\"",
        "",
        "    def __init__(",
        "        self,",
        "        log_dir: Optional[str] = None,",
        "    ):",
        "            self.log_dir.mkdir(exist_ok=True)",
        "",
        "",
        "",
        "        entry = {",
        "            'timestamp': ctx.timestamp,",
        "            'command': ctx.command_str,",
        "            'success': ctx.success,",
        "            'duration': ctx.duration,",
        "            'exit_code': ctx.exit_code,",
        "            'git_branch': ctx.git.branch,",
        "        }",
        "",
        "        with open(log_file, 'a') as f:",
        "            f.write(json.dumps(entry) + '\\n')",
        "",
        "    def run(self, command: List[str], **kwargs) -> ExecutionContext:",
        "",
        "        \"\"\"Get summary of session activity.\"\"\"",
        "",
        "    def should_reindex(self) -> bool:",
        "        \"\"\"Check if re-indexing is recommended.\"\"\"",
        "",
        "",
        "",
        "",
        "# =============================================================================",
        "# =============================================================================",
        "",
        "def main():",
        "    parser = argparse.ArgumentParser(",
        "        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "        epilog=\"\"\"",
        "Examples:",
        "        \"\"\"",
        "    )",
        "",
        "    parser.add_argument(",
        "        nargs='?',",
        "    )",
        "    parser.add_argument(",
        "        'command',",
        "        nargs='*',",
        "        help='Command to execute'",
        "    )",
        "    parser.add_argument(",
        "        action='store_true',",
        "    )",
        "    parser.add_argument(",
        "        '--json',",
        "        action='store_true',",
        "    )",
        "",
        "    args = parser.parse_args()",
        "",
        "    if not args.command:",
        "        return 1",
        "",
        "",
        "    # Output",
        "    if args.json:",
        "        print(result.to_json())",
        "    else:",
        "        if result.stdout:",
        "            print(result.stdout, end='')",
        "        if result.stderr:",
        "            print(result.stderr, end='', file=sys.stderr)",
        ""
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": "sys.path.insert(0, str(Path(__file__).parent.parent))",
      "start_line": 24,
      "lines_added": [
        "    run,",
        "    Session,"
      ],
      "lines_removed": [],
      "context_before": [
        "from cortical.cli_wrapper import (",
        "    ExecutionContext,",
        "    GitContext,",
        "    HookRegistry,",
        "    HookType,",
        "    CLIWrapper,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    create_wrapper_with_completion_manager,",
        "    run_with_context,"
      ],
      "context_after": [
        ")",
        "",
        "",
        "class TestGitContext(unittest.TestCase):",
        "    \"\"\"Tests for GitContext collection.\"\"\"",
        "",
        "    def test_collect_non_repo(self):",
        "        \"\"\"Test collection outside git repo.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            ctx = GitContext.collect(tmpdir)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": "class TestIntegration(unittest.TestCase):",
      "start_line": 553,
      "lines_added": [
        "class TestSimpleRunAPI(unittest.TestCase):",
        "    \"\"\"Tests for the simple run() API.\"\"\"",
        "",
        "    def test_run_basic(self):",
        "        \"\"\"Test basic run() usage.\"\"\"",
        "        result = run(\"echo hello\")",
        "        self.assertTrue(result.success)",
        "        self.assertIn(\"hello\", result.stdout)",
        "",
        "    def test_run_no_git_by_default(self):",
        "        \"\"\"Test that git context is not collected by default.\"\"\"",
        "        result = run(\"echo test\")",
        "        # Git context should be empty/default when git=False",
        "        self.assertFalse(result.git.is_repo)",
        "",
        "    def test_run_with_git(self):",
        "        \"\"\"Test run with git context.\"\"\"",
        "        result = run(\"echo test\", git=True)",
        "        # We're in a git repo, so this should be True",
        "        self.assertTrue(result.git.is_repo)",
        "        self.assertTrue(len(result.git.branch) > 0)",
        "",
        "    def test_run_with_timeout(self):",
        "        \"\"\"Test run with timeout.\"\"\"",
        "        result = run(\"python -c 'import time; time.sleep(10)'\", timeout=0.1)",
        "        self.assertFalse(result.success)",
        "",
        "    def test_run_failure(self):",
        "        \"\"\"Test run with failing command.\"\"\"",
        "        result = run([\"python\", \"-c\", \"import sys; sys.exit(42)\"])",
        "        self.assertFalse(result.success)",
        "        self.assertEqual(result.exit_code, 42)",
        "",
        "",
        "class TestSession(unittest.TestCase):",
        "    \"\"\"Tests for Session context manager.\"\"\"",
        "",
        "    def test_session_basic(self):",
        "        \"\"\"Test basic session usage.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo first\")",
        "            s.run(\"echo second\")",
        "",
        "        self.assertEqual(len(s.results), 2)",
        "        self.assertTrue(s.all_passed)",
        "",
        "    def test_session_tracks_failures(self):",
        "        \"\"\"Test session tracks failures correctly.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo ok\")",
        "            s.run(\"python -c 'import sys; sys.exit(1)'\")",
        "            s.run(\"echo also ok\")",
        "",
        "        self.assertEqual(len(s.results), 3)",
        "        self.assertFalse(s.all_passed)",
        "        self.assertAlmostEqual(s.success_rate, 2/3, places=2)",
        "",
        "    def test_session_summary(self):",
        "        \"\"\"Test session summary.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo test\")",
        "            summary = s.summary()",
        "",
        "        self.assertEqual(summary['task_count'], 1)",
        "        self.assertEqual(summary['success_rate'], 1.0)",
        "",
        "    def test_session_should_reindex(self):",
        "        \"\"\"Test should_reindex detection.\"\"\"",
        "        with Session(git=True) as s:",
        "            # Just an echo - no code changes",
        "            s.run(\"echo test\")",
        "",
        "        # No commits or file changes, shouldn't need reindex",
        "        # (Unless the test repo is dirty)",
        "        # Just verify it returns a boolean",
        "        self.assertIsInstance(s.should_reindex(), bool)",
        "",
        "    def test_session_context_manager(self):",
        "        \"\"\"Test session works as context manager.\"\"\"",
        "        results_outside = []",
        "",
        "        with Session(git=False) as s:",
        "            result = s.run(\"echo inside\")",
        "            results_outside.append(result)",
        "",
        "        # Can still access results after exiting",
        "        self.assertEqual(len(s.results), 1)",
        "        self.assertTrue(s.results[0].success)",
        "",
        "",
        "class TestDecoratorHooks(unittest.TestCase):",
        "    \"\"\"Tests for decorator-style hook registration.\"\"\"",
        "",
        "    def test_on_success_decorator(self):",
        "        \"\"\"Test @wrapper.on_success decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        calls = []",
        "",
        "        @wrapper.on_success()",
        "        def track_success(ctx):",
        "            calls.append(('success', ctx.command_str))",
        "",
        "        wrapper.run(\"echo hello\")",
        "        wrapper.run(\"python -c 'import sys; sys.exit(1)'\")",
        "",
        "        # Only the successful command should trigger",
        "        self.assertEqual(len(calls), 1)",
        "        self.assertEqual(calls[0][0], 'success')",
        "",
        "    def test_on_error_decorator(self):",
        "        \"\"\"Test @wrapper.on_error decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        errors = []",
        "",
        "        @wrapper.on_error()",
        "        def track_error(ctx):",
        "            errors.append(ctx.exit_code)",
        "",
        "        wrapper.run([\"echo\", \"hello\"])  # success",
        "        wrapper.run([\"python\", \"-c\", \"import sys; sys.exit(1)\"])  # fail",
        "        wrapper.run([\"python\", \"-c\", \"import sys; sys.exit(2)\"])  # fail",
        "",
        "        self.assertEqual(len(errors), 2)",
        "        self.assertEqual(errors, [1, 2])",
        "",
        "    def test_on_complete_decorator(self):",
        "        \"\"\"Test @wrapper.on_complete decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        completions = []",
        "",
        "        @wrapper.on_complete()",
        "        def track_all(ctx):",
        "            completions.append(ctx.success)",
        "",
        "        wrapper.run(\"echo hello\")",
        "        wrapper.run(\"python -c 'import sys; sys.exit(1)'\")",
        "",
        "        self.assertEqual(completions, [True, False])",
        "",
        "    def test_pattern_decorator(self):",
        "        \"\"\"Test decorator with pattern matching.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        echo_count = [0]",
        "",
        "        @wrapper.on_success(\"echo\")",
        "        def on_echo_success(ctx):",
        "            echo_count[0] += 1",
        "",
        "        wrapper.run(\"echo one\")",
        "        wrapper.run(\"echo two\")",
        "        wrapper.run(\"python -c 'print(1)'\")  # Not echo",
        "",
        "        self.assertEqual(echo_count[0], 2)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        self.assertTrue(completion_data[0]['success'])",
        "        self.assertTrue(completion_data[1]['success'])",
        "        self.assertFalse(completion_data[2]['success'])",
        "",
        "        # Verify session summary",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 3)",
        "        self.assertAlmostEqual(summary['success_rate'], 2/3, places=2)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 17,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -333020,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}