{
  "hash": "1fafc8b38522fd45a0fa06a90ac1696aaad73ff3",
  "message": "fix: Add test file penalty and code stop word filtering to search",
  "author": "Claude",
  "timestamp": "2025-12-14 23:46:18 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/processor/query_api.py",
    "cortical/query/passages.py",
    "cortical/query/search.py"
  ],
  "insertions": 51,
  "deletions": 9,
  "hunks": [
    {
      "file": "cortical/processor/query_api.py",
      "function": "class QueryMixin:",
      "start_line": 302,
      "lines_added": [
        "        use_semantic: bool = True,",
        "        filter_code_stop_words: bool = True,",
        "        test_file_penalty: float = 0.8",
        "            filter_code_stop_words: Filter ubiquitous code tokens (self, def, return)",
        "                                    from expansion. Reduces noise in code search. (default True)",
        "            test_file_penalty: Multiplier for test files to rank them lower (default 0.8).",
        "                               Set to 1.0 to disable penalty.",
        "            use_semantic=use_semantic,",
        "            filter_code_stop_words=filter_code_stop_words,",
        "            test_file_penalty=test_file_penalty"
      ],
      "lines_removed": [
        "        use_semantic: bool = True",
        "            use_semantic=use_semantic"
      ],
      "context_before": [
        "            decay_factor=decay_factor,",
        "            min_path_score=min_path_score",
        "        )",
        "",
        "    @timed(\"find_documents_for_query\", include_args=True)",
        "    def find_documents_for_query(",
        "        self,",
        "        query_text: str,",
        "        top_n: int = 5,",
        "        use_expansion: bool = True,"
      ],
      "context_after": [
        "    ) -> List[Tuple[str, float]]:",
        "        \"\"\"",
        "        Find documents most relevant to a query.",
        "",
        "        Args:",
        "            query_text: Search query",
        "            top_n: Number of documents to return",
        "            use_expansion: Whether to expand query terms",
        "            use_semantic: Whether to use semantic relations for expansion",
        "",
        "        Returns:",
        "            List of (doc_id, score) tuples ranked by relevance",
        "",
        "        Raises:",
        "            ValueError: If query_text is empty or top_n is not positive",
        "        \"\"\"",
        "        if not isinstance(query_text, str) or not query_text.strip():",
        "            raise ValueError(\"query_text must be a non-empty string\")",
        "        if not isinstance(top_n, int) or top_n < 1:",
        "            raise ValueError(\"top_n must be a positive integer\")",
        "",
        "        return query_module.find_documents_for_query(",
        "            query_text,",
        "            self.layers,",
        "            self.tokenizer,",
        "            top_n=top_n,",
        "            use_expansion=use_expansion,",
        "            semantic_relations=self.semantic_relations if use_semantic else None,",
        "        )",
        "",
        "    def fast_find_documents(",
        "        self,",
        "        query_text: str,",
        "        top_n: int = 5,",
        "        candidate_multiplier: int = 3,",
        "        use_code_concepts: bool = True",
        "    ) -> List[Tuple[str, float]]:",
        "        \"\"\""
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/processor/query_api.py",
      "function": "class QueryMixin:",
      "start_line": 516,
      "lines_added": [
        "        use_code_aware_chunks: bool = True,",
        "        filter_code_stop_words: bool = True,",
        "        test_file_penalty: float = 0.8",
        "            filter_code_stop_words: Filter ubiquitous code tokens (self, def, return)",
        "                                    from expansion. Reduces noise in code search. (default True)",
        "            test_file_penalty: Multiplier for test files to rank them lower (default 0.8).",
        "                               Set to 1.0 to disable penalty."
      ],
      "lines_removed": [
        "        use_code_aware_chunks: bool = True"
      ],
      "context_before": [
        "        overlap: Optional[int] = None,",
        "        use_expansion: bool = True,",
        "        doc_filter: Optional[List[str]] = None,",
        "        use_semantic: bool = True,",
        "        use_definition_search: bool = True,",
        "        definition_boost: float = 5.0,",
        "        apply_doc_boost: bool = True,",
        "        auto_detect_intent: bool = True,",
        "        prefer_docs: bool = False,",
        "        custom_boosts: Optional[Dict[str, float]] = None,"
      ],
      "context_after": [
        "    ) -> List[Tuple[str, str, int, int, float]]:",
        "        \"\"\"",
        "        Find text passages most relevant to a query (for RAG systems).",
        "",
        "        Args:",
        "            query_text: Search query",
        "            top_n: Number of passages to return",
        "            chunk_size: Size of each chunk in characters (default from config)",
        "            overlap: Overlap between chunks in characters (default from config)",
        "            use_expansion: Whether to expand query terms",
        "            doc_filter: Optional list of doc_ids to restrict search to",
        "            use_semantic: Whether to use semantic relations for expansion",
        "            use_definition_search: Whether to search for definition patterns",
        "            definition_boost: Score boost for definition matches",
        "            apply_doc_boost: Whether to apply document-type boosting",
        "            auto_detect_intent: Auto-detect conceptual queries and boost docs",
        "            prefer_docs: Always boost documentation",
        "            custom_boosts: Optional custom boost factors for doc types",
        "            use_code_aware_chunks: Use semantic boundaries for code files",
        "",
        "        Returns:",
        "            List of (passage_text, doc_id, start_char, end_char, score) tuples",
        "",
        "        Raises:",
        "            ValueError: If query_text is empty or parameters are invalid",
        "        \"\"\"",
        "        if not isinstance(query_text, str) or not query_text.strip():",
        "            raise ValueError(\"query_text must be a non-empty string\")",
        "        if not isinstance(top_n, int) or top_n < 1:"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/processor/query_api.py",
      "function": "class QueryMixin:",
      "start_line": 581,
      "lines_added": [
        "            use_code_aware_chunks=use_code_aware_chunks,",
        "            filter_code_stop_words=filter_code_stop_words,",
        "            test_file_penalty=test_file_penalty"
      ],
      "lines_removed": [
        "            use_code_aware_chunks=use_code_aware_chunks"
      ],
      "context_before": [
        "            doc_filter=doc_filter,",
        "            semantic_relations=self.semantic_relations if use_semantic else None,",
        "            use_semantic=use_semantic,",
        "            use_definition_search=use_definition_search,",
        "            definition_boost=definition_boost,",
        "            apply_doc_boost=apply_doc_boost,",
        "            doc_metadata=self.document_metadata,",
        "            auto_detect_intent=auto_detect_intent,",
        "            prefer_docs=prefer_docs,",
        "            custom_boosts=custom_boosts,"
      ],
      "context_after": [
        "        )",
        "",
        "    def is_definition_query(self, query_text: str) -> Tuple[bool, Optional[str], Optional[str]]:",
        "        \"\"\"Detect if a query is looking for a code definition.\"\"\"",
        "        return query_module.is_definition_query(query_text)",
        "",
        "    def find_definition_passages(",
        "        self,",
        "        query_text: str,",
        "        context_chars: int = 500,"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/passages.py",
      "function": "def find_passages_for_query(",
      "start_line": 47,
      "lines_added": [
        "    use_code_aware_chunks: bool = True,",
        "    filter_code_stop_words: bool = True,",
        "    test_file_penalty: float = 0.8"
      ],
      "lines_removed": [
        "    use_code_aware_chunks: bool = True"
      ],
      "context_before": [
        "    doc_filter: Optional[List[str]] = None,",
        "    semantic_relations: Optional[List[Tuple[str, str, str, float]]] = None,",
        "    use_semantic: bool = True,",
        "    use_definition_search: bool = True,",
        "    definition_boost: float = DEFINITION_BOOST,",
        "    apply_doc_boost: bool = True,",
        "    doc_metadata: Optional[Dict[str, Dict[str, Any]]] = None,",
        "    auto_detect_intent: bool = True,",
        "    prefer_docs: bool = False,",
        "    custom_boosts: Optional[Dict[str, float]] = None,"
      ],
      "context_after": [
        ") -> List[Tuple[str, str, int, int, float]]:",
        "    \"\"\"",
        "    Find text passages most relevant to a query.",
        "",
        "    This is the key function for RAG systems - instead of returning document IDs,",
        "    it returns actual text passages with position information for citations.",
        "",
        "    For definition queries (e.g., \"class Minicolumn\", \"def compute_pagerank\"),",
        "    this function will directly search for the definition pattern and inject",
        "    those results with a high score, ensuring definitions appear in top results."
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/passages.py",
      "function": "def find_passages_for_query(",
      "start_line": 86,
      "lines_added": [
        "        filter_code_stop_words: Filter ubiquitous code tokens (self, def, return)",
        "                                from expansion. Reduces noise in code search. (default True)",
        "        test_file_penalty: Multiplier for test files to rank them lower (default 0.8).",
        "                           Set to 1.0 to disable penalty."
      ],
      "lines_removed": [],
      "context_before": [
        "        semantic_relations: Optional list of semantic relations for expansion",
        "        use_semantic: Whether to use semantic relations for expansion (if available)",
        "        use_definition_search: Whether to search for definition patterns (default True)",
        "        definition_boost: Score boost for definition matches (default 5.0)",
        "        apply_doc_boost: Whether to apply document-type boosting (default True)",
        "        doc_metadata: Optional metadata dict {doc_id: {doc_type: ..., ...}}",
        "        auto_detect_intent: Auto-detect conceptual queries and boost docs (default True)",
        "        prefer_docs: Always boost documentation regardless of query type (default False)",
        "        custom_boosts: Optional custom boost factors for doc types",
        "        use_code_aware_chunks: Use semantic boundaries for code files (default True)"
      ],
      "context_after": [
        "",
        "    Returns:",
        "        List of (passage_text, doc_id, start_char, end_char, score) tuples",
        "        ranked by relevance",
        "    \"\"\"",
        "    layer0 = layers[CorticalLayer.TOKENS]",
        "",
        "    # Determine if we should apply doc-type boosting",
        "    should_boost = apply_doc_boost and (",
        "        prefer_docs or (auto_detect_intent and is_conceptual_query(query_text))"
      ],
      "change_type": "add"
    },
    {
      "file": "cortical/query/passages.py",
      "function": "def find_passages_for_query(",
      "start_line": 113,
      "lines_added": [
        "        use_semantic=use_semantic,",
        "        filter_code_stop_words=filter_code_stop_words"
      ],
      "lines_removed": [
        "        use_semantic=use_semantic"
      ],
      "context_before": [
        "            docs_to_search = {k: v for k, v in documents.items() if k in doc_filter}",
        "        definition_passages = find_definition_passages(",
        "            query_text, docs_to_search, chunk_size, definition_boost",
        "        )",
        "",
        "    # Get expanded query terms",
        "    query_terms = get_expanded_query_terms(",
        "        query_text, layers, tokenizer,",
        "        use_expansion=use_expansion,",
        "        semantic_relations=semantic_relations,"
      ],
      "context_after": [
        "    )",
        "",
        "    if not query_terms and not definition_passages:",
        "        return []",
        "",
        "    # If we only have definition results, apply boosting and return",
        "    if not query_terms:",
        "        if should_boost:",
        "            definition_passages = [",
        "                (p[0], p[1], p[2], p[3], p[4] * get_doc_type_boost(p[1], doc_metadata, custom_boosts))"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/passages.py",
      "function": "def find_passages_for_query(",
      "start_line": 144,
      "lines_added": [
        "            use_semantic=use_semantic,",
        "            filter_code_stop_words=filter_code_stop_words,",
        "            test_file_penalty=test_file_penalty"
      ],
      "lines_removed": [
        "            use_semantic=use_semantic"
      ],
      "context_before": [
        "        # Use provided filter directly as candidates (caller may have pre-boosted)",
        "        # Assign dummy scores since we'll re-score passages anyway",
        "        doc_scores = [(doc_id, 1.0) for doc_id in doc_filter if doc_id in documents]",
        "    else:",
        "        # No filter - get candidates via document search",
        "        doc_scores = find_documents_for_query(",
        "            query_text, layers, tokenizer,",
        "            top_n=min(len(documents), top_n * 3),",
        "            use_expansion=use_expansion,",
        "            semantic_relations=semantic_relations,"
      ],
      "context_after": [
        "        )",
        "",
        "    # Score passages within candidate documents",
        "    passages: List[Tuple[str, str, int, int, float]] = []",
        "",
        "    # Track definition passage locations to avoid duplicates",
        "    def_locations = {(p[1], p[2], p[3]) for p in definition_passages}",
        "",
        "    for doc_id, doc_score in doc_scores:",
        "        if doc_id not in documents:"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/search.py",
      "function": "from .expansion import expand_query, get_expanded_query_terms",
      "start_line": 23,
      "lines_added": [
        "    doc_name_boost: float = 2.0,",
        "    filter_code_stop_words: bool = True,",
        "    test_file_penalty: float = 0.8",
        "        filter_code_stop_words: Filter ubiquitous code tokens (self, def, return)",
        "                                from expansion candidates. Reduces noise in code search. (default True)",
        "        test_file_penalty: Multiplier for test files to rank them lower (default 0.8).",
        "                           Set to 1.0 to disable penalty.",
        "        use_semantic=use_semantic,",
        "        filter_code_stop_words=filter_code_stop_words"
      ],
      "lines_removed": [
        "    doc_name_boost: float = 2.0",
        "        use_semantic=use_semantic"
      ],
      "context_before": [
        "",
        "",
        "def find_documents_for_query(",
        "    query_text: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    tokenizer: Tokenizer,",
        "    top_n: int = 5,",
        "    use_expansion: bool = True,",
        "    semantic_relations: Optional[List[Tuple[str, str, str, float]]] = None,",
        "    use_semantic: bool = True,"
      ],
      "context_after": [
        ") -> List[Tuple[str, float]]:",
        "    \"\"\"",
        "    Find documents most relevant to a query using TF-IDF and optional expansion.",
        "",
        "    Args:",
        "        query_text: Search query",
        "        layers: Dictionary of layers",
        "        tokenizer: Tokenizer instance",
        "        top_n: Number of documents to return",
        "        use_expansion: Whether to expand query terms using lateral connections",
        "        semantic_relations: Optional list of semantic relations for expansion",
        "        use_semantic: Whether to use semantic relations for expansion (if available)",
        "        doc_name_boost: Multiplier for documents whose name matches query terms (default 2.0)",
        "",
        "    Returns:",
        "        List of (doc_id, score) tuples ranked by relevance",
        "    \"\"\"",
        "    layer0 = layers[CorticalLayer.TOKENS]",
        "    layer3 = layers[CorticalLayer.DOCUMENTS]",
        "",
        "    query_terms = get_expanded_query_terms(",
        "        query_text, layers, tokenizer,",
        "        use_expansion=use_expansion,",
        "        semantic_relations=semantic_relations,",
        "    )",
        "",
        "    # Score each document",
        "    doc_scores: Dict[str, float] = defaultdict(float)",
        "",
        "    for term, term_weight in query_terms.items():",
        "        col = layer0.get_minicolumn(term)",
        "        if col:",
        "            for doc_id in col.document_ids:",
        "                tfidf = col.tfidf_per_doc.get(doc_id, col.tfidf)"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/query/search.py",
      "function": "def find_documents_for_query(",
      "start_line": 101,
      "lines_added": [
        "    # Apply test file penalty to reduce test file ranking",
        "    if test_file_penalty < 1.0:",
        "        for doc_id in list(doc_scores.keys()):",
        "            # Detect test files by path patterns",
        "            if (doc_id.startswith('tests/') or",
        "                doc_id.startswith('test_') or",
        "                '/test_' in doc_id or",
        "                '/tests/' in doc_id):",
        "                doc_scores[doc_id] *= test_file_penalty",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        for doc_id in exact_matches:",
        "            # For exact matches, add max_score to ensure they rank first",
        "            # This guarantees exact match beats all other documents",
        "            doc_scores[doc_id] += max_score * doc_name_boost",
        "",
        "        for doc_id, match_ratio in partial_matches:",
        "            # Partial matches use proportional boost",
        "            boost = 1 + (doc_name_boost - 1) * match_ratio",
        "            doc_scores[doc_id] *= boost",
        ""
      ],
      "context_after": [
        "    sorted_docs = sorted(doc_scores.items(), key=lambda x: -x[1])",
        "    return sorted_docs[:top_n]",
        "",
        "",
        "def fast_find_documents(",
        "    query_text: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    tokenizer: Tokenizer,",
        "    top_n: int = 5,",
        "    candidate_multiplier: int = 3,"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 23,
  "day_of_week": "Sunday",
  "seconds_since_last_commit": -50310,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}