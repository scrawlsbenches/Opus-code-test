{
  "hash": "389b8f4391a66fa661f39c86b70b09273d160470",
  "message": "Add comprehensive MCP server tests to achieve 98% coverage",
  "author": "Claude",
  "timestamp": "2025-12-13 17:22:43 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "tests/test_mcp_server.py"
  ],
  "insertions": 359,
  "deletions": 0,
  "hunks": [
    {
      "file": "tests/test_mcp_server.py",
      "function": "class TestMCPServerIntegration(unittest.TestCase):",
      "start_line": 406,
      "lines_added": [
        "class TestExceptionHandlers(unittest.TestCase):",
        "    \"\"\"Test exception handlers in MCP tools to ensure graceful error handling.\"\"\"",
        "",
        "    def setUp(self):",
        "        \"\"\"Set up test server.\"\"\"",
        "        self.server = create_mcp_server()",
        "        # Add a document so we have something to work with",
        "        self.server.processor.process_document(\"doc1\", \"Test content for errors.\")",
        "        self.server.processor.compute_all()",
        "",
        "    def test_search_exception_handler(self):",
        "        \"\"\"Test search tool handles processor exceptions gracefully (lines 124-126).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        async def test_exception():",
        "            # Mock the processor to raise an exception",
        "            with patch.object(",
        "                self.server.processor,",
        "                'find_documents_for_query',",
        "                side_effect=RuntimeError(\"Simulated search error\")",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"search\", {\"query\": \"test\"})",
        "                result = metadata.get('result', {})",
        "",
        "                # Should return error gracefully, not raise",
        "                self.assertIn(\"error\", result)",
        "                self.assertIn(\"Simulated search error\", result[\"error\"])",
        "                self.assertEqual(result[\"results\"], [])",
        "                self.assertEqual(result[\"count\"], 0)",
        "",
        "        asyncio.run(test_exception())",
        "",
        "    def test_passages_exception_handler(self):",
        "        \"\"\"Test passages tool handles processor exceptions gracefully (lines 183-189).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        async def test_exception():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'find_passages_for_query',",
        "                side_effect=ValueError(\"Simulated passages error\")",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"passages\", {\"query\": \"test\"})",
        "                result = metadata.get('result', {})",
        "",
        "                self.assertIn(\"error\", result)",
        "                self.assertIn(\"Simulated passages error\", result[\"error\"])",
        "                self.assertEqual(result[\"passages\"], [])",
        "                self.assertEqual(result[\"count\"], 0)",
        "",
        "        asyncio.run(test_exception())",
        "",
        "    def test_expand_query_exception_handler(self):",
        "        \"\"\"Test expand_query tool handles processor exceptions gracefully (lines 230-232).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        async def test_exception():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'expand_query',",
        "                side_effect=KeyError(\"Simulated expansion error\")",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"expand_query\", {\"query\": \"test\"})",
        "                result = metadata.get('result', {})",
        "",
        "                self.assertIn(\"error\", result)",
        "                self.assertEqual(result[\"expansions\"], {})",
        "                self.assertEqual(result[\"count\"], 0)",
        "",
        "        asyncio.run(test_exception())",
        "",
        "    def test_corpus_stats_exception_handler(self):",
        "        \"\"\"Test corpus_stats tool handles processor exceptions gracefully (lines 261-263).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        async def test_exception():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'get_corpus_summary',",
        "                side_effect=AttributeError(\"Simulated stats error\")",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"corpus_stats\", {})",
        "                result = metadata.get('result', {})",
        "",
        "                self.assertIn(\"error\", result)",
        "                self.assertIn(\"Simulated stats error\", result[\"error\"])",
        "",
        "        asyncio.run(test_exception())",
        "",
        "    def test_add_document_exception_handler(self):",
        "        \"\"\"Test add_document tool handles processor exceptions gracefully (lines 314-316).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        async def test_exception():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'add_document_incremental',",
        "                side_effect=IOError(\"Simulated add document error\")",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"add_document\", {",
        "                    \"doc_id\": \"test_doc\",",
        "                    \"content\": \"Test content\"",
        "                })",
        "                result = metadata.get('result', {})",
        "",
        "                self.assertIn(\"error\", result)",
        "                self.assertIn(\"Simulated add document error\", result[\"error\"])",
        "                self.assertEqual(result[\"stats\"], {})",
        "",
        "        asyncio.run(test_exception())",
        "",
        "",
        "class TestMakeSerializable(unittest.TestCase):",
        "    \"\"\"Test the make_serializable function branches in corpus_stats.\"\"\"",
        "",
        "    def setUp(self):",
        "        \"\"\"Set up test server.\"\"\"",
        "        self.server = create_mcp_server()",
        "",
        "    def test_make_serializable_list_branch(self):",
        "        \"\"\"Test make_serializable handles list/tuple types (line 254).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        # Create a mock that returns a dict with list values",
        "        mock_stats = {",
        "            \"documents\": [\"doc1\", \"doc2\"],",
        "            \"nested\": [1, 2, [3, 4]],",
        "            \"tuple_data\": (1, 2, 3),  # Tuple should also be handled",
        "        }",
        "",
        "        async def test_list_handling():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'get_corpus_summary',",
        "                return_value=mock_stats",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"corpus_stats\", {})",
        "                result = metadata.get('result', {})",
        "",
        "                # Lists should be preserved",
        "                self.assertEqual(result[\"documents\"], [\"doc1\", \"doc2\"])",
        "                self.assertEqual(result[\"nested\"], [1, 2, [3, 4]])",
        "                # Tuples get converted to lists by JSON serialization",
        "                self.assertIsInstance(result[\"tuple_data\"], list)",
        "",
        "        asyncio.run(test_list_handling())",
        "",
        "    def test_make_serializable_custom_type_branch(self):",
        "        \"\"\"Test make_serializable converts custom types to string (line 258).\"\"\"",
        "        import asyncio",
        "        from unittest.mock import patch",
        "",
        "        # Custom class that isn't a primitive type",
        "        class CustomMetric:",
        "            def __init__(self, value):",
        "                self.value = value",
        "",
        "            def __str__(self):",
        "                return f\"CustomMetric({self.value})\"",
        "",
        "        mock_stats = {",
        "            \"custom_field\": CustomMetric(42),",
        "            \"nested_custom\": {",
        "                \"inner\": CustomMetric(100)",
        "            },",
        "            \"list_custom\": [CustomMetric(1), CustomMetric(2)]",
        "        }",
        "",
        "        async def test_custom_type_handling():",
        "            with patch.object(",
        "                self.server.processor,",
        "                'get_corpus_summary',",
        "                return_value=mock_stats",
        "            ):",
        "                content, metadata = await self.server.mcp.call_tool(\"corpus_stats\", {})",
        "                result = metadata.get('result', {})",
        "",
        "                # Custom types should be converted to strings",
        "                self.assertEqual(result[\"custom_field\"], \"CustomMetric(42)\")",
        "                self.assertEqual(result[\"nested_custom\"][\"inner\"], \"CustomMetric(100)\")",
        "                self.assertEqual(result[\"list_custom\"], [\"CustomMetric(1)\", \"CustomMetric(2)\"])",
        "",
        "        asyncio.run(test_custom_type_handling())",
        "",
        "",
        "class TestContentTypeValidation(unittest.TestCase):",
        "    \"\"\"Test content type validation in add_document.",
        "",
        "    Note: Line 292 (non-string content check) cannot be hit through normal MCP",
        "    usage because the MCP protocol serializes all inputs to JSON strings before",
        "    they reach the tool function. This validation is a defensive check for",
        "    potential direct API usage bypassing the MCP layer. Coverage is 98% with",
        "    this single unreachable line, which is acceptable and well-documented.",
        "    \"\"\"",
        "",
        "    def setUp(self):",
        "        \"\"\"Set up test server.\"\"\"",
        "        self.server = create_mcp_server()",
        "",
        "    def test_string_content_accepted(self):",
        "        \"\"\"Test that valid string content is accepted.\"\"\"",
        "        import asyncio",
        "",
        "        async def test_valid():",
        "            content, metadata = await self.server.mcp.call_tool(\"add_document\", {",
        "                \"doc_id\": \"valid_doc\",",
        "                \"content\": \"This is valid string content.\"",
        "            })",
        "            result = metadata.get('result', {})",
        "            # No error should be present",
        "            self.assertNotIn(\"error\", result)",
        "            self.assertIn(\"stats\", result)",
        "",
        "        asyncio.run(test_valid())",
        "",
        "    def test_content_validation_defensive_check_documented(self):",
        "        \"\"\"Document that non-string content check exists but is unreachable via MCP.",
        "",
        "        The validation at line 291-294:",
        "            if not isinstance(content, str):",
        "                return {\"error\": \"content must be a string\", \"stats\": {}}",
        "",
        "        This is unreachable because:",
        "        1. MCP protocol JSON-serializes all tool arguments",
        "        2. JSON only supports string values for this parameter",
        "        3. Any non-string input becomes a string before reaching the handler",
        "",
        "        This test documents this intentional design decision. The validation",
        "        exists for potential direct API usage bypassing MCP (e.g., if someone",
        "        imports CorticalMCPServer and calls methods directly without going",
        "        through the MCP protocol layer).",
        "        \"\"\"",
        "        # Verify the validation code exists in the source",
        "        import inspect",
        "        from cortical.mcp_server import CorticalMCPServer",
        "",
        "        source = inspect.getsource(CorticalMCPServer)",
        "        self.assertIn(\"not isinstance(content, str)\", source)",
        "        self.assertIn(\"content must be a string\", source)",
        "",
        "",
        "class TestServerRunAndMain(unittest.TestCase):",
        "    \"\"\"Test run() and main() functions.\"\"\"",
        "",
        "    def test_run_method_starts_server(self):",
        "        \"\"\"Test run() method calls mcp.run() with correct transport (lines 328-329).\"\"\"",
        "        from unittest.mock import patch, MagicMock",
        "",
        "        server = create_mcp_server()",
        "",
        "        # Mock the mcp.run() method to prevent actual server startup",
        "        with patch.object(server.mcp, 'run') as mock_run:",
        "            server.run(transport=\"stdio\")",
        "",
        "            # Verify mcp.run was called with correct transport",
        "            mock_run.assert_called_once_with(transport=\"stdio\")",
        "",
        "    def test_run_method_with_sse_transport(self):",
        "        \"\"\"Test run() method with SSE transport.\"\"\"",
        "        from unittest.mock import patch",
        "",
        "        server = create_mcp_server()",
        "",
        "        with patch.object(server.mcp, 'run') as mock_run:",
        "            server.run(transport=\"sse\")",
        "            mock_run.assert_called_once_with(transport=\"sse\")",
        "",
        "    def test_main_function(self):",
        "        \"\"\"Test main() function entry point (lines 361-372).\"\"\"",
        "        from unittest.mock import patch, MagicMock",
        "        import os",
        "",
        "        # Import main function",
        "        from cortical.mcp_server import main",
        "",
        "        # Mock environment variables and server creation",
        "        with patch.dict(os.environ, {",
        "            \"CORTICAL_LOG_LEVEL\": \"DEBUG\",",
        "            \"CORTICAL_CORPUS_PATH\": \"\"",
        "        }):",
        "            with patch('cortical.mcp_server.create_mcp_server') as mock_create:",
        "                mock_server = MagicMock()",
        "                mock_create.return_value = mock_server",
        "",
        "                with patch('logging.basicConfig') as mock_logging:",
        "                    main()",
        "",
        "                    # Verify logging was configured",
        "                    mock_logging.assert_called_once()",
        "                    call_args = mock_logging.call_args",
        "                    # Check log level was set from env var",
        "                    import logging",
        "                    self.assertEqual(call_args.kwargs.get('level'), logging.DEBUG)",
        "",
        "                    # Verify server was created and run",
        "                    mock_create.assert_called_once()",
        "                    mock_server.run.assert_called_once_with(transport=\"stdio\")",
        "",
        "    def test_main_function_with_corpus_path(self):",
        "        \"\"\"Test main() loads corpus from CORTICAL_CORPUS_PATH env var.\"\"\"",
        "        from unittest.mock import patch, MagicMock",
        "        import os",
        "        import tempfile",
        "",
        "        from cortical.mcp_server import main",
        "",
        "        # Create a temporary corpus file path",
        "        with tempfile.NamedTemporaryFile(suffix='.pkl', delete=False) as f:",
        "            temp_corpus = f.name",
        "",
        "        try:",
        "            with patch.dict(os.environ, {",
        "                \"CORTICAL_LOG_LEVEL\": \"INFO\",",
        "                \"CORTICAL_CORPUS_PATH\": temp_corpus",
        "            }):",
        "                with patch('cortical.mcp_server.create_mcp_server') as mock_create:",
        "                    mock_server = MagicMock()",
        "                    mock_create.return_value = mock_server",
        "",
        "                    with patch('logging.basicConfig'):",
        "                        main()",
        "",
        "                        # Verify corpus path was passed to create_mcp_server",
        "                        mock_create.assert_called_once_with(corpus_path=temp_corpus)",
        "        finally:",
        "            if os.path.exists(temp_corpus):",
        "                os.unlink(temp_corpus)",
        "",
        "    def test_main_function_default_log_level(self):",
        "        \"\"\"Test main() uses INFO as default log level.\"\"\"",
        "        from unittest.mock import patch, MagicMock",
        "        import os",
        "        import logging",
        "",
        "        from cortical.mcp_server import main",
        "",
        "        # Clear the log level env var to test default",
        "        env_without_log_level = {k: v for k, v in os.environ.items() if k != \"CORTICAL_LOG_LEVEL\"}",
        "        env_without_log_level[\"CORTICAL_CORPUS_PATH\"] = \"\"",
        "",
        "        with patch.dict(os.environ, env_without_log_level, clear=True):",
        "            with patch('cortical.mcp_server.create_mcp_server') as mock_create:",
        "                mock_server = MagicMock()",
        "                mock_create.return_value = mock_server",
        "",
        "                with patch('logging.basicConfig') as mock_logging:",
        "                    main()",
        "",
        "                    # Default should be INFO",
        "                    call_args = mock_logging.call_args",
        "                    self.assertEqual(call_args.kwargs.get('level'), logging.INFO)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "            # Expand query",
        "            _, expand_meta = await server.mcp.call_tool(\"expand_query\", {",
        "                \"query\": \"intelligence\"",
        "            })",
        "            expand_result = expand_meta.get('result', {})",
        "            self.assertIn(\"expansions\", expand_result)",
        "",
        "        asyncio.run(workflow())",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main()"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 17,
  "day_of_week": "Saturday",
  "seconds_since_last_commit": -159725,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}