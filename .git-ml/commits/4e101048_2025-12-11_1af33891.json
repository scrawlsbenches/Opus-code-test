{
  "hash": "4e101048793dec1a5f619d43d36303fc386c54e0",
  "message": "Merge pull request #37 from scrawlsbenches/claude/cli-wrapper-context-01JScUxQPSb4rGC2XhtXPSYB",
  "author": "scrawlsbenches",
  "timestamp": "2025-12-11 13:41:47 -0500",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/cli_wrapper.py",
    "docs/cli-wrapper-guide.md",
    "scripts/cli_wrappers.py",
    "tests/test_cli_wrapper.py"
  ],
  "insertions": 2748,
  "deletions": 0,
  "hunks": [
    {
      "file": "cortical/cli_wrapper.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "\"\"\"",
        "CLI wrapper framework for collecting context and triggering actions.",
        "",
        "Design philosophy: QUIET BY DEFAULT, POWERFUL WHEN NEEDED.",
        "",
        "Most of the time you just want to run a command and check if it worked.",
        "The fancy stuff (hooks, tracking, context management) is there when you",
        "need it, invisible when you don't.",
        "",
        "Simple usage (90% of cases):",
        "    from cortical.cli_wrapper import run",
        "",
        "    result = run(\"pytest tests/\")",
        "    if result.success:",
        "        print(\"Tests passed\")",
        "    else:",
        "        print(result.stderr)",
        "",
        "With git context (when you need it):",
        "    result = run(\"git status\", git=True)",
        "    print(result.git.modified_files)",
        "",
        "With session tracking (for complex workflows):",
        "    with Session() as s:",
        "        s.run(\"pytest tests/\")",
        "        s.run(\"git add -A\")",
        "        s.run(\"git commit -m 'fix tests'\")",
        "",
        "        if s.should_reindex():",
        "            s.run(\"python scripts/index_codebase.py --incremental\")",
        "",
        "        print(s.summary())",
        "",
        "Advanced (hooks for automation):",
        "    wrapper = CLIWrapper()",
        "",
        "    @wrapper.on_success(\"pytest\")",
        "    def after_tests(result):",
        "        # Auto-update coverage badge, etc.",
        "        pass",
        "\"\"\"",
        "",
        "import json",
        "import os",
        "import platform",
        "import subprocess",
        "import time",
        "import uuid",
        "from dataclasses import dataclass, field, asdict",
        "from datetime import datetime",
        "from enum import Enum",
        "from pathlib import Path",
        "from typing import (",
        "    Any, Callable, Dict, List, Optional, Tuple, Union, Protocol",
        ")",
        "",
        "",
        "# =============================================================================",
        "# Execution Context",
        "# =============================================================================",
        "",
        "@dataclass",
        "class GitContext:",
        "    \"\"\"Git repository context information.\"\"\"",
        "    is_repo: bool = False",
        "    branch: str = \"\"",
        "    commit_hash: str = \"\"",
        "    is_dirty: bool = False",
        "    staged_files: List[str] = field(default_factory=list)",
        "    modified_files: List[str] = field(default_factory=list)",
        "    untracked_files: List[str] = field(default_factory=list)",
        "",
        "    @classmethod",
        "    def collect(cls, cwd: Optional[str] = None) -> 'GitContext':",
        "        \"\"\"Collect git context from current directory.\"\"\"",
        "        ctx = cls()",
        "        try:",
        "            # Check if in git repo",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--is-inside-work-tree'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode != 0:",
        "                return ctx",
        "            ctx.is_repo = True",
        "",
        "            # Get branch",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode == 0:",
        "                ctx.branch = result.stdout.strip()",
        "",
        "            # Get commit hash",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--short', 'HEAD'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode == 0:",
        "                ctx.commit_hash = result.stdout.strip()",
        "",
        "            # Get status (porcelain for parsing)",
        "            result = subprocess.run(",
        "                ['git', 'status', '--porcelain'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=10",
        "            )",
        "            if result.returncode == 0:",
        "                for line in result.stdout.strip().split('\\n'):",
        "                    if not line:",
        "                        continue",
        "                    status = line[:2]",
        "                    filepath = line[3:]",
        "                    if status[0] in ('A', 'M', 'D', 'R'):",
        "                        ctx.staged_files.append(filepath)",
        "                    if status[1] in ('M', 'D'):",
        "                        ctx.modified_files.append(filepath)",
        "                    if status == '??':",
        "                        ctx.untracked_files.append(filepath)",
        "                ctx.is_dirty = bool(",
        "                    ctx.staged_files or ctx.modified_files or ctx.untracked_files",
        "                )",
        "",
        "        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):",
        "            pass",
        "",
        "        return ctx",
        "",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Convert to dictionary.\"\"\"",
        "        return asdict(self)",
        "",
        "",
        "@dataclass",
        "class ExecutionContext:",
        "    \"\"\"",
        "    Complete context for a CLI command execution.",
        "",
        "    Captures everything needed for:",
        "    - Logging and debugging",
        "    - Context window management decisions",
        "    - Task completion triggers",
        "    \"\"\"",
        "    # Execution metadata",
        "    command: List[str] = field(default_factory=list)",
        "    command_str: str = \"\"",
        "    exit_code: int = 0",
        "    start_time: float = 0.0",
        "    end_time: float = 0.0",
        "    duration: float = 0.0",
        "",
        "    # Output capture",
        "    stdout: str = \"\"",
        "    stderr: str = \"\"",
        "    output_lines: int = 0",
        "    error_lines: int = 0",
        "",
        "    # Environment context",
        "    working_directory: str = \"\"",
        "    session_id: str = \"\"",
        "    timestamp: str = \"\"",
        "    platform: str = \"\"",
        "    python_version: str = \"\"",
        "",
        "    # Git context",
        "    git: GitContext = field(default_factory=GitContext)",
        "",
        "    # Task classification",
        "    task_type: str = \"\"  # 'test', 'build', 'commit', 'search', etc.",
        "    success: bool = False",
        "",
        "    # Custom metadata from hooks",
        "    metadata: Dict[str, Any] = field(default_factory=dict)",
        "",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Convert to dictionary for serialization.\"\"\"",
        "        d = asdict(self)",
        "        d['git'] = self.git.to_dict()",
        "        return d",
        "",
        "    def to_json(self, indent: int = 2) -> str:",
        "        \"\"\"Convert to JSON string.\"\"\"",
        "        return json.dumps(self.to_dict(), indent=indent)",
        "",
        "    def summary(self) -> str:",
        "        \"\"\"Return a concise summary string.\"\"\"",
        "        status = \"✓\" if self.success else \"✗\"",
        "        return (",
        "            f\"{status} {self.command_str} \"",
        "            f\"[{self.duration:.2f}s, exit={self.exit_code}]\"",
        "        )",
        "",
        "",
        "# =============================================================================",
        "# Hook System",
        "# =============================================================================",
        "",
        "class HookType(Enum):",
        "    \"\"\"Types of hooks that can be registered.\"\"\"",
        "    PRE_EXEC = \"pre_exec\"       # Before command execution",
        "    POST_EXEC = \"post_exec\"     # After command execution (success or failure)",
        "    ON_SUCCESS = \"on_success\"   # Only on successful execution",
        "    ON_ERROR = \"on_error\"       # Only on failed execution",
        "    ON_TIMEOUT = \"on_timeout\"   # When command times out",
        "",
        "",
        "# Hook callback signature",
        "HookCallback = Callable[[ExecutionContext], None]",
        "",
        "",
        "class HookRegistry:",
        "    \"\"\"",
        "    Registry for CLI execution hooks.",
        "",
        "    Hooks can be registered globally or for specific command patterns.",
        "    \"\"\"",
        "",
        "    def __init__(self):",
        "        # Global hooks (apply to all commands)",
        "        self._global_hooks: Dict[HookType, List[HookCallback]] = {",
        "            hook_type: [] for hook_type in HookType",
        "        }",
        "        # Pattern-specific hooks (command prefix matching)",
        "        self._pattern_hooks: Dict[str, Dict[HookType, List[HookCallback]]] = {}",
        "",
        "    def register(",
        "        self,",
        "        hook_type: HookType,",
        "        callback: HookCallback,",
        "        pattern: Optional[str] = None",
        "    ) -> None:",
        "        \"\"\"",
        "        Register a hook callback.",
        "",
        "        Args:",
        "            hook_type: When to trigger the hook",
        "            callback: Function to call with ExecutionContext",
        "            pattern: Optional command pattern (e.g., 'git', 'pytest')",
        "                    If None, applies to all commands",
        "        \"\"\"",
        "        if pattern is None:",
        "            self._global_hooks[hook_type].append(callback)",
        "        else:",
        "            if pattern not in self._pattern_hooks:",
        "                self._pattern_hooks[pattern] = {",
        "                    hook_type: [] for hook_type in HookType",
        "                }",
        "            self._pattern_hooks[pattern][hook_type].append(callback)",
        "",
        "    def register_pre(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for pre-execution hooks.\"\"\"",
        "        self.register(HookType.PRE_EXEC, callback, pattern)",
        "",
        "    def register_post(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for post-execution hooks.\"\"\"",
        "        self.register(HookType.POST_EXEC, callback, pattern)",
        "",
        "    def register_success(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for success hooks.\"\"\"",
        "        self.register(HookType.ON_SUCCESS, callback, pattern)",
        "",
        "    def register_error(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for error hooks.\"\"\"",
        "        self.register(HookType.ON_ERROR, callback, pattern)",
        "",
        "    def get_hooks(",
        "        self,",
        "        hook_type: HookType,",
        "        command: List[str]",
        "    ) -> List[HookCallback]:",
        "        \"\"\"",
        "        Get all hooks that should be triggered for a command.",
        "",
        "        Args:",
        "            hook_type: Type of hook",
        "            command: Command being executed",
        "",
        "        Returns:",
        "            List of callbacks to execute",
        "        \"\"\"",
        "        callbacks = list(self._global_hooks[hook_type])",
        "",
        "        # Match patterns against command",
        "        if command:",
        "            cmd_str = ' '.join(command)",
        "            for pattern, hooks in self._pattern_hooks.items():",
        "                if cmd_str.startswith(pattern) or command[0] == pattern:",
        "                    callbacks.extend(hooks[hook_type])",
        "",
        "        return callbacks",
        "",
        "    def trigger(",
        "        self,",
        "        hook_type: HookType,",
        "        context: ExecutionContext",
        "    ) -> None:",
        "        \"\"\"Trigger all matching hooks.\"\"\"",
        "        for callback in self.get_hooks(hook_type, context.command):",
        "            try:",
        "                callback(context)",
        "            except Exception as e:",
        "                # Log but don't fail on hook errors",
        "                context.metadata.setdefault('hook_errors', []).append(",
        "                    f\"{hook_type.value}: {str(e)}\"",
        "                )",
        "",
        "",
        "# =============================================================================",
        "# CLI Wrapper",
        "# =============================================================================",
        "",
        "class CLIWrapper:",
        "    \"\"\"",
        "    Wrapper for CLI command execution with context collection and hooks.",
        "",
        "    Features:",
        "    - Automatic context collection (timing, git status, environment)",
        "    - Pre/post execution hooks",
        "    - Task type classification",
        "    - Timeout handling",
        "    - Output capture",
        "    \"\"\"",
        "",
        "    # Command patterns for task type classification",
        "    TASK_PATTERNS = {",
        "        'test': ['pytest', 'python -m pytest', 'python -m unittest', 'npm test'],",
        "        'build': ['python -m build', 'npm run build', 'make', 'cargo build'],",
        "        'commit': ['git commit', 'git add', 'git push'],",
        "        'search': ['grep', 'rg', 'find', 'ag'],",
        "        'install': ['pip install', 'npm install', 'cargo install'],",
        "        'lint': ['flake8', 'pylint', 'mypy', 'eslint', 'ruff'],",
        "        'format': ['black', 'prettier', 'rustfmt'],",
        "    }",
        "",
        "    def __init__(",
        "        self,",
        "        collect_git_context: bool = True,",
        "        capture_output: bool = True,",
        "        default_timeout: Optional[float] = None",
        "    ):",
        "        \"\"\"",
        "        Initialize CLI wrapper.",
        "",
        "        Args:",
        "            collect_git_context: Whether to collect git info before execution",
        "            capture_output: Whether to capture stdout/stderr",
        "            default_timeout: Default timeout in seconds (None = no timeout)",
        "        \"\"\"",
        "        self.hooks = HookRegistry()",
        "        self.collect_git_context = collect_git_context",
        "        self.capture_output = capture_output",
        "        self.default_timeout = default_timeout",
        "        self.session_id = uuid.uuid4().hex[:16]",
        "",
        "    def _classify_task(self, command: List[str]) -> str:",
        "        \"\"\"Classify command into a task type.\"\"\"",
        "        if not command:",
        "            return 'unknown'",
        "",
        "        cmd_str = ' '.join(command)",
        "        for task_type, patterns in self.TASK_PATTERNS.items():",
        "            for pattern in patterns:",
        "                if cmd_str.startswith(pattern) or command[0] == pattern.split()[0]:",
        "                    return task_type",
        "",
        "        return 'other'",
        "",
        "    def _build_context(",
        "        self,",
        "        command: List[str],",
        "        cwd: Optional[str] = None",
        "    ) -> ExecutionContext:",
        "        \"\"\"Build initial execution context.\"\"\"",
        "        cwd = cwd or os.getcwd()",
        "",
        "        ctx = ExecutionContext(",
        "            command=command,",
        "            command_str=' '.join(command),",
        "            working_directory=cwd,",
        "            session_id=self.session_id,",
        "            timestamp=datetime.now().isoformat(timespec='seconds'),",
        "            platform=platform.system(),",
        "            python_version=platform.python_version(),",
        "            task_type=self._classify_task(command),",
        "        )",
        "",
        "        if self.collect_git_context:",
        "            ctx.git = GitContext.collect(cwd)",
        "",
        "        return ctx",
        "",
        "    def run(",
        "        self,",
        "        command: Union[str, List[str]],",
        "        cwd: Optional[str] = None,",
        "        timeout: Optional[float] = None,",
        "        env: Optional[Dict[str, str]] = None,",
        "        **kwargs",
        "    ) -> ExecutionContext:",
        "        \"\"\"",
        "        Execute a command with context collection and hooks.",
        "",
        "        Args:",
        "            command: Command to execute (string or list)",
        "            cwd: Working directory",
        "            timeout: Timeout in seconds (overrides default)",
        "            env: Environment variables (merged with current env)",
        "            **kwargs: Additional args passed to subprocess.run",
        "",
        "        Returns:",
        "            ExecutionContext with all collected metadata",
        "        \"\"\"",
        "        # Normalize command",
        "        if isinstance(command, str):",
        "            command = command.split()",
        "",
        "        # Build initial context",
        "        ctx = self._build_context(command, cwd)",
        "        ctx.start_time = time.time()",
        "",
        "        # Merge environment",
        "        run_env = os.environ.copy()",
        "        if env:",
        "            run_env.update(env)",
        "",
        "        # Trigger pre-execution hooks",
        "        self.hooks.trigger(HookType.PRE_EXEC, ctx)",
        "",
        "        # Execute command",
        "        effective_timeout = timeout if timeout is not None else self.default_timeout",
        "",
        "        try:",
        "            result = subprocess.run(",
        "                command,",
        "                capture_output=self.capture_output,",
        "                text=True,",
        "                cwd=cwd,",
        "                env=run_env,",
        "                timeout=effective_timeout,",
        "                **kwargs",
        "            )",
        "",
        "            ctx.exit_code = result.returncode",
        "            ctx.success = result.returncode == 0",
        "",
        "            if self.capture_output:",
        "                ctx.stdout = result.stdout or \"\"",
        "                ctx.stderr = result.stderr or \"\"",
        "                ctx.output_lines = len(ctx.stdout.splitlines())",
        "                ctx.error_lines = len(ctx.stderr.splitlines())",
        "",
        "        except subprocess.TimeoutExpired as e:",
        "            ctx.exit_code = -1",
        "            ctx.success = False",
        "            ctx.metadata['timeout'] = effective_timeout",
        "            ctx.metadata['timeout_error'] = str(e)",
        "            if e.stdout:",
        "                ctx.stdout = e.stdout.decode() if isinstance(e.stdout, bytes) else e.stdout",
        "            if e.stderr:",
        "                ctx.stderr = e.stderr.decode() if isinstance(e.stderr, bytes) else e.stderr",
        "            self.hooks.trigger(HookType.ON_TIMEOUT, ctx)",
        "",
        "        except FileNotFoundError:",
        "            ctx.exit_code = 127",
        "            ctx.success = False",
        "            ctx.metadata['error'] = f\"Command not found: {command[0]}\"",
        "",
        "        except Exception as e:",
        "            ctx.exit_code = -1",
        "            ctx.success = False",
        "            ctx.metadata['error'] = str(e)",
        "",
        "        # Finalize timing",
        "        ctx.end_time = time.time()",
        "        ctx.duration = ctx.end_time - ctx.start_time",
        "",
        "        # Trigger post-execution hooks",
        "        self.hooks.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        # Trigger success/error hooks",
        "        if ctx.success:",
        "            self.hooks.trigger(HookType.ON_SUCCESS, ctx)",
        "        else:",
        "            self.hooks.trigger(HookType.ON_ERROR, ctx)",
        "",
        "        return ctx",
        "",
        "    # -------------------------------------------------------------------------",
        "    # Decorator-style hook registration (cleaner API)",
        "    # -------------------------------------------------------------------------",
        "",
        "    def on_success(self, pattern: Optional[str] = None):",
        "        \"\"\"",
        "        Decorator to register a success hook.",
        "",
        "        Example:",
        "            wrapper = CLIWrapper()",
        "",
        "            @wrapper.on_success(\"pytest\")",
        "            def after_tests(result):",
        "                print(f\"Tests passed in {result.duration:.1f}s\")",
        "        \"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_success(pattern, func)",
        "            return func",
        "        return decorator",
        "",
        "    def on_error(self, pattern: Optional[str] = None):",
        "        \"\"\"Decorator to register an error hook.\"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_error(pattern, func)",
        "            return func",
        "        return decorator",
        "",
        "    def on_complete(self, pattern: Optional[str] = None):",
        "        \"\"\"Decorator to register a completion hook (success or failure).\"\"\"",
        "        def decorator(func: HookCallback) -> HookCallback:",
        "            self.hooks.register_post(pattern, func)",
        "            return func",
        "        return decorator",
        "",
        "",
        "# =============================================================================",
        "# Task Completion Manager",
        "# =============================================================================",
        "",
        "class TaskCompletionManager:",
        "    \"\"\"",
        "    Manager for task completion triggers and context window management.",
        "",
        "    Provides high-level task completion callbacks that can:",
        "    - Trigger corpus re-indexing after code changes",
        "    - Update context window summaries",
        "    - Log task completions for session analysis",
        "    - Chain multiple actions on task completion",
        "    \"\"\"",
        "",
        "    def __init__(self):",
        "        self._task_handlers: Dict[str, List[HookCallback]] = {}",
        "        self._completion_log: List[ExecutionContext] = []",
        "        self._completion_callbacks: List[HookCallback] = []",
        "",
        "    def on_task_complete(",
        "        self,",
        "        task_type: str,",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"",
        "        Register a callback for when a specific task type completes.",
        "",
        "        Args:",
        "            task_type: Task type to match ('test', 'commit', 'build', etc.)",
        "            callback: Function called with ExecutionContext on completion",
        "        \"\"\"",
        "        if task_type not in self._task_handlers:",
        "            self._task_handlers[task_type] = []",
        "        self._task_handlers[task_type].append(callback)",
        "",
        "    def on_any_complete(self, callback: HookCallback) -> None:",
        "        \"\"\"Register a callback for any task completion.\"\"\"",
        "        self._completion_callbacks.append(callback)",
        "",
        "    def handle_completion(self, context: ExecutionContext) -> None:",
        "        \"\"\"",
        "        Handle task completion and trigger appropriate callbacks.",
        "",
        "        Should be called from CLIWrapper post-execution hook.",
        "        \"\"\"",
        "        # Log completion",
        "        self._completion_log.append(context)",
        "",
        "        # Trigger task-specific handlers",
        "        if context.task_type in self._task_handlers:",
        "            for callback in self._task_handlers[context.task_type]:",
        "                try:",
        "                    callback(context)",
        "                except Exception as e:",
        "                    context.metadata.setdefault('completion_errors', []).append(str(e))",
        "",
        "        # Trigger global completion callbacks",
        "        for callback in self._completion_callbacks:",
        "            try:",
        "                callback(context)",
        "            except Exception as e:",
        "                context.metadata.setdefault('completion_errors', []).append(str(e))",
        "",
        "    def get_session_summary(self) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Get summary of all tasks completed in this session.",
        "",
        "        Useful for context window management decisions.",
        "        \"\"\"",
        "        if not self._completion_log:",
        "            return {",
        "                'task_count': 0,",
        "                'success_rate': 0.0,",
        "                'total_duration': 0.0,",
        "                'tasks_by_type': {},",
        "                'files_modified': [],",
        "            }",
        "",
        "        tasks_by_type: Dict[str, Dict[str, Any]] = {}",
        "        all_modified_files: List[str] = []",
        "",
        "        for ctx in self._completion_log:",
        "            task_type = ctx.task_type or 'unknown'",
        "            if task_type not in tasks_by_type:",
        "                tasks_by_type[task_type] = {",
        "                    'count': 0,",
        "                    'successes': 0,",
        "                    'failures': 0,",
        "                    'total_duration': 0.0,",
        "                }",
        "",
        "            tasks_by_type[task_type]['count'] += 1",
        "            tasks_by_type[task_type]['total_duration'] += ctx.duration",
        "            if ctx.success:",
        "                tasks_by_type[task_type]['successes'] += 1",
        "            else:",
        "                tasks_by_type[task_type]['failures'] += 1",
        "",
        "            # Collect modified files from git context",
        "            all_modified_files.extend(ctx.git.modified_files)",
        "            all_modified_files.extend(ctx.git.staged_files)",
        "",
        "        total_tasks = len(self._completion_log)",
        "        successes = sum(1 for ctx in self._completion_log if ctx.success)",
        "",
        "        return {",
        "            'task_count': total_tasks,",
        "            'success_rate': successes / total_tasks if total_tasks > 0 else 0.0,",
        "            'total_duration': sum(ctx.duration for ctx in self._completion_log),",
        "            'tasks_by_type': tasks_by_type,",
        "            'files_modified': list(set(all_modified_files)),",
        "        }",
        "",
        "    def should_trigger_reindex(self) -> bool:",
        "        \"\"\"",
        "        Determine if corpus should be re-indexed based on session activity.",
        "",
        "        Returns True if:",
        "        - Code files were modified",
        "        - Tests were run (may indicate code changes)",
        "        - Git commits were made",
        "        \"\"\"",
        "        summary = self.get_session_summary()",
        "",
        "        # Check if relevant files were modified",
        "        code_extensions = {'.py', '.js', '.ts', '.md', '.rst'}",
        "        for filepath in summary['files_modified']:",
        "            if any(filepath.endswith(ext) for ext in code_extensions):",
        "                return True",
        "",
        "        # Check if commits were made",
        "        tasks_by_type = summary.get('tasks_by_type', {})",
        "        if 'commit' in tasks_by_type and tasks_by_type['commit']['successes'] > 0:",
        "            return True",
        "",
        "        return False",
        "",
        "",
        "# =============================================================================",
        "# Context Window Integration",
        "# =============================================================================",
        "",
        "class ContextWindowManager:",
        "    \"\"\"",
        "    Manages context window state based on CLI execution history.",
        "",
        "    Tracks what information is \"in context\" and provides utilities for:",
        "    - Summarizing recent activity",
        "    - Identifying relevant files for the current task",
        "    - Suggesting context pruning",
        "    \"\"\"",
        "",
        "    def __init__(self, max_context_items: int = 50):",
        "        self.max_context_items = max_context_items",
        "        self._context_items: List[Dict[str, Any]] = []",
        "        self._file_access_log: Dict[str, float] = {}  # filepath -> last access time",
        "",
        "    def add_execution(self, context: ExecutionContext) -> None:",
        "        \"\"\"Add an execution to the context window.\"\"\"",
        "        item = {",
        "            'type': 'execution',",
        "            'task_type': context.task_type,",
        "            'command': context.command_str,",
        "            'success': context.success,",
        "            'duration': context.duration,",
        "            'timestamp': context.timestamp,",
        "            'files': context.git.modified_files + context.git.staged_files,",
        "        }",
        "        self._context_items.append(item)",
        "",
        "        # Track file access",
        "        now = time.time()",
        "        for filepath in item['files']:",
        "            self._file_access_log[filepath] = now",
        "",
        "        # Prune if needed",
        "        if len(self._context_items) > self.max_context_items:",
        "            self._context_items = self._context_items[-self.max_context_items:]",
        "",
        "    def add_file_read(self, filepath: str) -> None:",
        "        \"\"\"Track that a file was read.\"\"\"",
        "        self._file_access_log[filepath] = time.time()",
        "        self._context_items.append({",
        "            'type': 'file_read',",
        "            'filepath': filepath,",
        "            'timestamp': datetime.now().isoformat(timespec='seconds'),",
        "        })",
        "",
        "    def get_recent_files(self, limit: int = 10) -> List[str]:",
        "        \"\"\"Get most recently accessed files.\"\"\"",
        "        sorted_files = sorted(",
        "            self._file_access_log.items(),",
        "            key=lambda x: x[1],",
        "            reverse=True",
        "        )",
        "        return [f for f, _ in sorted_files[:limit]]",
        "",
        "    def get_context_summary(self) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Get a summary of current context window state.",
        "",
        "        Useful for context window management decisions.",
        "        \"\"\"",
        "        executions = [i for i in self._context_items if i['type'] == 'execution']",
        "        file_reads = [i for i in self._context_items if i['type'] == 'file_read']",
        "",
        "        task_types = {}",
        "        for ex in executions:",
        "            task_type = ex.get('task_type', 'unknown')",
        "            task_types[task_type] = task_types.get(task_type, 0) + 1",
        "",
        "        return {",
        "            'total_items': len(self._context_items),",
        "            'executions': len(executions),",
        "            'file_reads': len(file_reads),",
        "            'task_types': task_types,",
        "            'recent_files': self.get_recent_files(5),",
        "            'unique_files_accessed': len(self._file_access_log),",
        "        }",
        "",
        "    def suggest_pruning(self) -> List[str]:",
        "        \"\"\"",
        "        Suggest files that could be pruned from context.",
        "",
        "        Returns files that:",
        "        - Haven't been accessed recently",
        "        - Aren't related to recent task types",
        "        \"\"\"",
        "        if len(self._file_access_log) < self.max_context_items // 2:",
        "            return []",
        "",
        "        now = time.time()",
        "        stale_threshold = 300  # 5 minutes",
        "",
        "        stale_files = [",
        "            filepath",
        "            for filepath, last_access in self._file_access_log.items()",
        "            if now - last_access > stale_threshold",
        "        ]",
        "",
        "        return stale_files[:10]  # Suggest up to 10 files",
        "",
        "",
        "# =============================================================================",
        "# Convenience Functions",
        "# =============================================================================",
        "",
        "def create_wrapper_with_completion_manager() -> Tuple[CLIWrapper, TaskCompletionManager]:",
        "    \"\"\"",
        "    Create a CLIWrapper with an attached TaskCompletionManager.",
        "",
        "    Returns:",
        "        Tuple of (wrapper, completion_manager) configured together",
        "    \"\"\"",
        "    wrapper = CLIWrapper()",
        "    manager = TaskCompletionManager()",
        "",
        "    # Connect wrapper to completion manager",
        "    wrapper.hooks.register_post(None, manager.handle_completion)",
        "",
        "    return wrapper, manager",
        "",
        "",
        "def run_with_context(",
        "    command: Union[str, List[str]],",
        "    **kwargs",
        ") -> ExecutionContext:",
        "    \"\"\"",
        "    Convenience function to run a command with full context collection.",
        "",
        "    Args:",
        "        command: Command to execute",
        "        **kwargs: Additional arguments for CLIWrapper.run()",
        "",
        "    Returns:",
        "        ExecutionContext with all metadata",
        "    \"\"\"",
        "    wrapper = CLIWrapper()",
        "    return wrapper.run(command, **kwargs)",
        "",
        "",
        "# =============================================================================",
        "# Simple API (the 90% use case)",
        "# =============================================================================",
        "",
        "def run(",
        "    command: Union[str, List[str]],",
        "    git: bool = False,",
        "    timeout: Optional[float] = None,",
        "    cwd: Optional[str] = None,",
        ") -> ExecutionContext:",
        "    \"\"\"",
        "    Run a command. That's it.",
        "",
        "    This is the simple API for the 90% use case. No hooks, no tracking,",
        "    no noise. Just run and get results.",
        "",
        "    Args:",
        "        command: Command to run (string or list)",
        "        git: If True, collect git context (branch, modified files, etc.)",
        "        timeout: Timeout in seconds (None = no timeout)",
        "        cwd: Working directory",
        "",
        "    Returns:",
        "        ExecutionContext with:",
        "        - .success: bool - did it work?",
        "        - .stdout: str - standard output",
        "        - .stderr: str - standard error",
        "        - .exit_code: int - exit code",
        "        - .duration: float - how long it took",
        "        - .git: GitContext - if git=True",
        "",
        "    Example:",
        "        result = run(\"pytest tests/\")",
        "        if result.success:",
        "            print(\"All tests passed\")",
        "        else:",
        "            print(f\"Failed: {result.stderr}\")",
        "    \"\"\"",
        "    wrapper = CLIWrapper(",
        "        collect_git_context=git,",
        "        capture_output=True,",
        "        default_timeout=timeout,",
        "    )",
        "    return wrapper.run(command, cwd=cwd)",
        "",
        "",
        "# =============================================================================",
        "# Session Context Manager",
        "# =============================================================================",
        "",
        "class Session:",
        "    \"\"\"",
        "    Track a sequence of commands as a session.",
        "",
        "    Use this when you want to:",
        "    - Track multiple related commands together",
        "    - Know if you should re-index after changes",
        "    - Get a summary of what happened",
        "",
        "    Example:",
        "        with Session() as s:",
        "            s.run(\"pytest tests/\")",
        "            s.run(\"git add -A\")",
        "            s.run(\"git commit -m 'fix'\")",
        "",
        "            if s.should_reindex():",
        "                s.run(\"python scripts/index_codebase.py -i\")",
        "",
        "            print(s.summary())",
        "    \"\"\"",
        "",
        "    def __init__(self, git: bool = True):",
        "        \"\"\"",
        "        Start a session.",
        "",
        "        Args:",
        "            git: Whether to collect git context for commands (default True)",
        "        \"\"\"",
        "        self._wrapper = CLIWrapper(collect_git_context=git)",
        "        self._manager = TaskCompletionManager()",
        "        self._context_manager = ContextWindowManager()",
        "        self._results: List[ExecutionContext] = []",
        "",
        "        # Wire up tracking (silent - no hooks that print anything)",
        "        self._wrapper.hooks.register_post(None, self._track)",
        "",
        "    def _track(self, ctx: ExecutionContext) -> None:",
        "        \"\"\"Internal: track command completion.\"\"\"",
        "        self._results.append(ctx)",
        "        self._manager.handle_completion(ctx)",
        "        self._context_manager.add_execution(ctx)",
        "",
        "    def __enter__(self) -> 'Session':",
        "        return self",
        "",
        "    def __exit__(self, exc_type, exc_val, exc_tb) -> None:",
        "        pass  # Nothing to clean up",
        "",
        "    def run(",
        "        self,",
        "        command: Union[str, List[str]],",
        "        **kwargs",
        "    ) -> ExecutionContext:",
        "        \"\"\"Run a command within this session.\"\"\"",
        "        return self._wrapper.run(command, **kwargs)",
        "",
        "    def should_reindex(self) -> bool:",
        "        \"\"\"Check if corpus re-indexing is recommended based on session activity.\"\"\"",
        "        return self._manager.should_trigger_reindex()",
        "",
        "    def summary(self) -> Dict[str, Any]:",
        "        \"\"\"Get a summary of this session's activity.\"\"\"",
        "        return self._manager.get_session_summary()",
        "",
        "    @property",
        "    def results(self) -> List[ExecutionContext]:",
        "        \"\"\"All command results from this session.\"\"\"",
        "        return self._results.copy()",
        "",
        "    @property",
        "    def success_rate(self) -> float:",
        "        \"\"\"Fraction of commands that succeeded (0.0 to 1.0).\"\"\"",
        "        if not self._results:",
        "            return 1.0",
        "        return sum(1 for r in self._results if r.success) / len(self._results)",
        "",
        "    @property",
        "    def all_passed(self) -> bool:",
        "        \"\"\"True if all commands in this session succeeded.\"\"\"",
        "        return all(r.success for r in self._results)",
        "",
        "    @property",
        "    def modified_files(self) -> List[str]:",
        "        \"\"\"List of files modified during this session (from git context).\"\"\"",
        "        files = set()",
        "        for r in self._results:",
        "            files.update(r.git.modified_files)",
        "            files.update(r.git.staged_files)",
        "        return list(files)",
        "",
        "",
        "# =============================================================================",
        "# Compound Commands (things I actually use)",
        "# =============================================================================",
        "",
        "def test_then_commit(",
        "    test_cmd: Union[str, List[str]] = \"python -m unittest discover -s tests\",",
        "    message: str = \"Update\",",
        "    add_all: bool = True,",
        ") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Run tests, commit only if they pass.",
        "",
        "    Returns (success, [test_result, add_result?, commit_result?])",
        "",
        "    Example:",
        "        ok, results = test_then_commit(message=\"Fix auth bug\")",
        "        if ok:",
        "            print(\"Committed!\")",
        "        else:",
        "            print(f\"Tests failed: {results[0].stderr}\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    # Run tests",
        "    test_result = run(test_cmd)",
        "    results.append(test_result)",
        "",
        "    if not test_result.success:",
        "        return False, results",
        "",
        "    # Add files",
        "    if add_all:",
        "        add_result = run([\"git\", \"add\", \"-A\"], git=True)",
        "        results.append(add_result)",
        "        if not add_result.success:",
        "            return False, results",
        "",
        "    # Commit",
        "    commit_result = run([\"git\", \"commit\", \"-m\", message], git=True)",
        "    results.append(commit_result)",
        "",
        "    return commit_result.success, results",
        "",
        "",
        "def commit_and_push(",
        "    message: str,",
        "    add_all: bool = True,",
        "    branch: Optional[str] = None,",
        ") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Add, commit, and push in one go.",
        "",
        "    Example:",
        "        ok, _ = commit_and_push(\"Fix typo\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    if add_all:",
        "        add_result = run([\"git\", \"add\", \"-A\"], git=True)",
        "        results.append(add_result)",
        "        if not add_result.success:",
        "            return False, results",
        "",
        "    commit_result = run([\"git\", \"commit\", \"-m\", message], git=True)",
        "    results.append(commit_result)",
        "    if not commit_result.success:",
        "        return False, results",
        "",
        "    # Determine branch",
        "    if branch is None:",
        "        branch_result = run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"])",
        "        if branch_result.success:",
        "            branch = branch_result.stdout.strip()",
        "        else:",
        "            branch = \"HEAD\"",
        "",
        "    push_result = run([\"git\", \"push\", \"-u\", \"origin\", branch], git=True)",
        "    results.append(push_result)",
        "",
        "    return push_result.success, results",
        "",
        "",
        "def sync_with_main(main_branch: str = \"main\") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Fetch and rebase current branch on main.",
        "",
        "    Example:",
        "        ok, results = sync_with_main()",
        "        if not ok:",
        "            print(\"Rebase conflicts - resolve manually\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    fetch_result = run([\"git\", \"fetch\", \"origin\", main_branch])",
        "    results.append(fetch_result)",
        "    if not fetch_result.success:",
        "        return False, results",
        "",
        "    rebase_result = run([\"git\", \"rebase\", f\"origin/{main_branch}\"])",
        "    results.append(rebase_result)",
        "",
        "    return rebase_result.success, results",
        "",
        "",
        "# =============================================================================",
        "# Context Checkpointing (for task switching)",
        "# =============================================================================",
        "",
        "class TaskCheckpoint:",
        "    \"\"\"",
        "    Save/restore context state when switching between tasks.",
        "",
        "    When you're working on Task A and need to switch to Task B,",
        "    checkpoint Task A so you can resume later with context intact.",
        "",
        "    Example:",
        "        checkpoint = TaskCheckpoint()",
        "",
        "        # Working on feature A",
        "        checkpoint.save(\"feature-a\", {",
        "            'branch': 'feature/auth',",
        "            'files_touched': ['auth.py', 'test_auth.py'],",
        "            'notes': 'Need to add token refresh logic',",
        "            'last_test_passed': True,",
        "        })",
        "",
        "        # Switch to urgent bugfix...",
        "        # ...later, resume feature A",
        "        ctx = checkpoint.load(\"feature-a\")",
        "        print(ctx['notes'])  # \"Need to add token refresh logic\"",
        "    \"\"\"",
        "",
        "    def __init__(self, checkpoint_dir: Optional[str] = None):",
        "        if checkpoint_dir:",
        "            self._dir = Path(checkpoint_dir)",
        "        else:",
        "            self._dir = Path('.task_checkpoints')",
        "        self._dir.mkdir(exist_ok=True)",
        "",
        "    def save(self, task_name: str, context: Dict[str, Any]) -> None:",
        "        \"\"\"Save context for a task.\"\"\"",
        "        checkpoint = {",
        "            'task_name': task_name,",
        "            'saved_at': datetime.now().isoformat(),",
        "            'context': context,",
        "        }",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        with open(filepath, 'w') as f:",
        "            json.dump(checkpoint, f, indent=2)",
        "",
        "    def load(self, task_name: str) -> Optional[Dict[str, Any]]:",
        "        \"\"\"Load context for a task. Returns None if not found.\"\"\"",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        if not filepath.exists():",
        "            return None",
        "        with open(filepath, 'r') as f:",
        "            checkpoint = json.load(f)",
        "        return checkpoint.get('context')",
        "",
        "    def list_tasks(self) -> List[str]:",
        "        \"\"\"List all saved task checkpoints.\"\"\"",
        "        return [f.stem for f in self._dir.glob('*.json')]",
        "",
        "    def delete(self, task_name: str) -> bool:",
        "        \"\"\"Delete a checkpoint. Returns True if deleted.\"\"\"",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        if filepath.exists():",
        "            filepath.unlink()",
        "            return True",
        "        return False",
        "",
        "    def summarize(self, task_name: str) -> Optional[str]:",
        "        \"\"\"Get a one-line summary of a task checkpoint.\"\"\"",
        "        ctx = self.load(task_name)",
        "        if ctx is None:",
        "            return None",
        "",
        "        parts = [task_name]",
        "        if 'branch' in ctx:",
        "            parts.append(f\"[{ctx['branch']}]\")",
        "        if 'notes' in ctx:",
        "            notes = ctx['notes']",
        "            if len(notes) > 50:",
        "                notes = notes[:47] + \"...\"",
        "            parts.append(f\"- {notes}\")",
        "",
        "        return ' '.join(parts)"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "docs/cli-wrapper-guide.md",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "# CLI Wrapper Guide",
        "",
        "A quick reference for the `cortical.cli_wrapper` module - designed for AI assistants working on code.",
        "",
        "## Design Philosophy",
        "",
        "**Quiet by default, powerful when needed.**",
        "",
        "- No emoji, no unsolicited suggestions",
        "- Git context is opt-in, not automatic",
        "- Data is available when you ask, silent otherwise",
        "",
        "## Quick Reference",
        "",
        "### Simple Command (90% of cases)",
        "",
        "```python",
        "from cortical.cli_wrapper import run",
        "",
        "result = run(\"pytest tests/\")",
        "if result.success:",
        "    # continue",
        "else:",
        "    print(result.stderr)",
        "```",
        "",
        "### With Git Context",
        "",
        "```python",
        "result = run(\"git status\", git=True)",
        "print(result.git.branch)",
        "print(result.git.modified_files)",
        "```",
        "",
        "### Session Tracking",
        "",
        "```python",
        "from cortical.cli_wrapper import Session",
        "",
        "with Session() as s:",
        "    s.run(\"pytest tests/\")",
        "    s.run(\"git add -A\")",
        "    s.run(\"git commit -m 'fix'\")",
        "",
        "    if s.should_reindex():",
        "        # Corpus was modified, consider re-indexing",
        "        s.run(\"python scripts/index_codebase.py -i\")",
        "",
        "    print(s.all_passed)  # True/False",
        "    print(s.summary())   # Dict with stats",
        "```",
        "",
        "### Compound Commands",
        "",
        "```python",
        "from cortical.cli_wrapper import test_then_commit, commit_and_push, sync_with_main",
        "",
        "# Only commit if tests pass",
        "ok, results = test_then_commit(message=\"Fix auth bug\")",
        "",
        "# Add + commit + push in one call",
        "ok, _ = commit_and_push(\"Quick fix\")",
        "",
        "# Fetch + rebase on main",
        "ok, _ = sync_with_main()",
        "```",
        "",
        "### Task Checkpointing (for context switching)",
        "",
        "```python",
        "from cortical.cli_wrapper import TaskCheckpoint",
        "",
        "checkpoint = TaskCheckpoint()",
        "",
        "# Before switching tasks, save context",
        "checkpoint.save(\"feature-auth\", {",
        "    'branch': 'feature/auth',",
        "    'notes': 'Need to add token refresh',",
        "    'files': ['auth.py', 'test_auth.py'],",
        "})",
        "",
        "# Later, resume",
        "ctx = checkpoint.load(\"feature-auth\")",
        "print(ctx['notes'])  # \"Need to add token refresh\"",
        "",
        "# See all checkpoints",
        "checkpoint.list_tasks()  # ['feature-auth', 'bugfix-123']",
        "```",
        "",
        "### Hooks (for automation)",
        "",
        "```python",
        "from cortical.cli_wrapper import CLIWrapper",
        "",
        "wrapper = CLIWrapper()",
        "",
        "@wrapper.on_success(\"pytest\")",
        "def after_tests(result):",
        "    print(f\"Tests passed in {result.duration:.1f}s\")",
        "",
        "@wrapper.on_error()",
        "def on_any_failure(result):",
        "    # Log, alert, etc.",
        "    pass",
        "```",
        "",
        "## ExecutionContext Fields",
        "",
        "| Field | Type | Description |",
        "|-------|------|-------------|",
        "| `success` | bool | Did the command succeed? |",
        "| `exit_code` | int | Process exit code |",
        "| `stdout` | str | Standard output |",
        "| `stderr` | str | Standard error |",
        "| `duration` | float | Execution time in seconds |",
        "| `command` | List[str] | Command that was run |",
        "| `command_str` | str | Command as string |",
        "| `git` | GitContext | Git info (if `git=True`) |",
        "| `task_type` | str | Classified type (test, commit, etc.) |",
        "",
        "## GitContext Fields",
        "",
        "| Field | Type | Description |",
        "|-------|------|-------------|",
        "| `is_repo` | bool | Inside a git repo? |",
        "| `branch` | str | Current branch name |",
        "| `commit_hash` | str | Short commit hash |",
        "| `is_dirty` | bool | Uncommitted changes? |",
        "| `modified_files` | List[str] | Modified but unstaged |",
        "| `staged_files` | List[str] | Staged for commit |",
        "| `untracked_files` | List[str] | Not tracked by git |",
        "",
        "## When to Use What",
        "",
        "| Situation | Use |",
        "|-----------|-----|",
        "| Run one command, check result | `run()` |",
        "| Need git branch/status | `run(..., git=True)` |",
        "| Multiple related commands | `Session()` |",
        "| Test before committing | `test_then_commit()` |",
        "| Quick commit + push | `commit_and_push()` |",
        "| Stay updated with main | `sync_with_main()` |",
        "| Switching between tasks | `TaskCheckpoint` |",
        "| Custom automation | `CLIWrapper` + hooks |",
        "",
        "## Key Design Decisions",
        "",
        "1. **`git=False` by default** - Avoids subprocess overhead when you don't need git info",
        "2. **No global state** - Each `run()` is independent; use `Session` for stateful tracking",
        "3. **Compound commands return `(bool, List[results])`** - Always know if it worked and what happened",
        "4. **Hooks are opt-in** - Register them explicitly, no surprise callbacks",
        "5. **Checkpoints are JSON files** - Human-readable, git-friendly, easy to inspect",
        "",
        "## File Locations",
        "",
        "- **Core module**: `cortical/cli_wrapper.py`",
        "- **Tests**: `tests/test_cli_wrapper.py` (60 tests)",
        "- **Example script**: `scripts/cli_wrappers.py`"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "scripts/cli_wrappers.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "#!/usr/bin/env python3",
        "\"\"\"",
        "Example CLI wrappers for common development tasks.",
        "",
        "Philosophy: QUIET BY DEFAULT. These wrappers collect context silently",
        "and only speak when asked.",
        "",
        "Usage:",
        "    # Simple - just use run()",
        "    from cortical.cli_wrapper import run, Session",
        "",
        "    result = run(\"pytest tests/\")",
        "    if not result.success:",
        "        print(result.stderr)",
        "",
        "    # Session tracking",
        "    with Session() as s:",
        "        s.run(\"pytest tests/\")",
        "        s.run(\"git commit -m 'fix'\")",
        "        if s.should_reindex():",
        "            print(\"Consider re-indexing\")",
        "",
        "    # As CLI",
        "    python scripts/cli_wrappers.py run pytest tests/ -v",
        "    python scripts/cli_wrappers.py --summary",
        "\"\"\"",
        "",
        "import argparse",
        "import json",
        "import os",
        "import sys",
        "from datetime import datetime",
        "from pathlib import Path",
        "from typing import List, Optional",
        "",
        "# Add parent directory for imports",
        "sys.path.insert(0, str(Path(__file__).parent.parent))",
        "",
        "from cortical.cli_wrapper import (",
        "    CLIWrapper,",
        "    ExecutionContext,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    Session,",
        "    run,",
        ")",
        "",
        "",
        "# =============================================================================",
        "# Context-Aware Wrapper Configuration",
        "# =============================================================================",
        "",
        "class DevWrapper:",
        "    \"\"\"",
        "    Development-focused CLI wrapper - QUIET BY DEFAULT.",
        "",
        "    No emoji. No unsolicited advice. Just runs commands and tracks context.",
        "    Ask for information when you want it.",
        "    \"\"\"",
        "",
        "    def __init__(",
        "        self,",
        "        log_dir: Optional[str] = None,",
        "        log_to_file: bool = False,",
        "    ):",
        "        self._session = Session(git=True)",
        "        self.log_to_file = log_to_file",
        "",
        "        if log_to_file:",
        "            if log_dir:",
        "                self.log_dir = Path(log_dir)",
        "            else:",
        "                self.log_dir = Path('.cli_wrapper_logs')",
        "            self.log_dir.mkdir(exist_ok=True)",
        "",
        "            # Register file logging hook",
        "            @self._session._wrapper.on_complete()",
        "            def log_to_file(ctx: ExecutionContext):",
        "                self._log_result(ctx)",
        "",
        "    def _log_result(self, ctx: ExecutionContext):",
        "        \"\"\"Log result to file (if enabled).\"\"\"",
        "        if not self.log_to_file:",
        "            return",
        "",
        "        log_file = self.log_dir / 'commands.jsonl'",
        "        entry = {",
        "            'timestamp': ctx.timestamp,",
        "            'command': ctx.command_str,",
        "            'success': ctx.success,",
        "            'duration': ctx.duration,",
        "            'exit_code': ctx.exit_code,",
        "            'git_branch': ctx.git.branch,",
        "        }",
        "",
        "        with open(log_file, 'a') as f:",
        "            f.write(json.dumps(entry) + '\\n')",
        "",
        "    def run(self, command: List[str], **kwargs) -> ExecutionContext:",
        "        \"\"\"Execute a command.\"\"\"",
        "        return self._session.run(command, **kwargs)",
        "",
        "    def summary(self) -> dict:",
        "        \"\"\"Get summary of session activity.\"\"\"",
        "        return self._session.summary()",
        "",
        "    def should_reindex(self) -> bool:",
        "        \"\"\"Check if re-indexing is recommended.\"\"\"",
        "        return self._session.should_reindex()",
        "",
        "    @property",
        "    def all_passed(self) -> bool:",
        "        \"\"\"True if all commands succeeded.\"\"\"",
        "        return self._session.all_passed",
        "",
        "    @property",
        "    def results(self) -> List[ExecutionContext]:",
        "        \"\"\"All command results.\"\"\"",
        "        return self._session.results",
        "",
        "",
        "# =============================================================================",
        "# CLI Interface (simplified)",
        "# =============================================================================",
        "",
        "def main():",
        "    \"\"\"",
        "    CLI entry point - just run commands with optional context.",
        "",
        "    This is mostly for demonstration. In practice, you'd use the",
        "    Python API directly: run() or Session.",
        "    \"\"\"",
        "    parser = argparse.ArgumentParser(",
        "        description='Run commands with context collection (quiet by default)',",
        "        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "        epilog=\"\"\"",
        "Examples:",
        "    %(prog)s run pytest tests/ -v",
        "    %(prog)s run git status",
        "    %(prog)s run echo hello --json",
        "        \"\"\"",
        "    )",
        "",
        "    parser.add_argument(",
        "        'mode',",
        "        nargs='?',",
        "        choices=['run'],",
        "        default='run',",
        "        help='Mode (currently only \"run\" is supported)'",
        "    )",
        "    parser.add_argument(",
        "        'command',",
        "        nargs='*',",
        "        help='Command to execute'",
        "    )",
        "    parser.add_argument(",
        "        '--git',",
        "        action='store_true',",
        "        help='Collect git context'",
        "    )",
        "    parser.add_argument(",
        "        '--json',",
        "        action='store_true',",
        "        help='Output result as JSON'",
        "    )",
        "",
        "    args = parser.parse_args()",
        "",
        "    if not args.command:",
        "        parser.print_help()",
        "        return 1",
        "",
        "    # Run the command",
        "    result = run(args.command, git=args.git)",
        "",
        "    # Output",
        "    if args.json:",
        "        print(result.to_json())",
        "    else:",
        "        if result.stdout:",
        "            print(result.stdout, end='')",
        "        if result.stderr:",
        "            print(result.stderr, end='', file=sys.stderr)",
        "",
        "    return result.exit_code",
        "",
        "",
        "if __name__ == '__main__':",
        "    sys.exit(main())"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "\"\"\"",
        "Tests for CLI wrapper framework.",
        "",
        "Tests cover:",
        "- ExecutionContext data collection",
        "- GitContext collection",
        "- HookRegistry registration and triggering",
        "- CLIWrapper command execution",
        "- TaskCompletionManager callbacks",
        "- ContextWindowManager tracking",
        "\"\"\"",
        "",
        "import os",
        "import sys",
        "import tempfile",
        "import time",
        "import unittest",
        "from pathlib import Path",
        "from unittest.mock import Mock, patch, MagicMock",
        "",
        "# Add parent directory for imports",
        "sys.path.insert(0, str(Path(__file__).parent.parent))",
        "",
        "from cortical.cli_wrapper import (",
        "    ExecutionContext,",
        "    GitContext,",
        "    HookRegistry,",
        "    HookType,",
        "    CLIWrapper,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    create_wrapper_with_completion_manager,",
        "    run_with_context,",
        "    run,",
        "    Session,",
        "    test_then_commit,",
        "    commit_and_push,",
        "    sync_with_main,",
        "    TaskCheckpoint,",
        ")",
        "",
        "",
        "class TestGitContext(unittest.TestCase):",
        "    \"\"\"Tests for GitContext collection.\"\"\"",
        "",
        "    def test_collect_non_repo(self):",
        "        \"\"\"Test collection outside git repo.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            ctx = GitContext.collect(tmpdir)",
        "            self.assertFalse(ctx.is_repo)",
        "            self.assertEqual(ctx.branch, \"\")",
        "",
        "    def test_collect_in_repo(self):",
        "        \"\"\"Test collection inside current repo.\"\"\"",
        "        # Current directory should be a git repo",
        "        ctx = GitContext.collect()",
        "        self.assertTrue(ctx.is_repo)",
        "        self.assertTrue(len(ctx.branch) > 0)",
        "",
        "    def test_to_dict(self):",
        "        \"\"\"Test conversion to dictionary.\"\"\"",
        "        ctx = GitContext(",
        "            is_repo=True,",
        "            branch=\"main\",",
        "            commit_hash=\"abc123\",",
        "            is_dirty=True,",
        "            staged_files=[\"file1.py\"],",
        "            modified_files=[\"file2.py\"],",
        "            untracked_files=[\"file3.py\"],",
        "        )",
        "        d = ctx.to_dict()",
        "        self.assertEqual(d['branch'], \"main\")",
        "        self.assertEqual(d['commit_hash'], \"abc123\")",
        "        self.assertTrue(d['is_dirty'])",
        "        self.assertEqual(len(d['staged_files']), 1)",
        "",
        "    def test_default_values(self):",
        "        \"\"\"Test default GitContext values.\"\"\"",
        "        ctx = GitContext()",
        "        self.assertFalse(ctx.is_repo)",
        "        self.assertEqual(ctx.branch, \"\")",
        "        self.assertEqual(ctx.commit_hash, \"\")",
        "        self.assertFalse(ctx.is_dirty)",
        "        self.assertEqual(ctx.staged_files, [])",
        "        self.assertEqual(ctx.modified_files, [])",
        "        self.assertEqual(ctx.untracked_files, [])",
        "",
        "",
        "class TestExecutionContext(unittest.TestCase):",
        "    \"\"\"Tests for ExecutionContext.\"\"\"",
        "",
        "    def test_default_values(self):",
        "        \"\"\"Test default context values.\"\"\"",
        "        ctx = ExecutionContext()",
        "        self.assertEqual(ctx.exit_code, 0)",
        "        self.assertEqual(ctx.command, [])",
        "        self.assertFalse(ctx.success)",
        "",
        "    def test_to_dict(self):",
        "        \"\"\"Test conversion to dictionary.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command=['echo', 'hello'],",
        "            command_str='echo hello',",
        "            exit_code=0,",
        "            success=True,",
        "            stdout='hello\\n',",
        "        )",
        "        d = ctx.to_dict()",
        "        self.assertEqual(d['command'], ['echo', 'hello'])",
        "        self.assertEqual(d['exit_code'], 0)",
        "        self.assertTrue(d['success'])",
        "",
        "    def test_to_json(self):",
        "        \"\"\"Test JSON serialization.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command=['test'],",
        "            success=True,",
        "        )",
        "        json_str = ctx.to_json()",
        "        self.assertIn('\"success\": true', json_str)",
        "        self.assertIn('\"command\":', json_str)",
        "        self.assertIn('\"test\"', json_str)",
        "",
        "    def test_summary(self):",
        "        \"\"\"Test summary generation.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command_str='pytest tests/',",
        "            success=True,",
        "            exit_code=0,",
        "            duration=1.5,",
        "        )",
        "        summary = ctx.summary()",
        "        self.assertIn('pytest tests/', summary)",
        "        self.assertIn('1.50s', summary)",
        "        self.assertIn('✓', summary)",
        "",
        "    def test_summary_failure(self):",
        "        \"\"\"Test summary for failed command.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command_str='pytest tests/',",
        "            success=False,",
        "            exit_code=1,",
        "            duration=0.5,",
        "        )",
        "        summary = ctx.summary()",
        "        self.assertIn('✗', summary)",
        "        self.assertIn('exit=1', summary)",
        "",
        "",
        "class TestHookRegistry(unittest.TestCase):",
        "    \"\"\"Tests for HookRegistry.\"\"\"",
        "",
        "    def test_register_global_hook(self):",
        "        \"\"\"Test registering a global hook.\"\"\"",
        "        registry = HookRegistry()",
        "        callback = Mock()",
        "",
        "        registry.register(HookType.POST_EXEC, callback)",
        "",
        "        hooks = registry.get_hooks(HookType.POST_EXEC, ['any', 'command'])",
        "        self.assertEqual(len(hooks), 1)",
        "        self.assertEqual(hooks[0], callback)",
        "",
        "    def test_register_pattern_hook(self):",
        "        \"\"\"Test registering a pattern-specific hook.\"\"\"",
        "        registry = HookRegistry()",
        "        git_callback = Mock()",
        "        pytest_callback = Mock()",
        "",
        "        registry.register(HookType.POST_EXEC, git_callback, pattern='git')",
        "        registry.register(HookType.POST_EXEC, pytest_callback, pattern='pytest')",
        "",
        "        # Git command should match git hook",
        "        git_hooks = registry.get_hooks(HookType.POST_EXEC, ['git', 'status'])",
        "        self.assertEqual(len(git_hooks), 1)",
        "        self.assertEqual(git_hooks[0], git_callback)",
        "",
        "        # Pytest command should match pytest hook",
        "        pytest_hooks = registry.get_hooks(HookType.POST_EXEC, ['pytest', 'tests/'])",
        "        self.assertEqual(len(pytest_hooks), 1)",
        "        self.assertEqual(pytest_hooks[0], pytest_callback)",
        "",
        "    def test_convenience_methods(self):",
        "        \"\"\"Test convenience registration methods.\"\"\"",
        "        registry = HookRegistry()",
        "        pre_cb = Mock()",
        "        post_cb = Mock()",
        "        success_cb = Mock()",
        "        error_cb = Mock()",
        "",
        "        registry.register_pre(None, pre_cb)",
        "        registry.register_post(None, post_cb)",
        "        registry.register_success('git', success_cb)",
        "        registry.register_error('pytest', error_cb)",
        "",
        "        self.assertEqual(len(registry.get_hooks(HookType.PRE_EXEC, ['any'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.POST_EXEC, ['any'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.ON_SUCCESS, ['git'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.ON_ERROR, ['pytest'])), 1)",
        "",
        "    def test_trigger_hooks(self):",
        "        \"\"\"Test triggering hooks.\"\"\"",
        "        registry = HookRegistry()",
        "        callback = Mock()",
        "        registry.register(HookType.POST_EXEC, callback)",
        "",
        "        ctx = ExecutionContext(command=['test'])",
        "        registry.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        callback.assert_called_once_with(ctx)",
        "",
        "    def test_hook_error_handling(self):",
        "        \"\"\"Test that hook errors don't crash execution.\"\"\"",
        "        registry = HookRegistry()",
        "",
        "        def bad_callback(ctx):",
        "            raise ValueError(\"Hook error!\")",
        "",
        "        registry.register(HookType.POST_EXEC, bad_callback)",
        "",
        "        ctx = ExecutionContext(command=['test'])",
        "        # Should not raise",
        "        registry.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        # Error should be recorded",
        "        self.assertIn('hook_errors', ctx.metadata)",
        "        self.assertTrue(any('Hook error!' in e for e in ctx.metadata['hook_errors']))",
        "",
        "",
        "class TestCLIWrapper(unittest.TestCase):",
        "    \"\"\"Tests for CLIWrapper.\"\"\"",
        "",
        "    def test_run_simple_command(self):",
        "        \"\"\"Test running a simple command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['echo', 'hello'])",
        "",
        "        self.assertEqual(result.exit_code, 0)",
        "        self.assertTrue(result.success)",
        "        self.assertIn('hello', result.stdout)",
        "        self.assertGreater(result.duration, 0)",
        "",
        "    def test_run_with_string_command(self):",
        "        \"\"\"Test running command as string.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run('echo hello')",
        "",
        "        self.assertEqual(result.exit_code, 0)",
        "        self.assertEqual(result.command, ['echo', 'hello'])",
        "",
        "    def test_run_failing_command(self):",
        "        \"\"\"Test handling failed command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "",
        "        self.assertEqual(result.exit_code, 1)",
        "        self.assertFalse(result.success)",
        "",
        "    def test_run_with_timeout(self):",
        "        \"\"\"Test command timeout handling.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(",
        "            ['python', '-c', 'import time; time.sleep(10)'],",
        "            timeout=0.1",
        "        )",
        "",
        "        self.assertFalse(result.success)",
        "        self.assertIn('timeout', result.metadata)",
        "",
        "    def test_run_nonexistent_command(self):",
        "        \"\"\"Test handling nonexistent command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['nonexistent_command_xyz'])",
        "",
        "        self.assertEqual(result.exit_code, 127)",
        "        self.assertFalse(result.success)",
        "        self.assertIn('error', result.metadata)",
        "",
        "    def test_task_classification(self):",
        "        \"\"\"Test task type classification.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        # Test task",
        "        result = wrapper.run(['echo', 'test'])  # not a test command",
        "        self.assertEqual(result.task_type, 'other')",
        "",
        "        # Simulate pytest classification",
        "        ctx = wrapper._build_context(['pytest', 'tests/'])",
        "        self.assertEqual(ctx.task_type, 'test')",
        "",
        "        # Git classification",
        "        ctx = wrapper._build_context(['git', 'commit', '-m', 'test'])",
        "        self.assertEqual(ctx.task_type, 'commit')",
        "",
        "    def test_hooks_triggered(self):",
        "        \"\"\"Test that hooks are triggered during execution.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        pre_called = []",
        "        post_called = []",
        "",
        "        def pre_hook(ctx):",
        "            pre_called.append(ctx.command_str)",
        "",
        "        def post_hook(ctx):",
        "            post_called.append((ctx.command_str, ctx.success))",
        "",
        "        wrapper.hooks.register_pre(None, pre_hook)",
        "        wrapper.hooks.register_post(None, post_hook)",
        "",
        "        wrapper.run(['echo', 'hello'])",
        "",
        "        self.assertEqual(len(pre_called), 1)",
        "        self.assertEqual(len(post_called), 1)",
        "        self.assertTrue(post_called[0][1])  # success = True",
        "",
        "    def test_success_error_hooks(self):",
        "        \"\"\"Test ON_SUCCESS and ON_ERROR hooks.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        success_calls = []",
        "        error_calls = []",
        "",
        "        wrapper.hooks.register_success(None, lambda ctx: success_calls.append(1))",
        "        wrapper.hooks.register_error(None, lambda ctx: error_calls.append(1))",
        "",
        "        # Successful command",
        "        wrapper.run(['echo', 'hello'])",
        "        self.assertEqual(len(success_calls), 1)",
        "        self.assertEqual(len(error_calls), 0)",
        "",
        "        # Failed command",
        "        wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "        self.assertEqual(len(success_calls), 1)  # unchanged",
        "        self.assertEqual(len(error_calls), 1)",
        "",
        "    def test_git_context_collection(self):",
        "        \"\"\"Test git context is collected when enabled.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=True)",
        "        result = wrapper.run(['echo', 'test'])",
        "",
        "        # Should have git context (we're in a git repo)",
        "        self.assertTrue(result.git.is_repo)",
        "        self.assertTrue(len(result.git.branch) > 0)",
        "",
        "    def test_output_capture(self):",
        "        \"\"\"Test stdout/stderr capture.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        # Stdout",
        "        result = wrapper.run(['echo', 'hello'])",
        "        self.assertIn('hello', result.stdout)",
        "        self.assertEqual(result.output_lines, 1)",
        "",
        "        # Stderr",
        "        result = wrapper.run(['python', '-c', 'import sys; print(\"error\", file=sys.stderr)'])",
        "        self.assertIn('error', result.stderr)",
        "        self.assertEqual(result.error_lines, 1)",
        "",
        "    def test_run_with_env(self):",
        "        \"\"\"Test running command with custom environment.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(",
        "            ['python', '-c', 'import os; print(os.environ.get(\"TEST_VAR\", \"\"))'],",
        "            env={'TEST_VAR': 'hello_test'}",
        "        )",
        "",
        "        self.assertTrue(result.success)",
        "        self.assertIn('hello_test', result.stdout)",
        "",
        "    def test_default_timeout(self):",
        "        \"\"\"Test wrapper with default timeout.\"\"\"",
        "        wrapper = CLIWrapper(",
        "            collect_git_context=False,",
        "            default_timeout=0.1",
        "        )",
        "        result = wrapper.run(['python', '-c', 'import time; time.sleep(10)'])",
        "",
        "        self.assertFalse(result.success)",
        "        self.assertIn('timeout', result.metadata)",
        "",
        "    def test_timeout_hook_triggered(self):",
        "        \"\"\"Test ON_TIMEOUT hook is triggered.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        timeout_calls = []",
        "",
        "        wrapper.hooks.register(",
        "            HookType.ON_TIMEOUT,",
        "            lambda ctx: timeout_calls.append(ctx.command_str)",
        "        )",
        "",
        "        wrapper.run(['python', '-c', 'import time; time.sleep(10)'], timeout=0.1)",
        "",
        "        self.assertEqual(len(timeout_calls), 1)",
        "",
        "    def test_capture_output_disabled(self):",
        "        \"\"\"Test wrapper with capture_output disabled.\"\"\"",
        "        wrapper = CLIWrapper(",
        "            collect_git_context=False,",
        "            capture_output=False",
        "        )",
        "        result = wrapper.run(['echo', 'test'])",
        "",
        "        self.assertTrue(result.success)",
        "        # stdout/stderr not captured",
        "        self.assertEqual(result.stdout, \"\")",
        "        self.assertEqual(result.stderr, \"\")",
        "",
        "",
        "class TestTaskCompletionManager(unittest.TestCase):",
        "    \"\"\"Tests for TaskCompletionManager.\"\"\"",
        "",
        "    def test_register_task_handler(self):",
        "        \"\"\"Test registering task-specific handlers.\"\"\"",
        "        manager = TaskCompletionManager()",
        "        handler_calls = []",
        "",
        "        manager.on_task_complete('test', lambda ctx: handler_calls.append(ctx))",
        "",
        "        # Simulate completion",
        "        ctx = ExecutionContext(task_type='test', success=True)",
        "        manager.handle_completion(ctx)",
        "",
        "        self.assertEqual(len(handler_calls), 1)",
        "        self.assertEqual(handler_calls[0], ctx)",
        "",
        "    def test_register_any_handler(self):",
        "        \"\"\"Test registering global completion handler.\"\"\"",
        "        manager = TaskCompletionManager()",
        "        handler_calls = []",
        "",
        "        manager.on_any_complete(lambda ctx: handler_calls.append(ctx.task_type))",
        "",
        "        manager.handle_completion(ExecutionContext(task_type='test'))",
        "        manager.handle_completion(ExecutionContext(task_type='commit'))",
        "        manager.handle_completion(ExecutionContext(task_type='build'))",
        "",
        "        self.assertEqual(handler_calls, ['test', 'commit', 'build'])",
        "",
        "    def test_session_summary(self):",
        "        \"\"\"Test session summary generation.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        # Empty summary",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 0)",
        "",
        "        # Add some completions",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='test',",
        "            success=True,",
        "            duration=1.0",
        "        ))",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='test',",
        "            success=False,",
        "            duration=0.5",
        "        ))",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='commit',",
        "            success=True,",
        "            duration=0.2",
        "        ))",
        "",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 3)",
        "        self.assertAlmostEqual(summary['success_rate'], 2/3, places=2)",
        "        self.assertAlmostEqual(summary['total_duration'], 1.7, places=2)",
        "        self.assertEqual(summary['tasks_by_type']['test']['count'], 2)",
        "        self.assertEqual(summary['tasks_by_type']['commit']['successes'], 1)",
        "",
        "    def test_should_trigger_reindex_on_commit(self):",
        "        \"\"\"Test reindex recommendation after commit.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        # No activity",
        "        self.assertFalse(manager.should_trigger_reindex())",
        "",
        "        # Commit success should trigger",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='commit',",
        "            success=True,",
        "        ))",
        "        self.assertTrue(manager.should_trigger_reindex())",
        "",
        "    def test_should_trigger_reindex_on_file_changes(self):",
        "        \"\"\"Test reindex recommendation on file changes.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        ctx = ExecutionContext(task_type='other')",
        "        ctx.git.modified_files = ['test.py']",
        "        manager.handle_completion(ctx)",
        "",
        "        self.assertTrue(manager.should_trigger_reindex())",
        "",
        "",
        "class TestContextWindowManager(unittest.TestCase):",
        "    \"\"\"Tests for ContextWindowManager.\"\"\"",
        "",
        "    def test_add_execution(self):",
        "        \"\"\"Test adding executions to context.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        ctx = ExecutionContext(",
        "            task_type='test',",
        "            command_str='pytest tests/',",
        "            success=True,",
        "            duration=1.0,",
        "        )",
        "        manager.add_execution(ctx)",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['executions'], 1)",
        "        self.assertEqual(summary['task_types']['test'], 1)",
        "",
        "    def test_add_file_read(self):",
        "        \"\"\"Test tracking file reads.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        manager.add_file_read('test.py')",
        "        manager.add_file_read('another.py')",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['file_reads'], 2)",
        "        self.assertEqual(summary['unique_files_accessed'], 2)",
        "",
        "    def test_recent_files(self):",
        "        \"\"\"Test getting recently accessed files.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        manager.add_file_read('old.py')",
        "        time.sleep(0.01)  # Small delay",
        "        manager.add_file_read('new.py')",
        "",
        "        recent = manager.get_recent_files(limit=2)",
        "        self.assertEqual(recent[0], 'new.py')  # Most recent first",
        "",
        "    def test_context_pruning_suggestion(self):",
        "        \"\"\"Test pruning suggestions for stale files.\"\"\"",
        "        manager = ContextWindowManager(max_context_items=10)",
        "",
        "        # Add some files",
        "        for i in range(20):",
        "            manager.add_file_read(f'file{i}.py')",
        "",
        "        # With default 5-minute staleness, nothing should be stale yet",
        "        suggestions = manager.suggest_pruning()",
        "        # All files accessed just now, so no suggestions expected",
        "        # (unless we mock time)",
        "        self.assertIsInstance(suggestions, list)",
        "",
        "    def test_max_context_pruning(self):",
        "        \"\"\"Test automatic pruning when max context exceeded.\"\"\"",
        "        manager = ContextWindowManager(max_context_items=5)",
        "",
        "        # Add more items than max",
        "        for i in range(10):",
        "            ctx = ExecutionContext(task_type='test', command_str=f'cmd{i}')",
        "            manager.add_execution(ctx)",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['total_items'], 5)",
        "",
        "",
        "class TestConvenienceFunctions(unittest.TestCase):",
        "    \"\"\"Tests for convenience functions.\"\"\"",
        "",
        "    def test_create_wrapper_with_manager(self):",
        "        \"\"\"Test creating wrapper with completion manager.\"\"\"",
        "        wrapper, manager = create_wrapper_with_completion_manager()",
        "",
        "        self.assertIsInstance(wrapper, CLIWrapper)",
        "        self.assertIsInstance(manager, TaskCompletionManager)",
        "",
        "        # Run a command and verify manager receives it",
        "        wrapper.run(['echo', 'test'])",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 1)",
        "",
        "    def test_run_with_context(self):",
        "        \"\"\"Test run_with_context convenience function.\"\"\"",
        "        result = run_with_context(['echo', 'hello'])",
        "",
        "        self.assertIsInstance(result, ExecutionContext)",
        "        self.assertTrue(result.success)",
        "        self.assertIn('hello', result.stdout)",
        "",
        "    def test_run_with_context_string_command(self):",
        "        \"\"\"Test run_with_context with string command.\"\"\"",
        "        result = run_with_context(\"echo test\")",
        "",
        "        self.assertTrue(result.success)",
        "        self.assertIn(\"test\", result.stdout)",
        "",
        "    def test_run_with_cwd(self):",
        "        \"\"\"Test run() with custom working directory.\"\"\"",
        "        result = run(\"pwd\", cwd=\"/tmp\")",
        "",
        "        self.assertTrue(result.success)",
        "        self.assertIn(\"/tmp\", result.stdout)",
        "",
        "",
        "class TestIntegration(unittest.TestCase):",
        "    \"\"\"Integration tests for the wrapper system.\"\"\"",
        "",
        "    def test_full_workflow(self):",
        "        \"\"\"Test complete workflow with hooks and completion tracking.\"\"\"",
        "        wrapper, manager = create_wrapper_with_completion_manager()",
        "",
        "        # Track hook calls",
        "        hook_calls = []",
        "        wrapper.hooks.register_pre(None, lambda ctx: hook_calls.append('pre'))",
        "        wrapper.hooks.register_post(None, lambda ctx: hook_calls.append('post'))",
        "",
        "        # Track completion",
        "        completion_data = []",
        "        manager.on_any_complete(lambda ctx: completion_data.append({",
        "            'cmd': ctx.command_str,",
        "            'success': ctx.success,",
        "        }))",
        "",
        "        # Run commands",
        "        wrapper.run(['echo', 'first'])",
        "        wrapper.run(['echo', 'second'])",
        "        wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "",
        "        # Verify hooks",
        "        self.assertEqual(hook_calls.count('pre'), 3)",
        "        self.assertEqual(hook_calls.count('post'), 3)",
        "",
        "        # Verify completions",
        "        self.assertEqual(len(completion_data), 3)",
        "        self.assertTrue(completion_data[0]['success'])",
        "        self.assertTrue(completion_data[1]['success'])",
        "        self.assertFalse(completion_data[2]['success'])",
        "",
        "        # Verify session summary",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 3)",
        "        self.assertAlmostEqual(summary['success_rate'], 2/3, places=2)",
        "",
        "",
        "class TestSimpleRunAPI(unittest.TestCase):",
        "    \"\"\"Tests for the simple run() API.\"\"\"",
        "",
        "    def test_run_basic(self):",
        "        \"\"\"Test basic run() usage.\"\"\"",
        "        result = run(\"echo hello\")",
        "        self.assertTrue(result.success)",
        "        self.assertIn(\"hello\", result.stdout)",
        "",
        "    def test_run_no_git_by_default(self):",
        "        \"\"\"Test that git context is not collected by default.\"\"\"",
        "        result = run(\"echo test\")",
        "        # Git context should be empty/default when git=False",
        "        self.assertFalse(result.git.is_repo)",
        "",
        "    def test_run_with_git(self):",
        "        \"\"\"Test run with git context.\"\"\"",
        "        result = run(\"echo test\", git=True)",
        "        # We're in a git repo, so this should be True",
        "        self.assertTrue(result.git.is_repo)",
        "        self.assertTrue(len(result.git.branch) > 0)",
        "",
        "    def test_run_with_timeout(self):",
        "        \"\"\"Test run with timeout.\"\"\"",
        "        result = run(\"python -c 'import time; time.sleep(10)'\", timeout=0.1)",
        "        self.assertFalse(result.success)",
        "",
        "    def test_run_failure(self):",
        "        \"\"\"Test run with failing command.\"\"\"",
        "        result = run([\"python\", \"-c\", \"import sys; sys.exit(42)\"])",
        "        self.assertFalse(result.success)",
        "        self.assertEqual(result.exit_code, 42)",
        "",
        "",
        "class TestSession(unittest.TestCase):",
        "    \"\"\"Tests for Session context manager.\"\"\"",
        "",
        "    def test_session_basic(self):",
        "        \"\"\"Test basic session usage.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo first\")",
        "            s.run(\"echo second\")",
        "",
        "        self.assertEqual(len(s.results), 2)",
        "        self.assertTrue(s.all_passed)",
        "",
        "    def test_session_tracks_failures(self):",
        "        \"\"\"Test session tracks failures correctly.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo ok\")",
        "            s.run(\"python -c 'import sys; sys.exit(1)'\")",
        "            s.run(\"echo also ok\")",
        "",
        "        self.assertEqual(len(s.results), 3)",
        "        self.assertFalse(s.all_passed)",
        "        self.assertAlmostEqual(s.success_rate, 2/3, places=2)",
        "",
        "    def test_session_summary(self):",
        "        \"\"\"Test session summary.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo test\")",
        "            summary = s.summary()",
        "",
        "        self.assertEqual(summary['task_count'], 1)",
        "        self.assertEqual(summary['success_rate'], 1.0)",
        "",
        "    def test_session_should_reindex(self):",
        "        \"\"\"Test should_reindex detection.\"\"\"",
        "        with Session(git=True) as s:",
        "            # Just an echo - no code changes",
        "            s.run(\"echo test\")",
        "",
        "        # No commits or file changes, shouldn't need reindex",
        "        # (Unless the test repo is dirty)",
        "        # Just verify it returns a boolean",
        "        self.assertIsInstance(s.should_reindex(), bool)",
        "",
        "    def test_session_context_manager(self):",
        "        \"\"\"Test session works as context manager.\"\"\"",
        "        results_outside = []",
        "",
        "        with Session(git=False) as s:",
        "            result = s.run(\"echo inside\")",
        "            results_outside.append(result)",
        "",
        "        # Can still access results after exiting",
        "        self.assertEqual(len(s.results), 1)",
        "        self.assertTrue(s.results[0].success)",
        "",
        "    def test_session_success_rate_empty(self):",
        "        \"\"\"Test success_rate with no commands.\"\"\"",
        "        with Session(git=False) as s:",
        "            pass  # No commands run",
        "",
        "        self.assertEqual(s.success_rate, 1.0)  # Default to 1.0",
        "",
        "    def test_session_modified_files(self):",
        "        \"\"\"Test modified_files property.\"\"\"",
        "        with Session(git=True) as s:",
        "            s.run(\"echo test\")",
        "",
        "        # Should return a list (possibly empty)",
        "        self.assertIsInstance(s.modified_files, list)",
        "",
        "    def test_session_with_git_context(self):",
        "        \"\"\"Test session collects git context when enabled.\"\"\"",
        "        with Session(git=True) as s:",
        "            result = s.run(\"echo test\")",
        "",
        "        # Git context should be collected",
        "        self.assertTrue(result.git.is_repo)",
        "",
        "",
        "class TestDecoratorHooks(unittest.TestCase):",
        "    \"\"\"Tests for decorator-style hook registration.\"\"\"",
        "",
        "    def test_on_success_decorator(self):",
        "        \"\"\"Test @wrapper.on_success decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        calls = []",
        "",
        "        @wrapper.on_success()",
        "        def track_success(ctx):",
        "            calls.append(('success', ctx.command_str))",
        "",
        "        wrapper.run(\"echo hello\")",
        "        wrapper.run(\"python -c 'import sys; sys.exit(1)'\")",
        "",
        "        # Only the successful command should trigger",
        "        self.assertEqual(len(calls), 1)",
        "        self.assertEqual(calls[0][0], 'success')",
        "",
        "    def test_on_error_decorator(self):",
        "        \"\"\"Test @wrapper.on_error decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        errors = []",
        "",
        "        @wrapper.on_error()",
        "        def track_error(ctx):",
        "            errors.append(ctx.exit_code)",
        "",
        "        wrapper.run([\"echo\", \"hello\"])  # success",
        "        wrapper.run([\"python\", \"-c\", \"import sys; sys.exit(1)\"])  # fail",
        "        wrapper.run([\"python\", \"-c\", \"import sys; sys.exit(2)\"])  # fail",
        "",
        "        self.assertEqual(len(errors), 2)",
        "        self.assertEqual(errors, [1, 2])",
        "",
        "    def test_on_complete_decorator(self):",
        "        \"\"\"Test @wrapper.on_complete decorator.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        completions = []",
        "",
        "        @wrapper.on_complete()",
        "        def track_all(ctx):",
        "            completions.append(ctx.success)",
        "",
        "        wrapper.run(\"echo hello\")",
        "        wrapper.run(\"python -c 'import sys; sys.exit(1)'\")",
        "",
        "        self.assertEqual(completions, [True, False])",
        "",
        "    def test_pattern_decorator(self):",
        "        \"\"\"Test decorator with pattern matching.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        echo_count = [0]",
        "",
        "        @wrapper.on_success(\"echo\")",
        "        def on_echo_success(ctx):",
        "            echo_count[0] += 1",
        "",
        "        wrapper.run(\"echo one\")",
        "        wrapper.run(\"echo two\")",
        "        wrapper.run(\"python -c 'print(1)'\")  # Not echo",
        "",
        "        self.assertEqual(echo_count[0], 2)",
        "",
        "",
        "class TestCompoundCommands(unittest.TestCase):",
        "    \"\"\"Tests for compound command functions.\"\"\"",
        "",
        "    def test_test_then_commit_fails_on_test_failure(self):",
        "        \"\"\"Test that test_then_commit stops if tests fail.\"\"\"",
        "        # Use a test command that fails",
        "        ok, results = test_then_commit(",
        "            test_cmd=[\"python\", \"-c\", \"import sys; sys.exit(1)\"],",
        "            message=\"Should not commit\"",
        "        )",
        "",
        "        self.assertFalse(ok)",
        "        self.assertEqual(len(results), 1)  # Only test ran",
        "        self.assertFalse(results[0].success)",
        "",
        "    def test_test_then_commit_returns_results(self):",
        "        \"\"\"Test that results are returned correctly.\"\"\"",
        "        # Use a test that passes",
        "        ok, results = test_then_commit(",
        "            test_cmd=[\"echo\", \"tests pass\"],",
        "            message=\"Test commit\",",
        "            add_all=False  # Don't actually add files",
        "        )",
        "",
        "        # Test passed, so we get test result + commit attempt",
        "        self.assertGreaterEqual(len(results), 1)",
        "        self.assertTrue(results[0].success)  # echo succeeded",
        "",
        "    def test_sync_with_main_returns_tuple(self):",
        "        \"\"\"Test sync_with_main returns proper structure.\"\"\"",
        "        # This will likely fail (no remote) but should return proper tuple",
        "        ok, results = sync_with_main(main_branch=\"nonexistent-branch-xyz\")",
        "",
        "        self.assertIsInstance(ok, bool)",
        "        self.assertIsInstance(results, list)",
        "        self.assertGreater(len(results), 0)",
        "",
        "    def test_commit_and_push_returns_tuple(self):",
        "        \"\"\"Test commit_and_push returns proper structure.\"\"\"",
        "        # Will fail (nothing to commit) but should return proper tuple",
        "        ok, results = commit_and_push(",
        "            message=\"Test message\",",
        "            add_all=False  # Don't add files",
        "        )",
        "",
        "        self.assertIsInstance(ok, bool)",
        "        self.assertIsInstance(results, list)",
        "",
        "    def test_commit_and_push_with_add_all_false(self):",
        "        \"\"\"Test commit_and_push without adding files.\"\"\"",
        "        ok, results = commit_and_push(",
        "            message=\"No add\",",
        "            add_all=False",
        "        )",
        "",
        "        # Should have at least the commit attempt",
        "        self.assertGreaterEqual(len(results), 1)",
        "",
        "    def test_commit_and_push_explicit_branch(self):",
        "        \"\"\"Test commit_and_push with explicit branch name.\"\"\"",
        "        ok, results = commit_and_push(",
        "            message=\"Test\",",
        "            add_all=False,",
        "            branch=\"test-branch-xyz\"",
        "        )",
        "",
        "        # Should return results regardless of success",
        "        self.assertIsInstance(results, list)",
        "",
        "    def test_test_then_commit_with_string_command(self):",
        "        \"\"\"Test test_then_commit with string test command.\"\"\"",
        "        ok, results = test_then_commit(",
        "            test_cmd=\"echo passing\",",
        "            message=\"String cmd test\",",
        "            add_all=False",
        "        )",
        "",
        "        self.assertTrue(results[0].success)",
        "",
        "",
        "class TestTaskCheckpoint(unittest.TestCase):",
        "    \"\"\"Tests for TaskCheckpoint context saving.\"\"\"",
        "",
        "    def setUp(self):",
        "        \"\"\"Create a temporary checkpoint directory.\"\"\"",
        "        self.tmpdir = tempfile.mkdtemp()",
        "        self.checkpoint = TaskCheckpoint(checkpoint_dir=self.tmpdir)",
        "",
        "    def tearDown(self):",
        "        \"\"\"Clean up temporary directory.\"\"\"",
        "        import shutil",
        "        shutil.rmtree(self.tmpdir, ignore_errors=True)",
        "",
        "    def test_save_and_load(self):",
        "        \"\"\"Test saving and loading a checkpoint.\"\"\"",
        "        context = {",
        "            'branch': 'feature/test',",
        "            'notes': 'Working on tests',",
        "            'files': ['test.py'],",
        "        }",
        "",
        "        self.checkpoint.save(\"my-task\", context)",
        "        loaded = self.checkpoint.load(\"my-task\")",
        "",
        "        self.assertEqual(loaded['branch'], 'feature/test')",
        "        self.assertEqual(loaded['notes'], 'Working on tests')",
        "        self.assertEqual(loaded['files'], ['test.py'])",
        "",
        "    def test_load_nonexistent(self):",
        "        \"\"\"Test loading a nonexistent checkpoint returns None.\"\"\"",
        "        result = self.checkpoint.load(\"does-not-exist\")",
        "        self.assertIsNone(result)",
        "",
        "    def test_list_tasks(self):",
        "        \"\"\"Test listing saved tasks.\"\"\"",
        "        self.checkpoint.save(\"task-a\", {'note': 'a'})",
        "        self.checkpoint.save(\"task-b\", {'note': 'b'})",
        "",
        "        tasks = self.checkpoint.list_tasks()",
        "",
        "        self.assertIn(\"task-a\", tasks)",
        "        self.assertIn(\"task-b\", tasks)",
        "",
        "    def test_delete(self):",
        "        \"\"\"Test deleting a checkpoint.\"\"\"",
        "        self.checkpoint.save(\"to-delete\", {'temp': True})",
        "",
        "        # Should exist",
        "        self.assertIsNotNone(self.checkpoint.load(\"to-delete\"))",
        "",
        "        # Delete it",
        "        deleted = self.checkpoint.delete(\"to-delete\")",
        "        self.assertTrue(deleted)",
        "",
        "        # Should be gone",
        "        self.assertIsNone(self.checkpoint.load(\"to-delete\"))",
        "",
        "    def test_delete_nonexistent(self):",
        "        \"\"\"Test deleting nonexistent checkpoint returns False.\"\"\"",
        "        deleted = self.checkpoint.delete(\"never-existed\")",
        "        self.assertFalse(deleted)",
        "",
        "    def test_summarize(self):",
        "        \"\"\"Test one-line summary generation.\"\"\"",
        "        self.checkpoint.save(\"feature-x\", {",
        "            'branch': 'feature/x',",
        "            'notes': 'Need to add validation',",
        "        })",
        "",
        "        summary = self.checkpoint.summarize(\"feature-x\")",
        "",
        "        self.assertIn(\"feature-x\", summary)",
        "        self.assertIn(\"[feature/x]\", summary)",
        "        self.assertIn(\"validation\", summary)",
        "",
        "    def test_summarize_truncates_long_notes(self):",
        "        \"\"\"Test that long notes are truncated.\"\"\"",
        "        long_notes = \"A\" * 100  # 100 chars",
        "",
        "        self.checkpoint.save(\"verbose-task\", {",
        "            'notes': long_notes,",
        "        })",
        "",
        "        summary = self.checkpoint.summarize(\"verbose-task\")",
        "",
        "        # Should be truncated",
        "        self.assertLess(len(summary), 100)",
        "        self.assertIn(\"...\", summary)",
        "",
        "    def test_summarize_without_notes(self):",
        "        \"\"\"Test summarize with no notes field.\"\"\"",
        "        self.checkpoint.save(\"no-notes\", {",
        "            'branch': 'feature/x',",
        "        })",
        "",
        "        summary = self.checkpoint.summarize(\"no-notes\")",
        "",
        "        self.assertIn(\"no-notes\", summary)",
        "        self.assertIn(\"[feature/x]\", summary)",
        "",
        "    def test_summarize_nonexistent(self):",
        "        \"\"\"Test summarize for nonexistent task.\"\"\"",
        "        result = self.checkpoint.summarize(\"does-not-exist\")",
        "        self.assertIsNone(result)",
        "",
        "    def test_summarize_minimal(self):",
        "        \"\"\"Test summarize with minimal context.\"\"\"",
        "        self.checkpoint.save(\"minimal\", {})",
        "",
        "        summary = self.checkpoint.summarize(\"minimal\")",
        "",
        "        self.assertEqual(summary, \"minimal\")",
        "",
        "",
        "class TestContextWindowManagerEdgeCases(unittest.TestCase):",
        "    \"\"\"Additional tests for ContextWindowManager edge cases.\"\"\"",
        "",
        "    def test_get_recent_files_empty(self):",
        "        \"\"\"Test get_recent_files with no files.\"\"\"",
        "        manager = ContextWindowManager()",
        "        recent = manager.get_recent_files()",
        "        self.assertEqual(recent, [])",
        "",
        "    def test_suggest_pruning_below_threshold(self):",
        "        \"\"\"Test suggest_pruning when below threshold.\"\"\"",
        "        manager = ContextWindowManager(max_context_items=100)",
        "",
        "        # Add a few files (well below threshold)",
        "        manager.add_file_read(\"file1.py\")",
        "        manager.add_file_read(\"file2.py\")",
        "",
        "        # Should return empty - not enough items to suggest pruning",
        "        suggestions = manager.suggest_pruning()",
        "        self.assertEqual(suggestions, [])",
        "",
        "    def test_context_summary_empty(self):",
        "        \"\"\"Test context summary with no items.\"\"\"",
        "        manager = ContextWindowManager()",
        "        summary = manager.get_context_summary()",
        "",
        "        self.assertEqual(summary['total_items'], 0)",
        "        self.assertEqual(summary['executions'], 0)",
        "        self.assertEqual(summary['file_reads'], 0)",
        "        self.assertEqual(summary['task_types'], {})",
        "        self.assertEqual(summary['recent_files'], [])",
        "        self.assertEqual(summary['unique_files_accessed'], 0)",
        "",
        "",
        "class TestHookRegistryEdgeCases(unittest.TestCase):",
        "    \"\"\"Additional tests for HookRegistry edge cases.\"\"\"",
        "",
        "    def test_get_hooks_empty_command(self):",
        "        \"\"\"Test get_hooks with empty command list.\"\"\"",
        "        registry = HookRegistry()",
        "        callback = Mock()",
        "        registry.register(HookType.POST_EXEC, callback)",
        "",
        "        hooks = registry.get_hooks(HookType.POST_EXEC, [])",
        "        self.assertEqual(len(hooks), 1)  # Global hook still returned",
        "",
        "    def test_multiple_patterns_same_hook_type(self):",
        "        \"\"\"Test multiple pattern hooks for same type.\"\"\"",
        "        registry = HookRegistry()",
        "        git_cb = Mock()",
        "        pytest_cb = Mock()",
        "",
        "        registry.register(HookType.POST_EXEC, git_cb, pattern='git')",
        "        registry.register(HookType.POST_EXEC, pytest_cb, pattern='pytest')",
        "",
        "        # Neither should match 'echo'",
        "        hooks = registry.get_hooks(HookType.POST_EXEC, ['echo', 'hello'])",
        "        self.assertEqual(len(hooks), 0)",
        "",
        "",
        "class TestExecutionContextEdgeCases(unittest.TestCase):",
        "    \"\"\"Additional tests for ExecutionContext edge cases.\"\"\"",
        "",
        "    def test_metadata_field(self):",
        "        \"\"\"Test that metadata field works correctly.\"\"\"",
        "        ctx = ExecutionContext()",
        "        ctx.metadata['custom_key'] = 'custom_value'",
        "",
        "        self.assertEqual(ctx.metadata['custom_key'], 'custom_value')",
        "",
        "        d = ctx.to_dict()",
        "        self.assertEqual(d['metadata']['custom_key'], 'custom_value')",
        "",
        "    def test_to_dict_complete(self):",
        "        \"\"\"Test to_dict includes all fields.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command=['test', 'cmd'],",
        "            command_str='test cmd',",
        "            exit_code=0,",
        "            success=True,",
        "            stdout='output',",
        "            stderr='error',",
        "            duration=1.5,",
        "            task_type='test',",
        "        )",
        "        d = ctx.to_dict()",
        "",
        "        self.assertEqual(d['command'], ['test', 'cmd'])",
        "        self.assertEqual(d['command_str'], 'test cmd')",
        "        self.assertEqual(d['exit_code'], 0)",
        "        self.assertTrue(d['success'])",
        "        self.assertEqual(d['stdout'], 'output')",
        "        self.assertEqual(d['stderr'], 'error')",
        "        self.assertEqual(d['duration'], 1.5)",
        "        self.assertEqual(d['task_type'], 'test')",
        "",
        "",
        "class TestCLIWrapperTaskClassification(unittest.TestCase):",
        "    \"\"\"Tests for task type classification.\"\"\"",
        "",
        "    def test_classify_test_commands(self):",
        "        \"\"\"Test classification of test commands.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context(['pytest', 'tests/'])",
        "        self.assertEqual(ctx.task_type, 'test')",
        "",
        "        ctx = wrapper._build_context(['python', '-m', 'unittest'])",
        "        self.assertEqual(ctx.task_type, 'test')",
        "",
        "    def test_classify_git_commands(self):",
        "        \"\"\"Test classification of git commands.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context(['git', 'commit', '-m', 'msg'])",
        "        self.assertEqual(ctx.task_type, 'commit')",
        "",
        "        ctx = wrapper._build_context(['git', 'add', '.'])",
        "        self.assertEqual(ctx.task_type, 'commit')",
        "",
        "    def test_classify_build_commands(self):",
        "        \"\"\"Test classification of build commands.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context(['make'])",
        "        self.assertEqual(ctx.task_type, 'build')",
        "",
        "    def test_classify_lint_commands(self):",
        "        \"\"\"Test classification of lint commands.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context(['flake8', 'src/'])",
        "        self.assertEqual(ctx.task_type, 'lint')",
        "",
        "        ctx = wrapper._build_context(['mypy', 'src/'])",
        "        self.assertEqual(ctx.task_type, 'lint')",
        "",
        "    def test_classify_unknown_commands(self):",
        "        \"\"\"Test classification of unknown commands.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context(['echo', 'hello'])",
        "        self.assertEqual(ctx.task_type, 'other')",
        "",
        "    def test_classify_empty_command(self):",
        "        \"\"\"Test classification of empty command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        ctx = wrapper._build_context([])",
        "        self.assertEqual(ctx.task_type, 'unknown')",
        "",
        "",
        "class TestSessionAllPassed(unittest.TestCase):",
        "    \"\"\"Tests for Session.all_passed edge cases.\"\"\"",
        "",
        "    def test_all_passed_empty_results(self):",
        "        \"\"\"Test all_passed with no results returns True.\"\"\"",
        "        with Session(git=False) as s:",
        "            # Don't run anything",
        "            pass",
        "",
        "        # Empty results should return True (vacuous truth)",
        "        self.assertTrue(s.all_passed)",
        "",
        "    def test_all_passed_single_success(self):",
        "        \"\"\"Test all_passed with single success.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run(\"echo ok\")",
        "",
        "        self.assertTrue(s.all_passed)",
        "",
        "    def test_all_passed_single_failure(self):",
        "        \"\"\"Test all_passed with single failure.\"\"\"",
        "        with Session(git=False) as s:",
        "            s.run([\"python\", \"-c\", \"import sys; sys.exit(1)\"])",
        "",
        "        self.assertFalse(s.all_passed)",
        "",
        "",
        "class TestTaskCompletionManagerEdgeCases(unittest.TestCase):",
        "    \"\"\"Additional tests for TaskCompletionManager.\"\"\"",
        "",
        "    def test_handler_exception_caught(self):",
        "        \"\"\"Test that handler exceptions don't crash completion.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        def bad_handler(ctx):",
        "            raise ValueError(\"Handler error!\")",
        "",
        "        manager.on_task_complete('test', bad_handler)",
        "",
        "        ctx = ExecutionContext(task_type='test', success=True)",
        "        # Should not raise",
        "        manager.handle_completion(ctx)",
        "",
        "        # Error should be logged",
        "        self.assertIn('completion_errors', ctx.metadata)",
        "",
        "    def test_global_handler_exception_caught(self):",
        "        \"\"\"Test that global handler exceptions don't crash completion.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        def bad_handler(ctx):",
        "            raise RuntimeError(\"Global handler error!\")",
        "",
        "        manager.on_any_complete(bad_handler)",
        "",
        "        ctx = ExecutionContext(task_type='test', success=True)",
        "        # Should not raise",
        "        manager.handle_completion(ctx)",
        "",
        "        self.assertIn('completion_errors', ctx.metadata)",
        "",
        "    def test_should_reindex_non_code_files(self):",
        "        \"\"\"Test that non-code files don't trigger reindex.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        ctx = ExecutionContext(task_type='other')",
        "        ctx.git.modified_files = ['image.png', 'data.csv']",
        "        manager.handle_completion(ctx)",
        "",
        "        # Non-code files shouldn't trigger reindex",
        "        self.assertFalse(manager.should_trigger_reindex())",
        "",
        "",
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    }
  ],
  "hour_of_day": 18,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -327781,
  "is_merge": true,
  "is_initial": false,
  "parent_count": 2,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}