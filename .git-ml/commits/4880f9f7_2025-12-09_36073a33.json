{
  "hash": "4880f9f7901349008218d650d8d6e0da6453b235",
  "message": "Add cross-layer feedforward/feedback connections (Task 19)",
  "author": "Claude",
  "timestamp": "2025-12-09 22:43:43 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "TASK_LIST.md",
    "cortical/analysis.py",
    "cortical/minicolumn.py",
    "cortical/processor.py",
    "tests/test_processor.py"
  ],
  "insertions": 277,
  "deletions": 32,
  "hunks": [
    {
      "file": "TASK_LIST.md",
      "function": "for query, passages in zip(queries, results):",
      "start_line": 534,
      "lines_added": [
        "**Files:** `cortical/analysis.py`, `cortical/processor.py`, `cortical/minicolumn.py`",
        "**Status:** [x] Completed",
        "Layers were isolated - concepts didn't connect back to their member tokens, and bigrams didn't link to component unigrams. This broke the hierarchical flow needed for cross-layer PageRank.",
        "**Solution Applied:**",
        "1. Added `feedforward_connections: Dict[str, float]` to Minicolumn (weighted links to lower layer)",
        "2. Added `feedback_connections: Dict[str, float]` to Minicolumn (weighted links to higher layer)",
        "3. Added helper methods: `add_feedforward_connection()`, `add_feedback_connection()`",
        "4. Updated bigram creation to link to component tokens with weight 1.0 per occurrence",
        "5. Updated document processing to create bidirectional doc↔token connections",
        "6. Updated concept creation to link to member tokens weighted by normalized PageRank",
        "7. Updated `to_dict()`/`from_dict()` for persistence",
        "**Files Modified:**",
        "- `cortical/minicolumn.py` - Added connection fields and helper methods (~50 lines)",
        "- `cortical/processor.py` - Populate feedforward/feedback during document processing",
        "- `cortical/analysis.py` - Updated `build_concept_clusters()` to create weighted links",
        "- `tests/test_processor.py` - Added 12 tests for cross-layer connections",
        "**Connection Types:**",
        "```python",
        "# Bigram → Tokens (weight by occurrence count)",
        "bigram.feedforward_connections[\"L0_neural\"] = 2.0  # seen twice",
        "",
        "# Token → Bigrams (feedback)",
        "token.feedback_connections[\"L1_neural_networks\"] = 2.0",
        "",
        "# Document → Tokens (weight by term frequency)",
        "doc.feedforward_connections[\"L0_neural\"] = 3.0  # appears 3 times",
        "",
        "# Concept → Tokens (weight by normalized PageRank)",
        "concept.feedforward_connections[\"L0_neural\"] = 1.0  # highest PR",
        "concept.feedforward_connections[\"L0_networks\"] = 0.7  # lower PR",
        "```"
      ],
      "lines_removed": [
        "**Files:** `cortical/analysis.py`, `cortical/processor.py`",
        "**Status:** [ ] Pending",
        "Layers are currently isolated - concepts don't connect back to their member tokens, and bigrams don't link to component unigrams. This breaks the hierarchical flow needed for cross-layer PageRank.",
        "**Current State:**",
        "- Concepts have `feedforward_sources` (set of token IDs) but no weighted connections",
        "- Bigrams store content like \"neural_networks\" but don't link to \"neural\" or \"networks\" minicolumns",
        "- No upward or downward propagation paths between layers",
        "**Implementation Steps:**",
        "1. Add `feedforward_connections: Dict[str, float]` to Minicolumn (weighted links to lower layer)",
        "2. Add `feedback_connections: Dict[str, float]` to Minicolumn (weighted links to higher layer)",
        "3. Update bigram creation to link to component tokens with weight 1.0",
        "4. Update concept creation to link to member tokens weighted by token PageRank",
        "5. Update persistence to save/load new connection types",
        "**Files to Modify:**",
        "- `cortical/minicolumn.py` - Add new connection fields",
        "- `cortical/processor.py` - Populate feedforward connections during processing",
        "- `cortical/analysis.py` - Update `build_concept_clusters()` to create weighted links",
        "- `cortical/persistence.py` - Handle new fields"
      ],
      "context_before": [
        "# ConceptNet-Enhanced PageRank",
        "",
        "The following tasks implement a ConceptNet-like enhanced PageRank algorithm that leverages semantic relations, cross-layer connections, and typed edge weights for improved concept importance scoring.",
        "",
        "---",
        "",
        "## ConceptNet Critical Priority",
        "",
        "### 19. Build Cross-Layer Feedforward Connections",
        ""
      ],
      "context_after": [
        "",
        "**Problem:**",
        "",
        "",
        "",
        "",
        "---",
        "",
        "### 20. Add Concept-Level Lateral Connections",
        "",
        "**Files:** `cortical/analysis.py`",
        "**Status:** [ ] Pending",
        "",
        "**Problem:**",
        "Layer 2 (Concepts) has 0 lateral connections. Concept clusters should connect to each other based on:"
      ],
      "change_type": "modify"
    },
    {
      "file": "TASK_LIST.md",
      "function": "complete_analogy(\"neural\", \"networks\", \"knowledge\")",
      "start_line": 863,
      "lines_added": [
        "| **Critical** | **Build cross-layer feedforward connections** | ✅ Completed | **ConceptNet** |",
        "**ConceptNet Enhancement Completion:** 1/12 tasks (8%)",
        "Ran 185 tests in 0.147s"
      ],
      "lines_removed": [
        "| **Critical** | **Build cross-layer feedforward connections** | ⏳ Pending | **ConceptNet** |",
        "**ConceptNet Enhancement Completion:** 0/12 tasks (0%)",
        "Ran 173 tests in 0.154s"
      ],
      "context_before": [
        "| **Critical** | **Add document metadata support** | ✅ Completed | **RAG** |",
        "| **High** | **Activate Layer 2 concepts** | ✅ Completed | **RAG** |",
        "| **High** | **Integrate semantic relations** | ✅ Completed | **RAG** |",
        "| **High** | **Persist full computed state** | ✅ Completed | **RAG** |",
        "| Medium | Fix type annotation (embeddings.py) | ✅ Completed | Bug Fix |",
        "| Medium | Optimize spectral embeddings | ✅ Completed | Performance |",
        "| Medium | Add incremental indexing | ✅ Completed | RAG |",
        "| Low | Document magic numbers | ⏳ Deferred | Documentation |",
        "| Low | Multi-stage ranking pipeline | ✅ Completed | RAG |",
        "| Low | Batch query API | ✅ Completed | RAG |"
      ],
      "context_after": [
        "| **Critical** | **Add concept-level lateral connections** | ⏳ Pending | **ConceptNet** |",
        "| **Critical** | **Add bigram lateral connections** | ⏳ Pending | **ConceptNet** |",
        "| **High** | **Implement relation-weighted PageRank** | ⏳ Pending | **ConceptNet** |",
        "| **High** | **Implement cross-layer PageRank propagation** | ⏳ Pending | **ConceptNet** |",
        "| **High** | **Add typed edge storage** | ⏳ Pending | **ConceptNet** |",
        "| Medium | Implement multi-hop semantic inference | ⏳ Pending | ConceptNet |",
        "| Medium | Add relation path scoring | ⏳ Pending | ConceptNet |",
        "| Medium | Implement concept inheritance | ⏳ Pending | ConceptNet |",
        "| Low | Add commonsense relation extraction | ⏳ Pending | ConceptNet |",
        "| Low | Visualize ConceptNet-style graph | ⏳ Pending | ConceptNet |",
        "| Low | Add analogy completion | ⏳ Pending | ConceptNet |",
        "",
        "**Bug Fix Completion:** 7/7 tasks (100%)",
        "**RAG Enhancement Completion:** 8/8 tasks (100%)",
        "",
        "---",
        "",
        "## Test Results",
        "",
        "```",
        "OK",
        "```",
        "",
        "All tests passing as of 2025-12-09.",
        "",
        "---",
        "",
        "*Updated from code review on 2025-12-09*"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/analysis.py",
      "function": "def build_concept_clusters(",
      "start_line": 305,
      "lines_added": [
        "        # Aggregate properties from members with weighted connections",
        "        max_pagerank = max(c.pagerank for c in member_cols) if member_cols else 1.0",
        "            # Weighted feedforward: concept → token (weight by normalized PageRank)",
        "            weight = col.pagerank / max_pagerank if max_pagerank > 0 else 1.0",
        "            concept.add_feedforward_connection(col.id, weight)",
        "            # Weighted feedback: token → concept (weight by normalized PageRank)",
        "            col.add_feedback_connection(concept.id, weight)",
        ""
      ],
      "lines_removed": [
        "        # Aggregate properties from members",
        "        "
      ],
      "context_before": [
        "        member_cols.sort(key=lambda c: c.pagerank, reverse=True)",
        "        ",
        "        # Name concept after top members",
        "        top_names = [c.content for c in member_cols[:3]]",
        "        concept_name = '/'.join(top_names)",
        "        ",
        "        # Create concept minicolumn",
        "        concept = layer2.get_or_create_minicolumn(concept_name)",
        "        concept.cluster_id = cluster_id",
        "        "
      ],
      "context_after": [
        "        for col in member_cols:",
        "            concept.feedforward_sources.add(col.id)",
        "            concept.document_ids.update(col.document_ids)",
        "            concept.activation += col.activation * 0.5",
        "            concept.occurrence_count += col.occurrence_count",
        "        # Set PageRank as average of members",
        "        concept.pagerank = sum(c.pagerank for c in member_cols) / len(member_cols)",
        "",
        "",
        "def compute_document_connections(",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    documents: Dict[str, str],",
        "    min_shared_terms: int = 3",
        ") -> None:",
        "    \"\"\""
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/minicolumn.py",
      "function": "class Minicolumn:",
      "start_line": 25,
      "lines_added": [
        "        feedforward_sources: IDs of columns that feed into this one (deprecated, use feedforward_connections)",
        "        feedforward_connections: Weighted connections to lower layer columns",
        "        feedback_connections: Weighted connections to higher layer columns",
        "        'feedforward_connections', 'feedback_connections',",
        "        self.feedforward_sources: Set[str] = set()  # Deprecated: use feedforward_connections",
        "        self.feedforward_connections: Dict[str, float] = {}  # Weighted links to lower layer",
        "        self.feedback_connections: Dict[str, float] = {}  # Weighted links to higher layer",
        "",
        "",
        "",
        "    def add_feedforward_connection(self, target_id: str, weight: float = 1.0) -> None:",
        "        \"\"\"",
        "        Add or strengthen a feedforward connection to a lower layer column.",
        "",
        "        Feedforward connections link higher-level representations to their",
        "        component parts (e.g., bigram → tokens, concept → tokens).",
        "",
        "        Args:",
        "            target_id: ID of the lower-layer minicolumn",
        "            weight: Connection strength to add",
        "        \"\"\"",
        "        self.feedforward_connections[target_id] = (",
        "            self.feedforward_connections.get(target_id, 0) + weight",
        "        )",
        "        # Also maintain legacy feedforward_sources for backward compatibility",
        "        self.feedforward_sources.add(target_id)",
        "",
        "    def add_feedback_connection(self, target_id: str, weight: float = 1.0) -> None:",
        "        \"\"\"",
        "        Add or strengthen a feedback connection to a higher layer column.",
        "",
        "        Feedback connections link lower-level representations to the",
        "        higher-level structures they participate in (e.g., token → bigrams).",
        "",
        "        Args:",
        "            target_id: ID of the higher-layer minicolumn",
        "            weight: Connection strength to add",
        "        \"\"\"",
        "        self.feedback_connections[target_id] = (",
        "            self.feedback_connections.get(target_id, 0) + weight",
        "        )"
      ],
      "lines_removed": [
        "        feedforward_sources: IDs of columns that feed into this one",
        "        self.feedforward_sources: Set[str] = set()",
        "        ",
        "        "
      ],
      "context_before": [
        "    - Layer 3: A document",
        "    ",
        "    Attributes:",
        "        id: Unique identifier (e.g., \"L0_neural\")",
        "        content: The actual content (word, bigram, doc_id)",
        "        layer: Which layer this column belongs to",
        "        activation: Current activation level (like neural firing rate)",
        "        occurrence_count: How many times this has been observed",
        "        document_ids: Which documents contain this content",
        "        lateral_connections: Connections to other columns at same layer"
      ],
      "context_after": [
        "        tfidf: TF-IDF weight for this term",
        "        tfidf_per_doc: Document-specific TF-IDF scores",
        "        pagerank: Importance score from PageRank algorithm",
        "        cluster_id: Which cluster this belongs to (for Layer 0)",
        "        doc_occurrence_counts: Per-document occurrence counts for accurate TF-IDF",
        "        ",
        "    Example:",
        "        col = Minicolumn(\"L0_neural\", \"neural\", 0)",
        "        col.occurrence_count = 15",
        "        col.add_lateral_connection(\"L0_network\", 0.8)",
        "    \"\"\"",
        "    ",
        "    __slots__ = [",
        "        'id', 'content', 'layer', 'activation', 'occurrence_count',",
        "        'document_ids', 'lateral_connections', 'feedforward_sources',",
        "        'tfidf', 'tfidf_per_doc', 'pagerank', 'cluster_id',",
        "        'doc_occurrence_counts'",
        "    ]",
        "    ",
        "    def __init__(self, id: str, content: str, layer: int):",
        "        \"\"\"",
        "        Initialize a minicolumn.",
        "        ",
        "        Args:",
        "            id: Unique identifier for this column",
        "            content: The content this column represents",
        "            layer: Layer number (0-3)",
        "        \"\"\"",
        "        self.id = id",
        "        self.content = content",
        "        self.layer = layer",
        "        self.activation = 0.0",
        "        self.occurrence_count = 0",
        "        self.document_ids: Set[str] = set()",
        "        self.lateral_connections: Dict[str, float] = {}",
        "        self.tfidf = 0.0",
        "        self.tfidf_per_doc: Dict[str, float] = {}",
        "        self.pagerank = 1.0",
        "        self.cluster_id: Optional[int] = None",
        "        self.doc_occurrence_counts: Dict[str, int] = {}",
        "    ",
        "    def add_lateral_connection(self, target_id: str, weight: float = 1.0) -> None:",
        "        \"\"\"",
        "        Add or strengthen a lateral connection to another column.",
        "        Lateral connections represent associations learned through",
        "        co-occurrence (like Hebbian learning: \"neurons that fire together",
        "        wire together\").",
        "        Args:",
        "            target_id: ID of the target minicolumn",
        "            weight: Connection strength to add",
        "        \"\"\"",
        "        self.lateral_connections[target_id] = (",
        "            self.lateral_connections.get(target_id, 0) + weight",
        "        )",
        "    ",
        "    def connection_count(self) -> int:",
        "        \"\"\"Return the number of lateral connections.\"\"\"",
        "        return len(self.lateral_connections)",
        "    ",
        "    def top_connections(self, n: int = 5) -> list:",
        "        \"\"\"",
        "        Get the strongest lateral connections.",
        "        ",
        "        Args:"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/minicolumn.py",
      "function": "class Minicolumn:",
      "start_line": 108,
      "lines_added": [
        "",
        "            'feedforward_connections': self.feedforward_connections,",
        "            'feedback_connections': self.feedback_connections,",
        "",
        "",
        "        col.feedforward_connections = data.get('feedforward_connections', {})",
        "        col.feedback_connections = data.get('feedback_connections', {})"
      ],
      "lines_removed": [
        "        ",
        "        ",
        "            "
      ],
      "context_before": [
        "        sorted_conns = sorted(",
        "            self.lateral_connections.items(),",
        "            key=lambda x: x[1],",
        "            reverse=True",
        "        )",
        "        return sorted_conns[:n]",
        "    ",
        "    def to_dict(self) -> Dict:",
        "        \"\"\"",
        "        Convert to dictionary for serialization."
      ],
      "context_after": [
        "        Returns:",
        "            Dictionary representation of this minicolumn",
        "        \"\"\"",
        "        return {",
        "            'id': self.id,",
        "            'content': self.content,",
        "            'layer': self.layer,",
        "            'activation': self.activation,",
        "            'occurrence_count': self.occurrence_count,",
        "            'document_ids': list(self.document_ids),",
        "            'lateral_connections': self.lateral_connections,",
        "            'feedforward_sources': list(self.feedforward_sources),",
        "            'tfidf': self.tfidf,",
        "            'tfidf_per_doc': self.tfidf_per_doc,",
        "            'pagerank': self.pagerank,",
        "            'cluster_id': self.cluster_id,",
        "            'doc_occurrence_counts': self.doc_occurrence_counts",
        "        }",
        "    ",
        "    @classmethod",
        "    def from_dict(cls, data: Dict) -> 'Minicolumn':",
        "        \"\"\"",
        "        Create a minicolumn from dictionary representation.",
        "        Args:",
        "            data: Dictionary with minicolumn data",
        "        Returns:",
        "            New Minicolumn instance",
        "        \"\"\"",
        "        col = cls(data['id'], data['content'], data['layer'])",
        "        col.activation = data.get('activation', 0.0)",
        "        col.occurrence_count = data.get('occurrence_count', 0)",
        "        col.document_ids = set(data.get('document_ids', []))",
        "        col.lateral_connections = data.get('lateral_connections', {})",
        "        col.feedforward_sources = set(data.get('feedforward_sources', []))",
        "        col.tfidf = data.get('tfidf', 0.0)",
        "        col.tfidf_per_doc = data.get('tfidf_per_doc', {})",
        "        col.pagerank = data.get('pagerank', 1.0)",
        "        col.cluster_id = data.get('cluster_id')",
        "        col.doc_occurrence_counts = data.get('doc_occurrence_counts', {})",
        "        return col",
        "    ",
        "    def __repr__(self) -> str:",
        "        return f\"Minicolumn(id={self.id}, content={self.content}, layer={self.layer})\""
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/processor.py",
      "function": "class CorticalTextProcessor:",
      "start_line": 78,
      "lines_added": [
        "            # Weighted feedforward: document → token (weight by occurrence count)",
        "            doc_col.add_feedforward_connection(col.id, 1.0)",
        "            # Weighted feedback: token → document (weight by occurrence count)",
        "            col.add_feedback_connection(doc_col.id, 1.0)",
        "                    # Weighted feedforward: bigram → tokens (weight 1.0 per occurrence)",
        "                    col.add_feedforward_connection(token_col.id, 1.0)",
        "                    # Weighted feedback: token → bigram (weight 1.0 per occurrence)",
        "                    token_col.add_feedback_connection(col.id, 1.0)"
      ],
      "lines_removed": [
        "            doc_col.feedforward_sources.add(col.id)",
        "                    col.feedforward_sources.add(token_col.id)"
      ],
      "context_before": [
        "        layer3 = self.layers[CorticalLayer.DOCUMENTS]",
        "        ",
        "        doc_col = layer3.get_or_create_minicolumn(doc_id)",
        "        doc_col.occurrence_count += 1",
        "        ",
        "        for token in tokens:",
        "            col = layer0.get_or_create_minicolumn(token)",
        "            col.occurrence_count += 1",
        "            col.document_ids.add(doc_id)",
        "            col.activation += 1.0"
      ],
      "context_after": [
        "            # Track per-document occurrence count for accurate TF-IDF",
        "            col.doc_occurrence_counts[doc_id] = col.doc_occurrence_counts.get(doc_id, 0) + 1",
        "        ",
        "        for i, token in enumerate(tokens):",
        "            col = layer0.get_minicolumn(token)",
        "            if col:",
        "                for j in range(max(0, i-3), min(len(tokens), i+4)):",
        "                    if i != j:",
        "                        other = layer0.get_minicolumn(tokens[j])",
        "                        if other:",
        "                            col.add_lateral_connection(other.id, 1.0)",
        "        ",
        "        for bigram in bigrams:",
        "            col = layer1.get_or_create_minicolumn(bigram)",
        "            col.occurrence_count += 1",
        "            col.document_ids.add(doc_id)",
        "            col.activation += 1.0",
        "            for part in bigram.split():",
        "                token_col = layer0.get_minicolumn(part)",
        "                if token_col:",
        "",
        "        # Mark all computations as stale since document corpus changed",
        "        self._mark_all_stale()",
        "",
        "        return {'tokens': len(tokens), 'bigrams': len(bigrams), 'unique_tokens': len(set(tokens))}",
        "",
        "    def set_document_metadata(self, doc_id: str, **kwargs) -> None:",
        "        \"\"\"",
        "        Set or update metadata for a document.",
        ""
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestProcessorIncrementalIndexing(unittest.TestCase):",
      "start_line": 816,
      "lines_added": [
        "class TestCrossLayerConnections(unittest.TestCase):",
        "    \"\"\"Test cross-layer feedforward and feedback connections.\"\"\"",
        "",
        "    def setUp(self):",
        "        self.processor = CorticalTextProcessor()",
        "        self.processor.process_document(\"doc1\", \"Neural networks process information efficiently.\")",
        "        self.processor.process_document(\"doc2\", \"Deep learning neural models are powerful.\")",
        "        self.processor.compute_all(verbose=False)",
        "",
        "    def test_bigram_feedforward_connections(self):",
        "        \"\"\"Test that bigrams have feedforward connections to component tokens.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        bigram = layer1.get_minicolumn(\"neural networks\")",
        "        self.assertIsNotNone(bigram)",
        "        self.assertGreater(len(bigram.feedforward_connections), 0)",
        "",
        "        # Should connect to both \"neural\" and \"networks\"",
        "        neural = layer0.get_minicolumn(\"neural\")",
        "        networks = layer0.get_minicolumn(\"networks\")",
        "        self.assertIn(neural.id, bigram.feedforward_connections)",
        "        self.assertIn(networks.id, bigram.feedforward_connections)",
        "",
        "    def test_bigram_feedforward_weights(self):",
        "        \"\"\"Test that bigram feedforward connections have accumulated weights.\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        bigram = layer1.get_minicolumn(\"neural networks\")",
        "        self.assertIsNotNone(bigram)",
        "",
        "        # Weight should be >= 1.0 (accumulated from occurrences)",
        "        for target_id, weight in bigram.feedforward_connections.items():",
        "            self.assertGreaterEqual(weight, 1.0)",
        "",
        "    def test_token_feedback_to_bigrams(self):",
        "        \"\"\"Test that tokens have feedback connections to bigrams.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        neural = layer0.get_minicolumn(\"neural\")",
        "        self.assertIsNotNone(neural)",
        "        self.assertGreater(len(neural.feedback_connections), 0)",
        "",
        "        # Should connect back to bigrams containing \"neural\"",
        "        bigram = layer1.get_minicolumn(\"neural networks\")",
        "        if bigram:",
        "            self.assertIn(bigram.id, neural.feedback_connections)",
        "",
        "    def test_document_feedforward_connections(self):",
        "        \"\"\"Test that documents have feedforward connections to tokens.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer3 = self.processor.get_layer(CorticalLayer.DOCUMENTS)",
        "",
        "        doc = layer3.get_minicolumn(\"doc1\")",
        "        self.assertIsNotNone(doc)",
        "        self.assertGreater(len(doc.feedforward_connections), 0)",
        "",
        "        # Document should connect to tokens in its content",
        "        neural = layer0.get_minicolumn(\"neural\")",
        "        self.assertIn(neural.id, doc.feedforward_connections)",
        "",
        "    def test_document_feedforward_weights(self):",
        "        \"\"\"Test that document feedforward weights reflect token frequency.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer3 = self.processor.get_layer(CorticalLayer.DOCUMENTS)",
        "",
        "        doc = layer3.get_minicolumn(\"doc1\")",
        "        neural = layer0.get_minicolumn(\"neural\")",
        "",
        "        # Weight should match occurrence count",
        "        weight = doc.feedforward_connections.get(neural.id, 0)",
        "        self.assertGreaterEqual(weight, 1.0)",
        "",
        "    def test_token_feedback_to_documents(self):",
        "        \"\"\"Test that tokens have feedback connections to documents.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer3 = self.processor.get_layer(CorticalLayer.DOCUMENTS)",
        "",
        "        neural = layer0.get_minicolumn(\"neural\")",
        "        self.assertIsNotNone(neural)",
        "",
        "        # Should connect to documents containing this token",
        "        doc1 = layer3.get_minicolumn(\"doc1\")",
        "        doc2 = layer3.get_minicolumn(\"doc2\")",
        "        self.assertIn(doc1.id, neural.feedback_connections)",
        "        self.assertIn(doc2.id, neural.feedback_connections)",
        "",
        "    def test_concept_feedforward_connections(self):",
        "        \"\"\"Test that concepts have feedforward connections to member tokens.\"\"\"",
        "        layer2 = self.processor.get_layer(CorticalLayer.CONCEPTS)",
        "",
        "        if layer2.column_count() > 0:",
        "            # Get first concept",
        "            concept = list(layer2.minicolumns.values())[0]",
        "            self.assertGreater(len(concept.feedforward_connections), 0)",
        "",
        "            # All feedforward targets should be in feedforward_sources too",
        "            for target_id in concept.feedforward_connections:",
        "                self.assertIn(target_id, concept.feedforward_sources)",
        "",
        "    def test_concept_feedforward_weights_by_pagerank(self):",
        "        \"\"\"Test that concept feedforward weights are based on token PageRank.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer2 = self.processor.get_layer(CorticalLayer.CONCEPTS)",
        "",
        "        if layer2.column_count() > 0:",
        "            concept = list(layer2.minicolumns.values())[0]",
        "",
        "            # Weights should be normalized (max = 1.0)",
        "            max_weight = max(concept.feedforward_connections.values())",
        "            self.assertLessEqual(max_weight, 1.0 + 0.001)  # Allow small float error",
        "",
        "    def test_token_feedback_to_concepts(self):",
        "        \"\"\"Test that tokens have feedback connections to concepts.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer2 = self.processor.get_layer(CorticalLayer.CONCEPTS)",
        "",
        "        if layer2.column_count() > 0:",
        "            concept = list(layer2.minicolumns.values())[0]",
        "",
        "            # Get a member token",
        "            if concept.feedforward_connections:",
        "                member_id = list(concept.feedforward_connections.keys())[0]",
        "                member = layer0.get_by_id(member_id)",
        "                if member:",
        "                    self.assertIn(concept.id, member.feedback_connections)",
        "",
        "    def test_cross_layer_bidirectional(self):",
        "        \"\"\"Test that cross-layer connections are bidirectional.\"\"\"",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        bigram = layer1.get_minicolumn(\"neural networks\")",
        "        if bigram:",
        "            for target_id in bigram.feedforward_connections:",
        "                token = layer0.get_by_id(target_id)",
        "                if token:",
        "                    self.assertIn(bigram.id, token.feedback_connections)",
        "",
        "    def test_persistence_cross_layer_connections(self):",
        "        \"\"\"Test that cross-layer connections are saved and loaded correctly.\"\"\"",
        "        import tempfile",
        "",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "        bigram = layer1.get_minicolumn(\"neural networks\")",
        "        original_ff = dict(bigram.feedforward_connections) if bigram else {}",
        "",
        "        with tempfile.NamedTemporaryFile(suffix='.pkl', delete=False) as f:",
        "            path = f.name",
        "",
        "        try:",
        "            self.processor.save(path)",
        "            loaded = CorticalTextProcessor.load(path)",
        "",
        "            loaded_layer1 = loaded.get_layer(CorticalLayer.BIGRAMS)",
        "            loaded_bigram = loaded_layer1.get_minicolumn(\"neural networks\")",
        "",
        "            if bigram and loaded_bigram:",
        "                self.assertEqual(",
        "                    loaded_bigram.feedforward_connections,",
        "                    original_ff",
        "                )",
        "        finally:",
        "            os.unlink(path)",
        "",
        "    def test_cross_layer_connection_count(self):",
        "        \"\"\"Test counting cross-layer connections.\"\"\"",
        "        layer1 = self.processor.get_layer(CorticalLayer.BIGRAMS)",
        "",
        "        total_ff = 0",
        "        for col in layer1.minicolumns.values():",
        "            total_ff += len(col.feedforward_connections)",
        "",
        "        # Each bigram should have 2 feedforward connections (to its 2 tokens)",
        "        # So total should be approximately 2 * number of bigrams",
        "        self.assertGreater(total_ff, 0)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "            (\"data\", \"Data processing storage retrieval.\", None),",
        "        ]",
        "        self.processor.add_documents_batch(docs, recompute='full', verbose=False)",
        "",
        "        results = self.processor.find_documents_for_query(\"neural networks\", top_n=3)",
        "        self.assertGreater(len(results), 0)",
        "        # The neural doc should rank highest",
        "        self.assertEqual(results[0][0], \"neural\")",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main(verbosity=2)"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 22,
  "day_of_week": "Tuesday",
  "seconds_since_last_commit": -486065,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}