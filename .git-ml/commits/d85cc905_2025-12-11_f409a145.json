{
  "hash": "d85cc9050a0dc015590b89b5d28840df2087d602",
  "message": "Fix definition boost to deprioritize test files over real implementations (Task #128)",
  "author": "Claude",
  "timestamp": "2025-12-11 22:46:03 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/query.py",
    "tests/test_query.py"
  ],
  "insertions": 235,
  "deletions": 5,
  "hunks": [
    {
      "file": "cortical/query.py",
      "function": "def apply_definition_boost(",
      "start_line": 619,
      "lines_added": [
        "def is_test_file(doc_id: str) -> bool:",
        "    \"\"\"",
        "    Detect if a document ID represents a test file.",
        "",
        "    Checks for common test file patterns:",
        "    - Path contains 'tests/' or 'test/'",
        "    - Filename starts with 'test_' or ends with '_test.py'",
        "    - Path contains 'mock' or 'fixture'",
        "",
        "    Args:",
        "        doc_id: Document identifier (typically a file path)",
        "",
        "    Returns:",
        "        True if the document appears to be a test file",
        "    \"\"\"",
        "    doc_lower = doc_id.lower()",
        "",
        "    # Check path components",
        "    if '/tests/' in doc_lower or '/test/' in doc_lower:",
        "        return True",
        "",
        "    # Check filename patterns",
        "    filename = doc_lower.split('/')[-1] if '/' in doc_lower else doc_lower",
        "    if filename.startswith('test_') or filename.endswith('_test.py'):",
        "        return True",
        "    if 'mock' in filename or 'fixture' in filename:",
        "        return True",
        "",
        "    return False",
        "",
        "",
        "    boost_factor: float = 2.0,",
        "    test_file_boost_factor: float = 0.5,",
        "    test_file_penalty: float = 0.7",
        "    For definition queries:",
        "    - Source files with the definition pattern get boost_factor (default 2.0x)",
        "    - Test files with the definition pattern get test_file_boost_factor (default 0.5x)",
        "    - All other test files get test_file_penalty (default 0.7x) to deprioritize them",
        "",
        "        boost_factor: Multiplier for definition-containing source docs (default 2.0)",
        "        test_file_boost_factor: Multiplier for test files with definition (default 0.5)",
        "        test_file_penalty: Multiplier for test files without definition (default 0.7)",
        "            Set to 1.0 to disable test file penalty.",
        "        has_definition = pattern.search(doc_text)",
        "        is_test = is_test_file(doc_id)",
        "",
        "        if has_definition:",
        "            if is_test:",
        "                # Test file with definition: apply reduced boost",
        "                boosted_docs.append((doc_id, score * test_file_boost_factor))",
        "            else:",
        "                # Source file with definition: apply full boost",
        "                boosted_docs.append((doc_id, score * boost_factor))",
        "        elif is_test:",
        "            # Test file without definition: apply penalty to deprioritize",
        "            boosted_docs.append((doc_id, score * test_file_penalty))",
        "            # Source file without definition: keep original score"
      ],
      "lines_removed": [
        "    boost_factor: float = 2.0",
        "        boost_factor: Multiplier for definition-containing docs (default 2.0)",
        "        if pattern.search(doc_text):",
        "            # This document contains the actual definition",
        "            boosted_docs.append((doc_id, score * boost_factor))"
      ],
      "context_before": [
        "            # This passage contains the actual definition",
        "            boosted_passages.append((text, doc_id, start, end, score * boost_factor))",
        "        else:",
        "            boosted_passages.append((text, doc_id, start, end, score))",
        "",
        "    # Re-sort by boosted scores",
        "    boosted_passages.sort(key=lambda x: x[4], reverse=True)",
        "    return boosted_passages",
        "",
        ""
      ],
      "context_after": [
        "def boost_definition_documents(",
        "    doc_results: List[Tuple[str, float]],",
        "    query_text: str,",
        "    documents: Dict[str, str],",
        ") -> List[Tuple[str, float]]:",
        "    \"\"\"",
        "    Boost documents that contain the actual definition being searched for.",
        "",
        "    This helps ensure the source file containing a class/function definition",
        "    is included in the document candidates, even if test files mention the",
        "    identifier more frequently.",
        "",
        "    Args:",
        "        doc_results: List of (doc_id, score) tuples",
        "        query_text: The original search query",
        "        documents: Dict mapping doc_id to document text",
        "",
        "    Returns:",
        "        Re-scored document results with definition boost applied",
        "    \"\"\"",
        "    definition_info = detect_definition_query(query_text)",
        "",
        "    if not definition_info['is_definition_query'] or not definition_info['pattern']:",
        "        return doc_results",
        "",
        "    pattern = re.compile(definition_info['pattern'], re.IGNORECASE)",
        "    boosted_docs = []",
        "",
        "    for doc_id, score in doc_results:",
        "        doc_text = documents.get(doc_id, '')",
        "        else:",
        "            boosted_docs.append((doc_id, score))",
        "",
        "    # Re-sort by boosted scores",
        "    boosted_docs.sort(key=lambda x: x[1], reverse=True)",
        "    return boosted_docs",
        "",
        "",
        "def parse_intent_query(query_text: str) -> ParsedIntent:",
        "    \"\"\"",
        "    Parse a natural language query to extract intent and searchable terms."
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_query.py",
      "function": "class TestQueryRelatedDocuments(unittest.TestCase):",
      "start_line": 1789,
      "lines_added": [
        "class TestIsTestFile(unittest.TestCase):",
        "    \"\"\"Test the is_test_file detection function.\"\"\"",
        "",
        "    def test_tests_directory(self):",
        "        \"\"\"Test detection of files in tests/ directory.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"tests/test_query.py\"))",
        "        self.assertTrue(is_test_file(\"project/tests/test_module.py\"))",
        "        self.assertTrue(is_test_file(\"/home/user/tests/helpers.py\"))",
        "",
        "    def test_test_directory(self):",
        "        \"\"\"Test detection of files in test/ directory.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"test/test_query.py\"))",
        "        self.assertTrue(is_test_file(\"project/test/conftest.py\"))",
        "",
        "    def test_test_prefix_filename(self):",
        "        \"\"\"Test detection of test_ prefixed files.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"test_module.py\"))",
        "        self.assertTrue(is_test_file(\"src/test_helpers.py\"))",
        "",
        "    def test_test_suffix_filename(self):",
        "        \"\"\"Test detection of _test.py suffixed files.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"module_test.py\"))",
        "        self.assertTrue(is_test_file(\"src/helpers_test.py\"))",
        "",
        "    def test_mock_files(self):",
        "        \"\"\"Test detection of mock files.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"mock_service.py\"))",
        "        self.assertTrue(is_test_file(\"mocks/mock_data.py\"))",
        "",
        "    def test_fixture_files(self):",
        "        \"\"\"Test detection of fixture files.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertTrue(is_test_file(\"fixtures.py\"))",
        "        self.assertTrue(is_test_file(\"test_fixtures.py\"))",
        "",
        "    def test_source_files_not_detected(self):",
        "        \"\"\"Test that source files are not detected as test files.\"\"\"",
        "        from cortical.query import is_test_file",
        "",
        "        self.assertFalse(is_test_file(\"cortical/query.py\"))",
        "        self.assertFalse(is_test_file(\"cortical/analysis.py\"))",
        "        self.assertFalse(is_test_file(\"src/module.py\"))",
        "        self.assertFalse(is_test_file(\"main.py\"))",
        "        self.assertFalse(is_test_file(\"scripts/run.py\"))",
        "",
        "",
        "class TestBoostDefinitionDocumentsTestFilePenalty(unittest.TestCase):",
        "    \"\"\"Test that definition boost correctly penalizes test files.\"\"\"",
        "",
        "    def test_source_file_boosted_over_test_file(self):",
        "        \"\"\"Test that source files are ranked higher than test files with same base score.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        # Simulate documents with the same base relevance score",
        "        doc_results = [",
        "            (\"tests/test_analysis.py\", 10.0),",
        "            (\"cortical/analysis.py\", 10.0),",
        "        ]",
        "",
        "        documents = {",
        "            \"tests/test_analysis.py\": \"def compute_pagerank(layers, damping=0.85): pass  # mock\",",
        "            \"cortical/analysis.py\": \"def compute_pagerank(layers, damping=0.85):\\n    '''Real implementation'''\\n    result = do_stuff()\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def compute_pagerank\",",
        "            documents,",
        "            boost_factor=2.0,",
        "            test_file_boost_factor=0.5",
        "        )",
        "",
        "        # Source file should be ranked first after boosting",
        "        self.assertEqual(boosted[0][0], \"cortical/analysis.py\")",
        "        # Source file gets 2.0x boost: 10.0 * 2.0 = 20.0",
        "        self.assertEqual(boosted[0][1], 20.0)",
        "        # Test file gets 0.5x penalty: 10.0 * 0.5 = 5.0",
        "        self.assertEqual(boosted[1][1], 5.0)",
        "",
        "    def test_test_file_penalty_can_be_disabled(self):",
        "        \"\"\"Test that test_file_boost_factor=1.0 disables the penalty.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        doc_results = [",
        "            (\"tests/test_module.py\", 10.0),",
        "            (\"src/module.py\", 10.0),",
        "        ]",
        "",
        "        documents = {",
        "            \"tests/test_module.py\": \"def my_func(): pass\",",
        "            \"src/module.py\": \"def my_func(): return 42\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def my_func\",",
        "            documents,",
        "            boost_factor=2.0,",
        "            test_file_boost_factor=1.0  # No penalty",
        "        )",
        "",
        "        # Both should get the same boost when penalty is disabled",
        "        scores = {doc_id: score for doc_id, score in boosted}",
        "        # Test file doesn't get full boost, it gets test_file_boost_factor (1.0 here means no change)",
        "        # Wait, if test_file_boost_factor=1.0, test file gets 10.0 * 1.0 = 10.0",
        "        # Source file gets 10.0 * 2.0 = 20.0",
        "        self.assertEqual(scores[\"src/module.py\"], 20.0)",
        "        self.assertEqual(scores[\"tests/test_module.py\"], 10.0)",
        "",
        "    def test_non_definition_query_unchanged(self):",
        "        \"\"\"Test that non-definition queries are not affected.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        doc_results = [",
        "            (\"tests/test_query.py\", 10.0),",
        "            (\"cortical/query.py\", 8.0),",
        "        ]",
        "",
        "        documents = {",
        "            \"tests/test_query.py\": \"testing query functionality\",",
        "            \"cortical/query.py\": \"query implementation code\",",
        "        }",
        "",
        "        # Non-definition query (no \"def\", \"class\", etc.)",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"query functionality\",",
        "            documents,",
        "            boost_factor=2.0",
        "        )",
        "",
        "        # Scores should be unchanged",
        "        self.assertEqual(boosted[0], (\"tests/test_query.py\", 10.0))",
        "        self.assertEqual(boosted[1], (\"cortical/query.py\", 8.0))",
        "",
        "    def test_test_files_without_definition_penalized(self):",
        "        \"\"\"Test that test files without the definition are penalized for definition queries.\"\"\"",
        "        from cortical.query import boost_definition_documents",
        "",
        "        # Test files that just mention the function but don't define it",
        "        doc_results = [",
        "            (\"tests/test_processor.py\", 100.0),  # High score, no definition",
        "            (\"cortical/analysis.py\", 80.0),       # Lower score, has definition",
        "        ]",
        "",
        "        documents = {",
        "            \"tests/test_processor.py\": \"from analysis import compute_pagerank; result = compute_pagerank()\",",
        "            \"cortical/analysis.py\": \"def compute_pagerank(layers, damping=0.85):\\n    return pagerank_impl()\",",
        "        }",
        "",
        "        boosted = boost_definition_documents(",
        "            doc_results,",
        "            \"def compute_pagerank\",",
        "            documents,",
        "            boost_factor=2.0,",
        "            test_file_boost_factor=0.5,",
        "            test_file_penalty=0.7",
        "        )",
        "",
        "        # Source file with definition should now rank first",
        "        # Source file gets 2.0x: 80.0 * 2.0 = 160.0",
        "        # Test file without definition gets 0.7x penalty: 100.0 * 0.7 = 70.0",
        "        self.assertEqual(boosted[0][0], \"cortical/analysis.py\")",
        "        self.assertEqual(boosted[0][1], 160.0)",
        "        self.assertEqual(boosted[1][1], 70.0)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "",
        "        related = find_related_documents(",
        "            \"doc1\",",
        "            self.processor.layers",
        "        )",
        "",
        "        # Should return a list",
        "        self.assertIsInstance(related, list)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 22,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -313125,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}