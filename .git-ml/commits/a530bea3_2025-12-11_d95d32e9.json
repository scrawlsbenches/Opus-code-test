{
  "hash": "a530bea352768c33631bcb933fbb737c21b1e0f9",
  "message": "Add CLI wrapper framework for context collection and task triggers",
  "author": "Claude",
  "timestamp": "2025-12-11 16:54:12 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/cli_wrapper.py",
    "scripts/cli_wrappers.py",
    "tests/test_cli_wrapper.py"
  ],
  "insertions": 1734,
  "deletions": 0,
  "hunks": [
    {
      "file": "cortical/cli_wrapper.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "\"\"\"",
        "CLI wrapper framework for collecting context and triggering actions.",
        "",
        "This module provides infrastructure for wrapping CLI tools to:",
        "- Collect execution metadata (timing, exit codes, output)",
        "- Gather context (git status, working directory, environment)",
        "- Trigger callbacks on task completion",
        "- Support context window management integration",
        "",
        "Architecture:",
        "    1. CLIWrapper - Base class for wrapping shell commands",
        "    2. ExecutionContext - Dataclass holding all execution metadata",
        "    3. HookRegistry - Register pre/post execution hooks",
        "    4. ContextCollector - Gather environment and git context",
        "",
        "Example usage:",
        "    # Basic wrapper with context collection",
        "    wrapper = CLIWrapper()",
        "    result = wrapper.run(['git', 'status'])",
        "    print(result.context.duration)",
        "    print(result.context.git_branch)",
        "",
        "    # With hooks for task completion",
        "    def on_test_complete(ctx: ExecutionContext):",
        "        if ctx.exit_code == 0:",
        "            print(\"Tests passed! Triggering re-index...\")",
        "",
        "    wrapper = CLIWrapper()",
        "    wrapper.hooks.register_post('pytest', on_test_complete)",
        "    wrapper.run(['pytest', 'tests/'])",
        "",
        "    # Task completion triggers",
        "    manager = TaskCompletionManager()",
        "    manager.on_task_complete('test', lambda ctx: reindex_if_needed(ctx))",
        "    manager.on_task_complete('commit', lambda ctx: update_context_window(ctx))",
        "\"\"\"",
        "",
        "import json",
        "import os",
        "import platform",
        "import subprocess",
        "import time",
        "import uuid",
        "from dataclasses import dataclass, field, asdict",
        "from datetime import datetime",
        "from enum import Enum",
        "from pathlib import Path",
        "from typing import (",
        "    Any, Callable, Dict, List, Optional, Tuple, Union, Protocol",
        ")",
        "",
        "",
        "# =============================================================================",
        "# Execution Context",
        "# =============================================================================",
        "",
        "@dataclass",
        "class GitContext:",
        "    \"\"\"Git repository context information.\"\"\"",
        "    is_repo: bool = False",
        "    branch: str = \"\"",
        "    commit_hash: str = \"\"",
        "    is_dirty: bool = False",
        "    staged_files: List[str] = field(default_factory=list)",
        "    modified_files: List[str] = field(default_factory=list)",
        "    untracked_files: List[str] = field(default_factory=list)",
        "",
        "    @classmethod",
        "    def collect(cls, cwd: Optional[str] = None) -> 'GitContext':",
        "        \"\"\"Collect git context from current directory.\"\"\"",
        "        ctx = cls()",
        "        try:",
        "            # Check if in git repo",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--is-inside-work-tree'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode != 0:",
        "                return ctx",
        "            ctx.is_repo = True",
        "",
        "            # Get branch",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode == 0:",
        "                ctx.branch = result.stdout.strip()",
        "",
        "            # Get commit hash",
        "            result = subprocess.run(",
        "                ['git', 'rev-parse', '--short', 'HEAD'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=5",
        "            )",
        "            if result.returncode == 0:",
        "                ctx.commit_hash = result.stdout.strip()",
        "",
        "            # Get status (porcelain for parsing)",
        "            result = subprocess.run(",
        "                ['git', 'status', '--porcelain'],",
        "                capture_output=True,",
        "                text=True,",
        "                cwd=cwd,",
        "                timeout=10",
        "            )",
        "            if result.returncode == 0:",
        "                for line in result.stdout.strip().split('\\n'):",
        "                    if not line:",
        "                        continue",
        "                    status = line[:2]",
        "                    filepath = line[3:]",
        "                    if status[0] in ('A', 'M', 'D', 'R'):",
        "                        ctx.staged_files.append(filepath)",
        "                    if status[1] in ('M', 'D'):",
        "                        ctx.modified_files.append(filepath)",
        "                    if status == '??':",
        "                        ctx.untracked_files.append(filepath)",
        "                ctx.is_dirty = bool(",
        "                    ctx.staged_files or ctx.modified_files or ctx.untracked_files",
        "                )",
        "",
        "        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):",
        "            pass",
        "",
        "        return ctx",
        "",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Convert to dictionary.\"\"\"",
        "        return asdict(self)",
        "",
        "",
        "@dataclass",
        "class ExecutionContext:",
        "    \"\"\"",
        "    Complete context for a CLI command execution.",
        "",
        "    Captures everything needed for:",
        "    - Logging and debugging",
        "    - Context window management decisions",
        "    - Task completion triggers",
        "    \"\"\"",
        "    # Execution metadata",
        "    command: List[str] = field(default_factory=list)",
        "    command_str: str = \"\"",
        "    exit_code: int = 0",
        "    start_time: float = 0.0",
        "    end_time: float = 0.0",
        "    duration: float = 0.0",
        "",
        "    # Output capture",
        "    stdout: str = \"\"",
        "    stderr: str = \"\"",
        "    output_lines: int = 0",
        "    error_lines: int = 0",
        "",
        "    # Environment context",
        "    working_directory: str = \"\"",
        "    session_id: str = \"\"",
        "    timestamp: str = \"\"",
        "    platform: str = \"\"",
        "    python_version: str = \"\"",
        "",
        "    # Git context",
        "    git: GitContext = field(default_factory=GitContext)",
        "",
        "    # Task classification",
        "    task_type: str = \"\"  # 'test', 'build', 'commit', 'search', etc.",
        "    success: bool = False",
        "",
        "    # Custom metadata from hooks",
        "    metadata: Dict[str, Any] = field(default_factory=dict)",
        "",
        "    def to_dict(self) -> Dict[str, Any]:",
        "        \"\"\"Convert to dictionary for serialization.\"\"\"",
        "        d = asdict(self)",
        "        d['git'] = self.git.to_dict()",
        "        return d",
        "",
        "    def to_json(self, indent: int = 2) -> str:",
        "        \"\"\"Convert to JSON string.\"\"\"",
        "        return json.dumps(self.to_dict(), indent=indent)",
        "",
        "    def summary(self) -> str:",
        "        \"\"\"Return a concise summary string.\"\"\"",
        "        status = \"âœ“\" if self.success else \"âœ—\"",
        "        return (",
        "            f\"{status} {self.command_str} \"",
        "            f\"[{self.duration:.2f}s, exit={self.exit_code}]\"",
        "        )",
        "",
        "",
        "# =============================================================================",
        "# Hook System",
        "# =============================================================================",
        "",
        "class HookType(Enum):",
        "    \"\"\"Types of hooks that can be registered.\"\"\"",
        "    PRE_EXEC = \"pre_exec\"       # Before command execution",
        "    POST_EXEC = \"post_exec\"     # After command execution (success or failure)",
        "    ON_SUCCESS = \"on_success\"   # Only on successful execution",
        "    ON_ERROR = \"on_error\"       # Only on failed execution",
        "    ON_TIMEOUT = \"on_timeout\"   # When command times out",
        "",
        "",
        "# Hook callback signature",
        "HookCallback = Callable[[ExecutionContext], None]",
        "",
        "",
        "class HookRegistry:",
        "    \"\"\"",
        "    Registry for CLI execution hooks.",
        "",
        "    Hooks can be registered globally or for specific command patterns.",
        "    \"\"\"",
        "",
        "    def __init__(self):",
        "        # Global hooks (apply to all commands)",
        "        self._global_hooks: Dict[HookType, List[HookCallback]] = {",
        "            hook_type: [] for hook_type in HookType",
        "        }",
        "        # Pattern-specific hooks (command prefix matching)",
        "        self._pattern_hooks: Dict[str, Dict[HookType, List[HookCallback]]] = {}",
        "",
        "    def register(",
        "        self,",
        "        hook_type: HookType,",
        "        callback: HookCallback,",
        "        pattern: Optional[str] = None",
        "    ) -> None:",
        "        \"\"\"",
        "        Register a hook callback.",
        "",
        "        Args:",
        "            hook_type: When to trigger the hook",
        "            callback: Function to call with ExecutionContext",
        "            pattern: Optional command pattern (e.g., 'git', 'pytest')",
        "                    If None, applies to all commands",
        "        \"\"\"",
        "        if pattern is None:",
        "            self._global_hooks[hook_type].append(callback)",
        "        else:",
        "            if pattern not in self._pattern_hooks:",
        "                self._pattern_hooks[pattern] = {",
        "                    hook_type: [] for hook_type in HookType",
        "                }",
        "            self._pattern_hooks[pattern][hook_type].append(callback)",
        "",
        "    def register_pre(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for pre-execution hooks.\"\"\"",
        "        self.register(HookType.PRE_EXEC, callback, pattern)",
        "",
        "    def register_post(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for post-execution hooks.\"\"\"",
        "        self.register(HookType.POST_EXEC, callback, pattern)",
        "",
        "    def register_success(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for success hooks.\"\"\"",
        "        self.register(HookType.ON_SUCCESS, callback, pattern)",
        "",
        "    def register_error(",
        "        self,",
        "        pattern: Optional[str],",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"Convenience method for error hooks.\"\"\"",
        "        self.register(HookType.ON_ERROR, callback, pattern)",
        "",
        "    def get_hooks(",
        "        self,",
        "        hook_type: HookType,",
        "        command: List[str]",
        "    ) -> List[HookCallback]:",
        "        \"\"\"",
        "        Get all hooks that should be triggered for a command.",
        "",
        "        Args:",
        "            hook_type: Type of hook",
        "            command: Command being executed",
        "",
        "        Returns:",
        "            List of callbacks to execute",
        "        \"\"\"",
        "        callbacks = list(self._global_hooks[hook_type])",
        "",
        "        # Match patterns against command",
        "        if command:",
        "            cmd_str = ' '.join(command)",
        "            for pattern, hooks in self._pattern_hooks.items():",
        "                if cmd_str.startswith(pattern) or command[0] == pattern:",
        "                    callbacks.extend(hooks[hook_type])",
        "",
        "        return callbacks",
        "",
        "    def trigger(",
        "        self,",
        "        hook_type: HookType,",
        "        context: ExecutionContext",
        "    ) -> None:",
        "        \"\"\"Trigger all matching hooks.\"\"\"",
        "        for callback in self.get_hooks(hook_type, context.command):",
        "            try:",
        "                callback(context)",
        "            except Exception as e:",
        "                # Log but don't fail on hook errors",
        "                context.metadata.setdefault('hook_errors', []).append(",
        "                    f\"{hook_type.value}: {str(e)}\"",
        "                )",
        "",
        "",
        "# =============================================================================",
        "# CLI Wrapper",
        "# =============================================================================",
        "",
        "class CLIWrapper:",
        "    \"\"\"",
        "    Wrapper for CLI command execution with context collection and hooks.",
        "",
        "    Features:",
        "    - Automatic context collection (timing, git status, environment)",
        "    - Pre/post execution hooks",
        "    - Task type classification",
        "    - Timeout handling",
        "    - Output capture",
        "    \"\"\"",
        "",
        "    # Command patterns for task type classification",
        "    TASK_PATTERNS = {",
        "        'test': ['pytest', 'python -m pytest', 'python -m unittest', 'npm test'],",
        "        'build': ['python -m build', 'npm run build', 'make', 'cargo build'],",
        "        'commit': ['git commit', 'git add', 'git push'],",
        "        'search': ['grep', 'rg', 'find', 'ag'],",
        "        'install': ['pip install', 'npm install', 'cargo install'],",
        "        'lint': ['flake8', 'pylint', 'mypy', 'eslint', 'ruff'],",
        "        'format': ['black', 'prettier', 'rustfmt'],",
        "    }",
        "",
        "    def __init__(",
        "        self,",
        "        collect_git_context: bool = True,",
        "        capture_output: bool = True,",
        "        default_timeout: Optional[float] = None",
        "    ):",
        "        \"\"\"",
        "        Initialize CLI wrapper.",
        "",
        "        Args:",
        "            collect_git_context: Whether to collect git info before execution",
        "            capture_output: Whether to capture stdout/stderr",
        "            default_timeout: Default timeout in seconds (None = no timeout)",
        "        \"\"\"",
        "        self.hooks = HookRegistry()",
        "        self.collect_git_context = collect_git_context",
        "        self.capture_output = capture_output",
        "        self.default_timeout = default_timeout",
        "        self.session_id = uuid.uuid4().hex[:16]",
        "",
        "    def _classify_task(self, command: List[str]) -> str:",
        "        \"\"\"Classify command into a task type.\"\"\"",
        "        if not command:",
        "            return 'unknown'",
        "",
        "        cmd_str = ' '.join(command)",
        "        for task_type, patterns in self.TASK_PATTERNS.items():",
        "            for pattern in patterns:",
        "                if cmd_str.startswith(pattern) or command[0] == pattern.split()[0]:",
        "                    return task_type",
        "",
        "        return 'other'",
        "",
        "    def _build_context(",
        "        self,",
        "        command: List[str],",
        "        cwd: Optional[str] = None",
        "    ) -> ExecutionContext:",
        "        \"\"\"Build initial execution context.\"\"\"",
        "        cwd = cwd or os.getcwd()",
        "",
        "        ctx = ExecutionContext(",
        "            command=command,",
        "            command_str=' '.join(command),",
        "            working_directory=cwd,",
        "            session_id=self.session_id,",
        "            timestamp=datetime.now().isoformat(timespec='seconds'),",
        "            platform=platform.system(),",
        "            python_version=platform.python_version(),",
        "            task_type=self._classify_task(command),",
        "        )",
        "",
        "        if self.collect_git_context:",
        "            ctx.git = GitContext.collect(cwd)",
        "",
        "        return ctx",
        "",
        "    def run(",
        "        self,",
        "        command: Union[str, List[str]],",
        "        cwd: Optional[str] = None,",
        "        timeout: Optional[float] = None,",
        "        env: Optional[Dict[str, str]] = None,",
        "        **kwargs",
        "    ) -> ExecutionContext:",
        "        \"\"\"",
        "        Execute a command with context collection and hooks.",
        "",
        "        Args:",
        "            command: Command to execute (string or list)",
        "            cwd: Working directory",
        "            timeout: Timeout in seconds (overrides default)",
        "            env: Environment variables (merged with current env)",
        "            **kwargs: Additional args passed to subprocess.run",
        "",
        "        Returns:",
        "            ExecutionContext with all collected metadata",
        "        \"\"\"",
        "        # Normalize command",
        "        if isinstance(command, str):",
        "            command = command.split()",
        "",
        "        # Build initial context",
        "        ctx = self._build_context(command, cwd)",
        "        ctx.start_time = time.time()",
        "",
        "        # Merge environment",
        "        run_env = os.environ.copy()",
        "        if env:",
        "            run_env.update(env)",
        "",
        "        # Trigger pre-execution hooks",
        "        self.hooks.trigger(HookType.PRE_EXEC, ctx)",
        "",
        "        # Execute command",
        "        effective_timeout = timeout if timeout is not None else self.default_timeout",
        "",
        "        try:",
        "            result = subprocess.run(",
        "                command,",
        "                capture_output=self.capture_output,",
        "                text=True,",
        "                cwd=cwd,",
        "                env=run_env,",
        "                timeout=effective_timeout,",
        "                **kwargs",
        "            )",
        "",
        "            ctx.exit_code = result.returncode",
        "            ctx.success = result.returncode == 0",
        "",
        "            if self.capture_output:",
        "                ctx.stdout = result.stdout or \"\"",
        "                ctx.stderr = result.stderr or \"\"",
        "                ctx.output_lines = len(ctx.stdout.splitlines())",
        "                ctx.error_lines = len(ctx.stderr.splitlines())",
        "",
        "        except subprocess.TimeoutExpired as e:",
        "            ctx.exit_code = -1",
        "            ctx.success = False",
        "            ctx.metadata['timeout'] = effective_timeout",
        "            ctx.metadata['timeout_error'] = str(e)",
        "            if e.stdout:",
        "                ctx.stdout = e.stdout.decode() if isinstance(e.stdout, bytes) else e.stdout",
        "            if e.stderr:",
        "                ctx.stderr = e.stderr.decode() if isinstance(e.stderr, bytes) else e.stderr",
        "            self.hooks.trigger(HookType.ON_TIMEOUT, ctx)",
        "",
        "        except FileNotFoundError:",
        "            ctx.exit_code = 127",
        "            ctx.success = False",
        "            ctx.metadata['error'] = f\"Command not found: {command[0]}\"",
        "",
        "        except Exception as e:",
        "            ctx.exit_code = -1",
        "            ctx.success = False",
        "            ctx.metadata['error'] = str(e)",
        "",
        "        # Finalize timing",
        "        ctx.end_time = time.time()",
        "        ctx.duration = ctx.end_time - ctx.start_time",
        "",
        "        # Trigger post-execution hooks",
        "        self.hooks.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        # Trigger success/error hooks",
        "        if ctx.success:",
        "            self.hooks.trigger(HookType.ON_SUCCESS, ctx)",
        "        else:",
        "            self.hooks.trigger(HookType.ON_ERROR, ctx)",
        "",
        "        return ctx",
        "",
        "",
        "# =============================================================================",
        "# Task Completion Manager",
        "# =============================================================================",
        "",
        "class TaskCompletionManager:",
        "    \"\"\"",
        "    Manager for task completion triggers and context window management.",
        "",
        "    Provides high-level task completion callbacks that can:",
        "    - Trigger corpus re-indexing after code changes",
        "    - Update context window summaries",
        "    - Log task completions for session analysis",
        "    - Chain multiple actions on task completion",
        "    \"\"\"",
        "",
        "    def __init__(self):",
        "        self._task_handlers: Dict[str, List[HookCallback]] = {}",
        "        self._completion_log: List[ExecutionContext] = []",
        "        self._completion_callbacks: List[HookCallback] = []",
        "",
        "    def on_task_complete(",
        "        self,",
        "        task_type: str,",
        "        callback: HookCallback",
        "    ) -> None:",
        "        \"\"\"",
        "        Register a callback for when a specific task type completes.",
        "",
        "        Args:",
        "            task_type: Task type to match ('test', 'commit', 'build', etc.)",
        "            callback: Function called with ExecutionContext on completion",
        "        \"\"\"",
        "        if task_type not in self._task_handlers:",
        "            self._task_handlers[task_type] = []",
        "        self._task_handlers[task_type].append(callback)",
        "",
        "    def on_any_complete(self, callback: HookCallback) -> None:",
        "        \"\"\"Register a callback for any task completion.\"\"\"",
        "        self._completion_callbacks.append(callback)",
        "",
        "    def handle_completion(self, context: ExecutionContext) -> None:",
        "        \"\"\"",
        "        Handle task completion and trigger appropriate callbacks.",
        "",
        "        Should be called from CLIWrapper post-execution hook.",
        "        \"\"\"",
        "        # Log completion",
        "        self._completion_log.append(context)",
        "",
        "        # Trigger task-specific handlers",
        "        if context.task_type in self._task_handlers:",
        "            for callback in self._task_handlers[context.task_type]:",
        "                try:",
        "                    callback(context)",
        "                except Exception as e:",
        "                    context.metadata.setdefault('completion_errors', []).append(str(e))",
        "",
        "        # Trigger global completion callbacks",
        "        for callback in self._completion_callbacks:",
        "            try:",
        "                callback(context)",
        "            except Exception as e:",
        "                context.metadata.setdefault('completion_errors', []).append(str(e))",
        "",
        "    def get_session_summary(self) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Get summary of all tasks completed in this session.",
        "",
        "        Useful for context window management decisions.",
        "        \"\"\"",
        "        if not self._completion_log:",
        "            return {",
        "                'task_count': 0,",
        "                'success_rate': 0.0,",
        "                'total_duration': 0.0,",
        "                'tasks_by_type': {},",
        "                'files_modified': [],",
        "            }",
        "",
        "        tasks_by_type: Dict[str, Dict[str, Any]] = {}",
        "        all_modified_files: List[str] = []",
        "",
        "        for ctx in self._completion_log:",
        "            task_type = ctx.task_type or 'unknown'",
        "            if task_type not in tasks_by_type:",
        "                tasks_by_type[task_type] = {",
        "                    'count': 0,",
        "                    'successes': 0,",
        "                    'failures': 0,",
        "                    'total_duration': 0.0,",
        "                }",
        "",
        "            tasks_by_type[task_type]['count'] += 1",
        "            tasks_by_type[task_type]['total_duration'] += ctx.duration",
        "            if ctx.success:",
        "                tasks_by_type[task_type]['successes'] += 1",
        "            else:",
        "                tasks_by_type[task_type]['failures'] += 1",
        "",
        "            # Collect modified files from git context",
        "            all_modified_files.extend(ctx.git.modified_files)",
        "            all_modified_files.extend(ctx.git.staged_files)",
        "",
        "        total_tasks = len(self._completion_log)",
        "        successes = sum(1 for ctx in self._completion_log if ctx.success)",
        "",
        "        return {",
        "            'task_count': total_tasks,",
        "            'success_rate': successes / total_tasks if total_tasks > 0 else 0.0,",
        "            'total_duration': sum(ctx.duration for ctx in self._completion_log),",
        "            'tasks_by_type': tasks_by_type,",
        "            'files_modified': list(set(all_modified_files)),",
        "        }",
        "",
        "    def should_trigger_reindex(self) -> bool:",
        "        \"\"\"",
        "        Determine if corpus should be re-indexed based on session activity.",
        "",
        "        Returns True if:",
        "        - Code files were modified",
        "        - Tests were run (may indicate code changes)",
        "        - Git commits were made",
        "        \"\"\"",
        "        summary = self.get_session_summary()",
        "",
        "        # Check if relevant files were modified",
        "        code_extensions = {'.py', '.js', '.ts', '.md', '.rst'}",
        "        for filepath in summary['files_modified']:",
        "            if any(filepath.endswith(ext) for ext in code_extensions):",
        "                return True",
        "",
        "        # Check if commits were made",
        "        tasks_by_type = summary.get('tasks_by_type', {})",
        "        if 'commit' in tasks_by_type and tasks_by_type['commit']['successes'] > 0:",
        "            return True",
        "",
        "        return False",
        "",
        "",
        "# =============================================================================",
        "# Context Window Integration",
        "# =============================================================================",
        "",
        "class ContextWindowManager:",
        "    \"\"\"",
        "    Manages context window state based on CLI execution history.",
        "",
        "    Tracks what information is \"in context\" and provides utilities for:",
        "    - Summarizing recent activity",
        "    - Identifying relevant files for the current task",
        "    - Suggesting context pruning",
        "    \"\"\"",
        "",
        "    def __init__(self, max_context_items: int = 50):",
        "        self.max_context_items = max_context_items",
        "        self._context_items: List[Dict[str, Any]] = []",
        "        self._file_access_log: Dict[str, float] = {}  # filepath -> last access time",
        "",
        "    def add_execution(self, context: ExecutionContext) -> None:",
        "        \"\"\"Add an execution to the context window.\"\"\"",
        "        item = {",
        "            'type': 'execution',",
        "            'task_type': context.task_type,",
        "            'command': context.command_str,",
        "            'success': context.success,",
        "            'duration': context.duration,",
        "            'timestamp': context.timestamp,",
        "            'files': context.git.modified_files + context.git.staged_files,",
        "        }",
        "        self._context_items.append(item)",
        "",
        "        # Track file access",
        "        now = time.time()",
        "        for filepath in item['files']:",
        "            self._file_access_log[filepath] = now",
        "",
        "        # Prune if needed",
        "        if len(self._context_items) > self.max_context_items:",
        "            self._context_items = self._context_items[-self.max_context_items:]",
        "",
        "    def add_file_read(self, filepath: str) -> None:",
        "        \"\"\"Track that a file was read.\"\"\"",
        "        self._file_access_log[filepath] = time.time()",
        "        self._context_items.append({",
        "            'type': 'file_read',",
        "            'filepath': filepath,",
        "            'timestamp': datetime.now().isoformat(timespec='seconds'),",
        "        })",
        "",
        "    def get_recent_files(self, limit: int = 10) -> List[str]:",
        "        \"\"\"Get most recently accessed files.\"\"\"",
        "        sorted_files = sorted(",
        "            self._file_access_log.items(),",
        "            key=lambda x: x[1],",
        "            reverse=True",
        "        )",
        "        return [f for f, _ in sorted_files[:limit]]",
        "",
        "    def get_context_summary(self) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Get a summary of current context window state.",
        "",
        "        Useful for context window management decisions.",
        "        \"\"\"",
        "        executions = [i for i in self._context_items if i['type'] == 'execution']",
        "        file_reads = [i for i in self._context_items if i['type'] == 'file_read']",
        "",
        "        task_types = {}",
        "        for ex in executions:",
        "            task_type = ex.get('task_type', 'unknown')",
        "            task_types[task_type] = task_types.get(task_type, 0) + 1",
        "",
        "        return {",
        "            'total_items': len(self._context_items),",
        "            'executions': len(executions),",
        "            'file_reads': len(file_reads),",
        "            'task_types': task_types,",
        "            'recent_files': self.get_recent_files(5),",
        "            'unique_files_accessed': len(self._file_access_log),",
        "        }",
        "",
        "    def suggest_pruning(self) -> List[str]:",
        "        \"\"\"",
        "        Suggest files that could be pruned from context.",
        "",
        "        Returns files that:",
        "        - Haven't been accessed recently",
        "        - Aren't related to recent task types",
        "        \"\"\"",
        "        if len(self._file_access_log) < self.max_context_items // 2:",
        "            return []",
        "",
        "        now = time.time()",
        "        stale_threshold = 300  # 5 minutes",
        "",
        "        stale_files = [",
        "            filepath",
        "            for filepath, last_access in self._file_access_log.items()",
        "            if now - last_access > stale_threshold",
        "        ]",
        "",
        "        return stale_files[:10]  # Suggest up to 10 files",
        "",
        "",
        "# =============================================================================",
        "# Convenience Functions",
        "# =============================================================================",
        "",
        "def create_wrapper_with_completion_manager() -> Tuple[CLIWrapper, TaskCompletionManager]:",
        "    \"\"\"",
        "    Create a CLIWrapper with an attached TaskCompletionManager.",
        "",
        "    Returns:",
        "        Tuple of (wrapper, completion_manager) configured together",
        "    \"\"\"",
        "    wrapper = CLIWrapper()",
        "    manager = TaskCompletionManager()",
        "",
        "    # Connect wrapper to completion manager",
        "    wrapper.hooks.register_post(None, manager.handle_completion)",
        "",
        "    return wrapper, manager",
        "",
        "",
        "def run_with_context(",
        "    command: Union[str, List[str]],",
        "    **kwargs",
        ") -> ExecutionContext:",
        "    \"\"\"",
        "    Convenience function to run a command with full context collection.",
        "",
        "    Args:",
        "        command: Command to execute",
        "        **kwargs: Additional arguments for CLIWrapper.run()",
        "",
        "    Returns:",
        "        ExecutionContext with all metadata",
        "    \"\"\"",
        "    wrapper = CLIWrapper()",
        "    return wrapper.run(command, **kwargs)"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "scripts/cli_wrappers.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "#!/usr/bin/env python3",
        "\"\"\"",
        "Example CLI wrappers for common development tasks.",
        "",
        "These wrappers collect context and trigger actions automatically:",
        "- git_wrapper: Track commits, trigger re-indexing",
        "- test_wrapper: Run tests, log results",
        "- dev_wrapper: General development command wrapper",
        "",
        "Usage:",
        "    # As a module",
        "    from scripts.cli_wrappers import git_wrapper, test_wrapper",
        "",
        "    result = git_wrapper.run(['git', 'status'])",
        "    result = test_wrapper.run(['pytest', 'tests/', '-v'])",
        "",
        "    # As CLI",
        "    python scripts/cli_wrappers.py git status",
        "    python scripts/cli_wrappers.py test pytest tests/ -v",
        "    python scripts/cli_wrappers.py run echo hello",
        "\"\"\"",
        "",
        "import argparse",
        "import json",
        "import os",
        "import sys",
        "from datetime import datetime",
        "from pathlib import Path",
        "from typing import List, Optional",
        "",
        "# Add parent directory for imports",
        "sys.path.insert(0, str(Path(__file__).parent.parent))",
        "",
        "from cortical.cli_wrapper import (",
        "    CLIWrapper,",
        "    ExecutionContext,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    HookType,",
        "    create_wrapper_with_completion_manager,",
        ")",
        "",
        "",
        "# =============================================================================",
        "# Context-Aware Wrapper Configuration",
        "# =============================================================================",
        "",
        "class DevWrapper:",
        "    \"\"\"",
        "    Development-focused CLI wrapper with smart defaults.",
        "",
        "    Features:",
        "    - Automatic re-index triggering after code changes",
        "    - Test result logging",
        "    - Session activity tracking",
        "    - Context window management hints",
        "    \"\"\"",
        "",
        "    def __init__(",
        "        self,",
        "        log_dir: Optional[str] = None,",
        "        auto_reindex: bool = True,",
        "        verbose: bool = False",
        "    ):",
        "        self.wrapper, self.completion_manager = create_wrapper_with_completion_manager()",
        "        self.context_manager = ContextWindowManager()",
        "        self.verbose = verbose",
        "        self.auto_reindex = auto_reindex",
        "",
        "        # Set up logging directory",
        "        if log_dir:",
        "            self.log_dir = Path(log_dir)",
        "            self.log_dir.mkdir(parents=True, exist_ok=True)",
        "        else:",
        "            self.log_dir = Path('.cli_wrapper_logs')",
        "            self.log_dir.mkdir(exist_ok=True)",
        "",
        "        # Register hooks",
        "        self._register_hooks()",
        "",
        "    def _register_hooks(self):",
        "        \"\"\"Set up default hooks for development workflow.\"\"\"",
        "",
        "        # Pre-execution: log command start",
        "        def log_start(ctx: ExecutionContext):",
        "            if self.verbose:",
        "                print(f\"â†’ {ctx.command_str}\")",
        "",
        "        self.wrapper.hooks.register_pre(None, log_start)",
        "",
        "        # Post-execution: track in context window",
        "        def track_context(ctx: ExecutionContext):",
        "            self.context_manager.add_execution(ctx)",
        "",
        "        self.wrapper.hooks.register_post(None, track_context)",
        "",
        "        # Git commit success: suggest re-indexing",
        "        def on_commit_success(ctx: ExecutionContext):",
        "            if self.auto_reindex and ctx.task_type == 'commit' and ctx.success:",
        "                print(\"\\nðŸ’¡ Code committed. Consider re-indexing:\")",
        "                print(\"   python scripts/index_codebase.py --incremental\")",
        "",
        "        self.wrapper.hooks.register_success('git commit', on_commit_success)",
        "",
        "        # Test completion: log results",
        "        def on_test_complete(ctx: ExecutionContext):",
        "            if ctx.task_type == 'test':",
        "                status = \"âœ“ PASS\" if ctx.success else \"âœ— FAIL\"",
        "                print(f\"\\n{status} ({ctx.duration:.2f}s)\")",
        "",
        "                # Log detailed results",
        "                self._log_test_result(ctx)",
        "",
        "        self.wrapper.hooks.register_post('pytest', on_test_complete)",
        "        self.wrapper.hooks.register_post('python -m unittest', on_test_complete)",
        "        self.wrapper.hooks.register_post('python -m pytest', on_test_complete)",
        "",
        "    def _log_test_result(self, ctx: ExecutionContext):",
        "        \"\"\"Log test results to file.\"\"\"",
        "        log_file = self.log_dir / 'test_results.jsonl'",
        "",
        "        entry = {",
        "            'timestamp': ctx.timestamp,",
        "            'command': ctx.command_str,",
        "            'success': ctx.success,",
        "            'duration': ctx.duration,",
        "            'exit_code': ctx.exit_code,",
        "            'output_lines': ctx.output_lines,",
        "            'error_lines': ctx.error_lines,",
        "            'git_branch': ctx.git.branch,",
        "            'git_commit': ctx.git.commit_hash,",
        "        }",
        "",
        "        with open(log_file, 'a') as f:",
        "            f.write(json.dumps(entry) + '\\n')",
        "",
        "    def run(self, command: List[str], **kwargs) -> ExecutionContext:",
        "        \"\"\"Execute a command with full context collection.\"\"\"",
        "        return self.wrapper.run(command, **kwargs)",
        "",
        "    def get_session_summary(self) -> dict:",
        "        \"\"\"Get summary of session activity.\"\"\"",
        "        return self.completion_manager.get_session_summary()",
        "",
        "    def get_context_summary(self) -> dict:",
        "        \"\"\"Get context window state summary.\"\"\"",
        "        return self.context_manager.get_context_summary()",
        "",
        "    def should_reindex(self) -> bool:",
        "        \"\"\"Check if re-indexing is recommended.\"\"\"",
        "        return self.completion_manager.should_trigger_reindex()",
        "",
        "",
        "# =============================================================================",
        "# Specialized Wrappers",
        "# =============================================================================",
        "",
        "class GitWrapper(DevWrapper):",
        "    \"\"\"Git-specific wrapper with additional context collection.\"\"\"",
        "",
        "    def __init__(self, **kwargs):",
        "        super().__init__(**kwargs)",
        "",
        "        # Track files changed per commit",
        "        def track_commit_files(ctx: ExecutionContext):",
        "            if 'commit' in ctx.command_str and ctx.success:",
        "                ctx.metadata['committed_files'] = ctx.git.staged_files.copy()",
        "",
        "        self.wrapper.hooks.register_success('git commit', track_commit_files)",
        "",
        "    def status(self) -> ExecutionContext:",
        "        \"\"\"Run git status.\"\"\"",
        "        return self.run(['git', 'status'])",
        "",
        "    def diff(self, staged: bool = False) -> ExecutionContext:",
        "        \"\"\"Run git diff.\"\"\"",
        "        cmd = ['git', 'diff']",
        "        if staged:",
        "            cmd.append('--staged')",
        "        return self.run(cmd)",
        "",
        "    def log(self, count: int = 5) -> ExecutionContext:",
        "        \"\"\"Run git log.\"\"\"",
        "        return self.run(['git', 'log', f'-{count}', '--oneline'])",
        "",
        "    def add(self, *paths: str) -> ExecutionContext:",
        "        \"\"\"Run git add.\"\"\"",
        "        return self.run(['git', 'add'] + list(paths))",
        "",
        "    def commit(self, message: str) -> ExecutionContext:",
        "        \"\"\"Run git commit.\"\"\"",
        "        return self.run(['git', 'commit', '-m', message])",
        "",
        "",
        "class TestWrapper(DevWrapper):",
        "    \"\"\"Test runner wrapper with result tracking.\"\"\"",
        "",
        "    def __init__(self, **kwargs):",
        "        super().__init__(**kwargs)",
        "        self.test_history: List[ExecutionContext] = []",
        "",
        "        # Track test results",
        "        def track_test(ctx: ExecutionContext):",
        "            if ctx.task_type == 'test':",
        "                self.test_history.append(ctx)",
        "",
        "        self.wrapper.hooks.register_post(None, track_test)",
        "",
        "    def pytest(self, *args: str, **kwargs) -> ExecutionContext:",
        "        \"\"\"Run pytest with given arguments.\"\"\"",
        "        cmd = ['pytest'] + list(args)",
        "        return self.run(cmd, **kwargs)",
        "",
        "    def unittest(self, pattern: str = 'tests/', **kwargs) -> ExecutionContext:",
        "        \"\"\"Run unittest discover.\"\"\"",
        "        cmd = ['python', '-m', 'unittest', 'discover', '-s', pattern, '-v']",
        "        return self.run(cmd, **kwargs)",
        "",
        "    def get_test_summary(self) -> dict:",
        "        \"\"\"Get summary of test runs in this session.\"\"\"",
        "        if not self.test_history:",
        "            return {'runs': 0, 'passes': 0, 'failures': 0}",
        "",
        "        return {",
        "            'runs': len(self.test_history),",
        "            'passes': sum(1 for t in self.test_history if t.success),",
        "            'failures': sum(1 for t in self.test_history if not t.success),",
        "            'total_duration': sum(t.duration for t in self.test_history),",
        "            'last_run': self.test_history[-1].timestamp if self.test_history else None,",
        "        }",
        "",
        "",
        "# =============================================================================",
        "# Singleton Instances",
        "# =============================================================================",
        "",
        "# Global wrapper instances for convenience",
        "_git_wrapper: Optional[GitWrapper] = None",
        "_test_wrapper: Optional[TestWrapper] = None",
        "_dev_wrapper: Optional[DevWrapper] = None",
        "",
        "",
        "def get_git_wrapper(**kwargs) -> GitWrapper:",
        "    \"\"\"Get or create the global git wrapper.\"\"\"",
        "    global _git_wrapper",
        "    if _git_wrapper is None:",
        "        _git_wrapper = GitWrapper(**kwargs)",
        "    return _git_wrapper",
        "",
        "",
        "def get_test_wrapper(**kwargs) -> TestWrapper:",
        "    \"\"\"Get or create the global test wrapper.\"\"\"",
        "    global _test_wrapper",
        "    if _test_wrapper is None:",
        "        _test_wrapper = TestWrapper(**kwargs)",
        "    return _test_wrapper",
        "",
        "",
        "def get_dev_wrapper(**kwargs) -> DevWrapper:",
        "    \"\"\"Get or create the global development wrapper.\"\"\"",
        "    global _dev_wrapper",
        "    if _dev_wrapper is None:",
        "        _dev_wrapper = DevWrapper(**kwargs)",
        "    return _dev_wrapper",
        "",
        "",
        "# Convenience aliases",
        "git_wrapper = get_git_wrapper",
        "test_wrapper = get_test_wrapper",
        "dev_wrapper = get_dev_wrapper",
        "",
        "",
        "# =============================================================================",
        "# CLI Interface",
        "# =============================================================================",
        "",
        "def main():",
        "    \"\"\"CLI entry point for wrapped commands.\"\"\"",
        "    parser = argparse.ArgumentParser(",
        "        description='Context-aware CLI wrapper for development commands',",
        "        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "        epilog=\"\"\"",
        "Examples:",
        "    %(prog)s git status",
        "    %(prog)s git log -5 --oneline",
        "    %(prog)s test pytest tests/ -v",
        "    %(prog)s run echo \"hello world\"",
        "    %(prog)s --summary",
        "        \"\"\"",
        "    )",
        "",
        "    parser.add_argument(",
        "        'wrapper_type',",
        "        nargs='?',",
        "        choices=['git', 'test', 'run'],",
        "        help='Type of wrapper to use'",
        "    )",
        "    parser.add_argument(",
        "        'command',",
        "        nargs='*',",
        "        help='Command to execute'",
        "    )",
        "    parser.add_argument(",
        "        '-v', '--verbose',",
        "        action='store_true',",
        "        help='Verbose output'",
        "    )",
        "    parser.add_argument(",
        "        '--summary',",
        "        action='store_true',",
        "        help='Show session summary'",
        "    )",
        "    parser.add_argument(",
        "        '--json',",
        "        action='store_true',",
        "        help='Output results as JSON'",
        "    )",
        "",
        "    args = parser.parse_args()",
        "",
        "    # Handle summary request",
        "    if args.summary:",
        "        wrapper = get_dev_wrapper(verbose=args.verbose)",
        "        summary = {",
        "            'session': wrapper.get_session_summary(),",
        "            'context': wrapper.get_context_summary(),",
        "            'should_reindex': wrapper.should_reindex(),",
        "        }",
        "        if args.json:",
        "            print(json.dumps(summary, indent=2))",
        "        else:",
        "            print(\"Session Summary:\")",
        "            print(f\"  Tasks: {summary['session']['task_count']}\")",
        "            print(f\"  Success Rate: {summary['session']['success_rate']:.1%}\")",
        "            print(f\"  Total Duration: {summary['session']['total_duration']:.2f}s\")",
        "            print(f\"\\nContext Window:\")",
        "            print(f\"  Items: {summary['context']['total_items']}\")",
        "            print(f\"  Files Accessed: {summary['context']['unique_files_accessed']}\")",
        "            if summary['should_reindex']:",
        "                print(\"\\nðŸ’¡ Re-indexing recommended\")",
        "        return 0",
        "",
        "    # Need wrapper type and command",
        "    if not args.wrapper_type:",
        "        parser.print_help()",
        "        return 1",
        "",
        "    if not args.command:",
        "        print(f\"Error: No command specified for '{args.wrapper_type}' wrapper\")",
        "        return 1",
        "",
        "    # Select wrapper",
        "    if args.wrapper_type == 'git':",
        "        wrapper = get_git_wrapper(verbose=args.verbose)",
        "        cmd = ['git'] + args.command",
        "    elif args.wrapper_type == 'test':",
        "        wrapper = get_test_wrapper(verbose=args.verbose)",
        "        cmd = args.command",
        "    else:  # 'run'",
        "        wrapper = get_dev_wrapper(verbose=args.verbose)",
        "        cmd = args.command",
        "",
        "    # Execute",
        "    result = wrapper.run(cmd)",
        "",
        "    # Output",
        "    if args.json:",
        "        print(result.to_json())",
        "    else:",
        "        if result.stdout:",
        "            print(result.stdout, end='')",
        "        if result.stderr:",
        "            print(result.stderr, end='', file=sys.stderr)",
        "",
        "    return result.exit_code",
        "",
        "",
        "if __name__ == '__main__':",
        "    sys.exit(main())"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": null,
      "start_line": 0,
      "lines_added": [
        "\"\"\"",
        "Tests for CLI wrapper framework.",
        "",
        "Tests cover:",
        "- ExecutionContext data collection",
        "- GitContext collection",
        "- HookRegistry registration and triggering",
        "- CLIWrapper command execution",
        "- TaskCompletionManager callbacks",
        "- ContextWindowManager tracking",
        "\"\"\"",
        "",
        "import os",
        "import sys",
        "import tempfile",
        "import time",
        "import unittest",
        "from pathlib import Path",
        "from unittest.mock import Mock, patch, MagicMock",
        "",
        "# Add parent directory for imports",
        "sys.path.insert(0, str(Path(__file__).parent.parent))",
        "",
        "from cortical.cli_wrapper import (",
        "    ExecutionContext,",
        "    GitContext,",
        "    HookRegistry,",
        "    HookType,",
        "    CLIWrapper,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    create_wrapper_with_completion_manager,",
        "    run_with_context,",
        ")",
        "",
        "",
        "class TestGitContext(unittest.TestCase):",
        "    \"\"\"Tests for GitContext collection.\"\"\"",
        "",
        "    def test_collect_non_repo(self):",
        "        \"\"\"Test collection outside git repo.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            ctx = GitContext.collect(tmpdir)",
        "            self.assertFalse(ctx.is_repo)",
        "            self.assertEqual(ctx.branch, \"\")",
        "",
        "    def test_collect_in_repo(self):",
        "        \"\"\"Test collection inside current repo.\"\"\"",
        "        # Current directory should be a git repo",
        "        ctx = GitContext.collect()",
        "        self.assertTrue(ctx.is_repo)",
        "        self.assertTrue(len(ctx.branch) > 0)",
        "",
        "    def test_to_dict(self):",
        "        \"\"\"Test conversion to dictionary.\"\"\"",
        "        ctx = GitContext(",
        "            is_repo=True,",
        "            branch=\"main\",",
        "            commit_hash=\"abc123\",",
        "            is_dirty=True,",
        "            staged_files=[\"file1.py\"],",
        "            modified_files=[\"file2.py\"],",
        "            untracked_files=[\"file3.py\"],",
        "        )",
        "        d = ctx.to_dict()",
        "        self.assertEqual(d['branch'], \"main\")",
        "        self.assertEqual(d['commit_hash'], \"abc123\")",
        "        self.assertTrue(d['is_dirty'])",
        "        self.assertEqual(len(d['staged_files']), 1)",
        "",
        "",
        "class TestExecutionContext(unittest.TestCase):",
        "    \"\"\"Tests for ExecutionContext.\"\"\"",
        "",
        "    def test_default_values(self):",
        "        \"\"\"Test default context values.\"\"\"",
        "        ctx = ExecutionContext()",
        "        self.assertEqual(ctx.exit_code, 0)",
        "        self.assertEqual(ctx.command, [])",
        "        self.assertFalse(ctx.success)",
        "",
        "    def test_to_dict(self):",
        "        \"\"\"Test conversion to dictionary.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command=['echo', 'hello'],",
        "            command_str='echo hello',",
        "            exit_code=0,",
        "            success=True,",
        "            stdout='hello\\n',",
        "        )",
        "        d = ctx.to_dict()",
        "        self.assertEqual(d['command'], ['echo', 'hello'])",
        "        self.assertEqual(d['exit_code'], 0)",
        "        self.assertTrue(d['success'])",
        "",
        "    def test_to_json(self):",
        "        \"\"\"Test JSON serialization.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command=['test'],",
        "            success=True,",
        "        )",
        "        json_str = ctx.to_json()",
        "        self.assertIn('\"success\": true', json_str)",
        "        self.assertIn('\"command\":', json_str)",
        "        self.assertIn('\"test\"', json_str)",
        "",
        "    def test_summary(self):",
        "        \"\"\"Test summary generation.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command_str='pytest tests/',",
        "            success=True,",
        "            exit_code=0,",
        "            duration=1.5,",
        "        )",
        "        summary = ctx.summary()",
        "        self.assertIn('pytest tests/', summary)",
        "        self.assertIn('1.50s', summary)",
        "        self.assertIn('âœ“', summary)",
        "",
        "    def test_summary_failure(self):",
        "        \"\"\"Test summary for failed command.\"\"\"",
        "        ctx = ExecutionContext(",
        "            command_str='pytest tests/',",
        "            success=False,",
        "            exit_code=1,",
        "            duration=0.5,",
        "        )",
        "        summary = ctx.summary()",
        "        self.assertIn('âœ—', summary)",
        "        self.assertIn('exit=1', summary)",
        "",
        "",
        "class TestHookRegistry(unittest.TestCase):",
        "    \"\"\"Tests for HookRegistry.\"\"\"",
        "",
        "    def test_register_global_hook(self):",
        "        \"\"\"Test registering a global hook.\"\"\"",
        "        registry = HookRegistry()",
        "        callback = Mock()",
        "",
        "        registry.register(HookType.POST_EXEC, callback)",
        "",
        "        hooks = registry.get_hooks(HookType.POST_EXEC, ['any', 'command'])",
        "        self.assertEqual(len(hooks), 1)",
        "        self.assertEqual(hooks[0], callback)",
        "",
        "    def test_register_pattern_hook(self):",
        "        \"\"\"Test registering a pattern-specific hook.\"\"\"",
        "        registry = HookRegistry()",
        "        git_callback = Mock()",
        "        pytest_callback = Mock()",
        "",
        "        registry.register(HookType.POST_EXEC, git_callback, pattern='git')",
        "        registry.register(HookType.POST_EXEC, pytest_callback, pattern='pytest')",
        "",
        "        # Git command should match git hook",
        "        git_hooks = registry.get_hooks(HookType.POST_EXEC, ['git', 'status'])",
        "        self.assertEqual(len(git_hooks), 1)",
        "        self.assertEqual(git_hooks[0], git_callback)",
        "",
        "        # Pytest command should match pytest hook",
        "        pytest_hooks = registry.get_hooks(HookType.POST_EXEC, ['pytest', 'tests/'])",
        "        self.assertEqual(len(pytest_hooks), 1)",
        "        self.assertEqual(pytest_hooks[0], pytest_callback)",
        "",
        "    def test_convenience_methods(self):",
        "        \"\"\"Test convenience registration methods.\"\"\"",
        "        registry = HookRegistry()",
        "        pre_cb = Mock()",
        "        post_cb = Mock()",
        "        success_cb = Mock()",
        "        error_cb = Mock()",
        "",
        "        registry.register_pre(None, pre_cb)",
        "        registry.register_post(None, post_cb)",
        "        registry.register_success('git', success_cb)",
        "        registry.register_error('pytest', error_cb)",
        "",
        "        self.assertEqual(len(registry.get_hooks(HookType.PRE_EXEC, ['any'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.POST_EXEC, ['any'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.ON_SUCCESS, ['git'])), 1)",
        "        self.assertEqual(len(registry.get_hooks(HookType.ON_ERROR, ['pytest'])), 1)",
        "",
        "    def test_trigger_hooks(self):",
        "        \"\"\"Test triggering hooks.\"\"\"",
        "        registry = HookRegistry()",
        "        callback = Mock()",
        "        registry.register(HookType.POST_EXEC, callback)",
        "",
        "        ctx = ExecutionContext(command=['test'])",
        "        registry.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        callback.assert_called_once_with(ctx)",
        "",
        "    def test_hook_error_handling(self):",
        "        \"\"\"Test that hook errors don't crash execution.\"\"\"",
        "        registry = HookRegistry()",
        "",
        "        def bad_callback(ctx):",
        "            raise ValueError(\"Hook error!\")",
        "",
        "        registry.register(HookType.POST_EXEC, bad_callback)",
        "",
        "        ctx = ExecutionContext(command=['test'])",
        "        # Should not raise",
        "        registry.trigger(HookType.POST_EXEC, ctx)",
        "",
        "        # Error should be recorded",
        "        self.assertIn('hook_errors', ctx.metadata)",
        "        self.assertTrue(any('Hook error!' in e for e in ctx.metadata['hook_errors']))",
        "",
        "",
        "class TestCLIWrapper(unittest.TestCase):",
        "    \"\"\"Tests for CLIWrapper.\"\"\"",
        "",
        "    def test_run_simple_command(self):",
        "        \"\"\"Test running a simple command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['echo', 'hello'])",
        "",
        "        self.assertEqual(result.exit_code, 0)",
        "        self.assertTrue(result.success)",
        "        self.assertIn('hello', result.stdout)",
        "        self.assertGreater(result.duration, 0)",
        "",
        "    def test_run_with_string_command(self):",
        "        \"\"\"Test running command as string.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run('echo hello')",
        "",
        "        self.assertEqual(result.exit_code, 0)",
        "        self.assertEqual(result.command, ['echo', 'hello'])",
        "",
        "    def test_run_failing_command(self):",
        "        \"\"\"Test handling failed command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "",
        "        self.assertEqual(result.exit_code, 1)",
        "        self.assertFalse(result.success)",
        "",
        "    def test_run_with_timeout(self):",
        "        \"\"\"Test command timeout handling.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(",
        "            ['python', '-c', 'import time; time.sleep(10)'],",
        "            timeout=0.1",
        "        )",
        "",
        "        self.assertFalse(result.success)",
        "        self.assertIn('timeout', result.metadata)",
        "",
        "    def test_run_nonexistent_command(self):",
        "        \"\"\"Test handling nonexistent command.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "        result = wrapper.run(['nonexistent_command_xyz'])",
        "",
        "        self.assertEqual(result.exit_code, 127)",
        "        self.assertFalse(result.success)",
        "        self.assertIn('error', result.metadata)",
        "",
        "    def test_task_classification(self):",
        "        \"\"\"Test task type classification.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        # Test task",
        "        result = wrapper.run(['echo', 'test'])  # not a test command",
        "        self.assertEqual(result.task_type, 'other')",
        "",
        "        # Simulate pytest classification",
        "        ctx = wrapper._build_context(['pytest', 'tests/'])",
        "        self.assertEqual(ctx.task_type, 'test')",
        "",
        "        # Git classification",
        "        ctx = wrapper._build_context(['git', 'commit', '-m', 'test'])",
        "        self.assertEqual(ctx.task_type, 'commit')",
        "",
        "    def test_hooks_triggered(self):",
        "        \"\"\"Test that hooks are triggered during execution.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        pre_called = []",
        "        post_called = []",
        "",
        "        def pre_hook(ctx):",
        "            pre_called.append(ctx.command_str)",
        "",
        "        def post_hook(ctx):",
        "            post_called.append((ctx.command_str, ctx.success))",
        "",
        "        wrapper.hooks.register_pre(None, pre_hook)",
        "        wrapper.hooks.register_post(None, post_hook)",
        "",
        "        wrapper.run(['echo', 'hello'])",
        "",
        "        self.assertEqual(len(pre_called), 1)",
        "        self.assertEqual(len(post_called), 1)",
        "        self.assertTrue(post_called[0][1])  # success = True",
        "",
        "    def test_success_error_hooks(self):",
        "        \"\"\"Test ON_SUCCESS and ON_ERROR hooks.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        success_calls = []",
        "        error_calls = []",
        "",
        "        wrapper.hooks.register_success(None, lambda ctx: success_calls.append(1))",
        "        wrapper.hooks.register_error(None, lambda ctx: error_calls.append(1))",
        "",
        "        # Successful command",
        "        wrapper.run(['echo', 'hello'])",
        "        self.assertEqual(len(success_calls), 1)",
        "        self.assertEqual(len(error_calls), 0)",
        "",
        "        # Failed command",
        "        wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "        self.assertEqual(len(success_calls), 1)  # unchanged",
        "        self.assertEqual(len(error_calls), 1)",
        "",
        "    def test_git_context_collection(self):",
        "        \"\"\"Test git context is collected when enabled.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=True)",
        "        result = wrapper.run(['echo', 'test'])",
        "",
        "        # Should have git context (we're in a git repo)",
        "        self.assertTrue(result.git.is_repo)",
        "        self.assertTrue(len(result.git.branch) > 0)",
        "",
        "    def test_output_capture(self):",
        "        \"\"\"Test stdout/stderr capture.\"\"\"",
        "        wrapper = CLIWrapper(collect_git_context=False)",
        "",
        "        # Stdout",
        "        result = wrapper.run(['echo', 'hello'])",
        "        self.assertIn('hello', result.stdout)",
        "        self.assertEqual(result.output_lines, 1)",
        "",
        "        # Stderr",
        "        result = wrapper.run(['python', '-c', 'import sys; print(\"error\", file=sys.stderr)'])",
        "        self.assertIn('error', result.stderr)",
        "        self.assertEqual(result.error_lines, 1)",
        "",
        "",
        "class TestTaskCompletionManager(unittest.TestCase):",
        "    \"\"\"Tests for TaskCompletionManager.\"\"\"",
        "",
        "    def test_register_task_handler(self):",
        "        \"\"\"Test registering task-specific handlers.\"\"\"",
        "        manager = TaskCompletionManager()",
        "        handler_calls = []",
        "",
        "        manager.on_task_complete('test', lambda ctx: handler_calls.append(ctx))",
        "",
        "        # Simulate completion",
        "        ctx = ExecutionContext(task_type='test', success=True)",
        "        manager.handle_completion(ctx)",
        "",
        "        self.assertEqual(len(handler_calls), 1)",
        "        self.assertEqual(handler_calls[0], ctx)",
        "",
        "    def test_register_any_handler(self):",
        "        \"\"\"Test registering global completion handler.\"\"\"",
        "        manager = TaskCompletionManager()",
        "        handler_calls = []",
        "",
        "        manager.on_any_complete(lambda ctx: handler_calls.append(ctx.task_type))",
        "",
        "        manager.handle_completion(ExecutionContext(task_type='test'))",
        "        manager.handle_completion(ExecutionContext(task_type='commit'))",
        "        manager.handle_completion(ExecutionContext(task_type='build'))",
        "",
        "        self.assertEqual(handler_calls, ['test', 'commit', 'build'])",
        "",
        "    def test_session_summary(self):",
        "        \"\"\"Test session summary generation.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        # Empty summary",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 0)",
        "",
        "        # Add some completions",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='test',",
        "            success=True,",
        "            duration=1.0",
        "        ))",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='test',",
        "            success=False,",
        "            duration=0.5",
        "        ))",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='commit',",
        "            success=True,",
        "            duration=0.2",
        "        ))",
        "",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 3)",
        "        self.assertAlmostEqual(summary['success_rate'], 2/3, places=2)",
        "        self.assertAlmostEqual(summary['total_duration'], 1.7, places=2)",
        "        self.assertEqual(summary['tasks_by_type']['test']['count'], 2)",
        "        self.assertEqual(summary['tasks_by_type']['commit']['successes'], 1)",
        "",
        "    def test_should_trigger_reindex_on_commit(self):",
        "        \"\"\"Test reindex recommendation after commit.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        # No activity",
        "        self.assertFalse(manager.should_trigger_reindex())",
        "",
        "        # Commit success should trigger",
        "        manager.handle_completion(ExecutionContext(",
        "            task_type='commit',",
        "            success=True,",
        "        ))",
        "        self.assertTrue(manager.should_trigger_reindex())",
        "",
        "    def test_should_trigger_reindex_on_file_changes(self):",
        "        \"\"\"Test reindex recommendation on file changes.\"\"\"",
        "        manager = TaskCompletionManager()",
        "",
        "        ctx = ExecutionContext(task_type='other')",
        "        ctx.git.modified_files = ['test.py']",
        "        manager.handle_completion(ctx)",
        "",
        "        self.assertTrue(manager.should_trigger_reindex())",
        "",
        "",
        "class TestContextWindowManager(unittest.TestCase):",
        "    \"\"\"Tests for ContextWindowManager.\"\"\"",
        "",
        "    def test_add_execution(self):",
        "        \"\"\"Test adding executions to context.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        ctx = ExecutionContext(",
        "            task_type='test',",
        "            command_str='pytest tests/',",
        "            success=True,",
        "            duration=1.0,",
        "        )",
        "        manager.add_execution(ctx)",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['executions'], 1)",
        "        self.assertEqual(summary['task_types']['test'], 1)",
        "",
        "    def test_add_file_read(self):",
        "        \"\"\"Test tracking file reads.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        manager.add_file_read('test.py')",
        "        manager.add_file_read('another.py')",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['file_reads'], 2)",
        "        self.assertEqual(summary['unique_files_accessed'], 2)",
        "",
        "    def test_recent_files(self):",
        "        \"\"\"Test getting recently accessed files.\"\"\"",
        "        manager = ContextWindowManager()",
        "",
        "        manager.add_file_read('old.py')",
        "        time.sleep(0.01)  # Small delay",
        "        manager.add_file_read('new.py')",
        "",
        "        recent = manager.get_recent_files(limit=2)",
        "        self.assertEqual(recent[0], 'new.py')  # Most recent first",
        "",
        "    def test_context_pruning_suggestion(self):",
        "        \"\"\"Test pruning suggestions for stale files.\"\"\"",
        "        manager = ContextWindowManager(max_context_items=10)",
        "",
        "        # Add some files",
        "        for i in range(20):",
        "            manager.add_file_read(f'file{i}.py')",
        "",
        "        # With default 5-minute staleness, nothing should be stale yet",
        "        suggestions = manager.suggest_pruning()",
        "        # All files accessed just now, so no suggestions expected",
        "        # (unless we mock time)",
        "        self.assertIsInstance(suggestions, list)",
        "",
        "    def test_max_context_pruning(self):",
        "        \"\"\"Test automatic pruning when max context exceeded.\"\"\"",
        "        manager = ContextWindowManager(max_context_items=5)",
        "",
        "        # Add more items than max",
        "        for i in range(10):",
        "            ctx = ExecutionContext(task_type='test', command_str=f'cmd{i}')",
        "            manager.add_execution(ctx)",
        "",
        "        summary = manager.get_context_summary()",
        "        self.assertEqual(summary['total_items'], 5)",
        "",
        "",
        "class TestConvenienceFunctions(unittest.TestCase):",
        "    \"\"\"Tests for convenience functions.\"\"\"",
        "",
        "    def test_create_wrapper_with_manager(self):",
        "        \"\"\"Test creating wrapper with completion manager.\"\"\"",
        "        wrapper, manager = create_wrapper_with_completion_manager()",
        "",
        "        self.assertIsInstance(wrapper, CLIWrapper)",
        "        self.assertIsInstance(manager, TaskCompletionManager)",
        "",
        "        # Run a command and verify manager receives it",
        "        wrapper.run(['echo', 'test'])",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 1)",
        "",
        "    def test_run_with_context(self):",
        "        \"\"\"Test run_with_context convenience function.\"\"\"",
        "        result = run_with_context(['echo', 'hello'])",
        "",
        "        self.assertIsInstance(result, ExecutionContext)",
        "        self.assertTrue(result.success)",
        "        self.assertIn('hello', result.stdout)",
        "",
        "",
        "class TestIntegration(unittest.TestCase):",
        "    \"\"\"Integration tests for the wrapper system.\"\"\"",
        "",
        "    def test_full_workflow(self):",
        "        \"\"\"Test complete workflow with hooks and completion tracking.\"\"\"",
        "        wrapper, manager = create_wrapper_with_completion_manager()",
        "",
        "        # Track hook calls",
        "        hook_calls = []",
        "        wrapper.hooks.register_pre(None, lambda ctx: hook_calls.append('pre'))",
        "        wrapper.hooks.register_post(None, lambda ctx: hook_calls.append('post'))",
        "",
        "        # Track completion",
        "        completion_data = []",
        "        manager.on_any_complete(lambda ctx: completion_data.append({",
        "            'cmd': ctx.command_str,",
        "            'success': ctx.success,",
        "        }))",
        "",
        "        # Run commands",
        "        wrapper.run(['echo', 'first'])",
        "        wrapper.run(['echo', 'second'])",
        "        wrapper.run(['python', '-c', 'import sys; sys.exit(1)'])",
        "",
        "        # Verify hooks",
        "        self.assertEqual(hook_calls.count('pre'), 3)",
        "        self.assertEqual(hook_calls.count('post'), 3)",
        "",
        "        # Verify completions",
        "        self.assertEqual(len(completion_data), 3)",
        "        self.assertTrue(completion_data[0]['success'])",
        "        self.assertTrue(completion_data[1]['success'])",
        "        self.assertFalse(completion_data[2]['success'])",
        "",
        "        # Verify session summary",
        "        summary = manager.get_session_summary()",
        "        self.assertEqual(summary['task_count'], 3)",
        "        self.assertAlmostEqual(summary['success_rate'], 2/3, places=2)",
        "",
        "",
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "lines_removed": [],
      "context_before": [],
      "context_after": [],
      "change_type": "add"
    }
  ],
  "hour_of_day": 16,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -334236,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}