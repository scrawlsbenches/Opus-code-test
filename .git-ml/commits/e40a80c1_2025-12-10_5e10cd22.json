{
  "hash": "e40a80c12dc3ae0811a9d897ac9a3bc057ce37ad",
  "message": "Add ConceptNet-style graph visualization export (Task 29)",
  "author": "Claude",
  "timestamp": "2025-12-10 00:24:25 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "TASK_LIST.md",
    "cortical/persistence.py",
    "cortical/processor.py",
    "tests/test_persistence.py"
  ],
  "insertions": 573,
  "deletions": 18,
  "hunks": [
    {
      "file": "TASK_LIST.md",
      "function": "processor.extract_corpus_semantics(",
      "start_line": 1010,
      "lines_added": [
        "**Files:** `cortical/persistence.py`, `cortical/processor.py`",
        "**Status:** [x] Completed",
        "**Solution Applied:**",
        "1. Added `LAYER_COLORS` constant with color codes for each layer:",
        "   - Tokens: Royal Blue (#4169E1)",
        "   - Bigrams: Forest Green (#228B22)",
        "   - Concepts: Dark Orange (#FF8C00)",
        "   - Documents: Crimson (#DC143C)",
        "2. Added `LAYER_NAMES` constant for display names",
        "3. Added `export_conceptnet_json()` function (~200 lines) with:",
        "   - Color-coded nodes by layer with layer_name",
        "   - Typed edges with relation_type, confidence, and source_type",
        "   - Cross-layer edges (feedforward/feedback)",
        "   - Relation-based edge colors",
        "   - D3.js/Cytoscape/Gephi-compatible format",
        "4. Added `_get_relation_color()` helper with 16 relation type colors",
        "5. Added `_count_edge_types()` and `_count_relation_types()` helpers",
        "6. Added processor wrapper method `export_conceptnet_json()`",
        "",
        "**Files Modified:**",
        "- `cortical/persistence.py` - Added constants and export function (~270 lines)",
        "- `cortical/processor.py` - Added processor wrapper method (~50 lines)",
        "- `tests/test_persistence.py` - Added 13 tests for ConceptNet export",
        "",
        "**Usage:**",
        "```python",
        "# Export ConceptNet-style graph",
        "processor.extract_corpus_semantics(verbose=False)",
        "graph = processor.export_conceptnet_json(",
        "    \"graph.json\",",
        "    include_cross_layer=True,     # Include feedforward/feedback edges",
        "    include_typed_edges=True,     # Include typed_connections",
        "    min_weight=0.0,               # Minimum edge weight",
        "    max_nodes_per_layer=100       # Limit nodes per layer",
        ")",
        "",
        "# Open graph.json in D3.js, Cytoscape.js, or Gephi for visualization",
        "```"
      ],
      "lines_removed": [
        "**Files:** `cortical/persistence.py`",
        "**Status:** [ ] Pending",
        "**Implementation Steps:**",
        "1. Add `export_conceptnet_json()` function",
        "2. Include edge relation types and confidence",
        "3. Color-code by layer (tokens=blue, bigrams=green, concepts=orange, docs=red)",
        "4. Export in format compatible with graph visualization tools (D3.js, Cytoscape)",
        "5. Include cross-layer edges"
      ],
      "context_before": [
        "# Direct pattern extraction",
        "relations = processor.extract_pattern_relations(min_confidence=0.5)",
        "for t1, rel_type, t2, confidence in relations:",
        "    print(f\"{t1} --{rel_type}--> {t2} ({confidence:.2f})\")",
        "```",
        "",
        "---",
        "",
        "### 29. Visualize ConceptNet-Style Graph",
        ""
      ],
      "context_after": [
        "",
        "**Problem:**",
        "Current `export_graph_json()` doesn't distinguish edge types or layers. Need ConceptNet-style visualization export.",
        "",
        "",
        "---",
        "",
        "### 30. Add Analogy Completion",
        "",
        "**Files:** `cortical/query.py`",
        "**Status:** [ ] Pending",
        "",
        "**Problem:**",
        "ConceptNet enables analogy completion: \"king is to queen as man is to ?\" → \"woman\""
      ],
      "change_type": "modify"
    },
    {
      "file": "TASK_LIST.md",
      "function": "Semantic bonus is capped at 50% boost (`min(avg_semantic, 0.5)`). This is a reas",
      "start_line": 1128,
      "lines_added": [
        "| Low | Visualize ConceptNet-style graph | ✅ Completed | ConceptNet |",
        "**ConceptNet Enhancement Completion:** 11/12 tasks (92%)",
        "Ran 307 tests in 0.275s"
      ],
      "lines_removed": [
        "| Low | Visualize ConceptNet-style graph | ⏳ Pending | ConceptNet |",
        "**ConceptNet Enhancement Completion:** 10/12 tasks (83%)",
        "Ran 294 tests in 0.265s"
      ],
      "context_before": [
        "| **Critical** | **Build cross-layer feedforward connections** | ✅ Completed | **ConceptNet** |",
        "| **Critical** | **Add concept-level lateral connections** | ✅ Completed | **ConceptNet** |",
        "| **Critical** | **Add bigram lateral connections** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Implement relation-weighted PageRank** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Implement cross-layer PageRank propagation** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Add typed edge storage** | ✅ Completed | **ConceptNet** |",
        "| Medium | Implement multi-hop semantic inference | ✅ Completed | ConceptNet |",
        "| Medium | Add relation path scoring | ✅ Completed | ConceptNet |",
        "| Medium | Implement concept inheritance | ✅ Completed | ConceptNet |",
        "| Low | Add commonsense relation extraction | ✅ Completed | ConceptNet |"
      ],
      "context_after": [
        "| Low | Add analogy completion | ⏳ Pending | ConceptNet |",
        "",
        "**Bug Fix Completion:** 7/7 tasks (100%)",
        "**RAG Enhancement Completion:** 8/8 tasks (100%)",
        "",
        "---",
        "",
        "## Test Results",
        "",
        "```",
        "OK",
        "```",
        "",
        "All tests passing as of 2025-12-10.",
        "",
        "---",
        "",
        "*Updated from code review on 2025-12-10*"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/persistence.py",
      "function": "def load_semantic_relations_json(filepath: str) -> list:",
      "start_line": 280,
      "lines_added": [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "# Layer colors for visualization",
        "LAYER_COLORS = {",
        "    CorticalLayer.TOKENS: '#4169E1',     # Royal Blue",
        "    CorticalLayer.BIGRAMS: '#228B22',    # Forest Green",
        "    CorticalLayer.CONCEPTS: '#FF8C00',   # Dark Orange",
        "    CorticalLayer.DOCUMENTS: '#DC143C',  # Crimson",
        "}",
        "",
        "# Layer display names",
        "LAYER_NAMES = {",
        "    CorticalLayer.TOKENS: 'Tokens',",
        "    CorticalLayer.BIGRAMS: 'Bigrams',",
        "    CorticalLayer.CONCEPTS: 'Concepts',",
        "    CorticalLayer.DOCUMENTS: 'Documents',",
        "}",
        "",
        "",
        "def export_conceptnet_json(",
        "    filepath: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    semantic_relations: Optional[list] = None,",
        "    include_cross_layer: bool = True,",
        "    include_typed_edges: bool = True,",
        "    min_weight: float = 0.0,",
        "    min_confidence: float = 0.0,",
        "    max_nodes_per_layer: int = 100,",
        "    verbose: bool = True",
        ") -> Dict[str, Any]:",
        "    \"\"\"",
        "    Export ConceptNet-style graph for visualization.",
        "",
        "    Creates a rich graph format with:",
        "    - Color-coded nodes by layer",
        "    - Typed edges with relation types and confidence",
        "    - Cross-layer connections (feedforward/feedback)",
        "    - D3.js/Cytoscape-compatible output",
        "",
        "    Args:",
        "        filepath: Output file path (JSON)",
        "        layers: Dictionary of layers",
        "        semantic_relations: Optional list of (t1, rel, t2, weight) tuples",
        "        include_cross_layer: Include feedforward/feedback edges",
        "        include_typed_edges: Include typed_connections with relation types",
        "        min_weight: Minimum edge weight to include",
        "        min_confidence: Minimum confidence for typed edges",
        "        max_nodes_per_layer: Maximum nodes per layer (by PageRank)",
        "        verbose: Print progress messages",
        "",
        "    Returns:",
        "        The exported graph data",
        "",
        "    Example:",
        "        >>> export_conceptnet_json(",
        "        ...     \"graph.json\", processor.layers,",
        "        ...     semantic_relations=processor.semantic_relations",
        "        ... )",
        "    \"\"\"",
        "    nodes = []",
        "    edges = []",
        "    node_ids = set()",
        "    edge_set = set()  # Track unique edges",
        "",
        "    # Collect nodes from each layer",
        "    for layer_enum, layer in layers.items():",
        "        if layer is None or layer.column_count() == 0:",
        "            continue",
        "",
        "        color = LAYER_COLORS.get(layer_enum, '#808080')",
        "        layer_name = LAYER_NAMES.get(layer_enum, f'Layer {layer_enum.value}')",
        "",
        "        # Sort by PageRank and take top nodes",
        "        sorted_cols = sorted(",
        "            layer.minicolumns.values(),",
        "            key=lambda c: c.pagerank,",
        "            reverse=True",
        "        )[:max_nodes_per_layer]",
        "",
        "        for col in sorted_cols:",
        "            node = {",
        "                'id': col.id,",
        "                'label': col.content,",
        "                'layer': layer_enum.value,",
        "                'layer_name': layer_name,",
        "                'color': color,",
        "                'pagerank': round(col.pagerank, 6),",
        "                'tfidf': round(col.tfidf, 6),",
        "                'activation': round(col.activation, 6),",
        "                'occurrence_count': col.occurrence_count,",
        "                'document_count': len(col.document_ids),",
        "                'cluster_id': col.cluster_id",
        "            }",
        "            nodes.append(node)",
        "            node_ids.add(col.id)",
        "",
        "    # Collect lateral edges (same-layer connections)",
        "    for layer_enum, layer in layers.items():",
        "        if layer is None:",
        "            continue",
        "",
        "        for col in layer.minicolumns.values():",
        "            if col.id not in node_ids:",
        "                continue",
        "",
        "            # Add typed edges with relation information",
        "            if include_typed_edges:",
        "                for target_id, edge_obj in col.typed_connections.items():",
        "                    if target_id in node_ids and edge_obj.weight >= min_weight:",
        "                        if edge_obj.confidence >= min_confidence:",
        "                            edge_key = (col.id, target_id, edge_obj.relation_type)",
        "                            if edge_key not in edge_set:",
        "                                edge_set.add(edge_key)",
        "                                edges.append({",
        "                                    'source': col.id,",
        "                                    'target': target_id,",
        "                                    'weight': round(edge_obj.weight, 4),",
        "                                    'relation_type': edge_obj.relation_type,",
        "                                    'confidence': round(edge_obj.confidence, 4),",
        "                                    'source_type': edge_obj.source,",
        "                                    'edge_type': 'lateral',",
        "                                    'color': _get_relation_color(edge_obj.relation_type)",
        "                                })",
        "",
        "            # Add regular lateral connections (without typed info)",
        "            for target_id, weight in col.lateral_connections.items():",
        "                if target_id in node_ids and weight >= min_weight:",
        "                    # Skip if already added as typed edge",
        "                    if include_typed_edges and target_id in col.typed_connections:",
        "                        continue",
        "                    edge_key = (col.id, target_id, 'co_occurrence')",
        "                    if edge_key not in edge_set:",
        "                        edge_set.add(edge_key)",
        "                        edges.append({",
        "                            'source': col.id,",
        "                            'target': target_id,",
        "                            'weight': round(weight, 4),",
        "                            'relation_type': 'co_occurrence',",
        "                            'confidence': 1.0,",
        "                            'source_type': 'corpus',",
        "                            'edge_type': 'lateral',",
        "                            'color': '#999999'",
        "                        })",
        "",
        "    # Add cross-layer edges (feedforward/feedback)",
        "    if include_cross_layer:",
        "        for layer_enum, layer in layers.items():",
        "            if layer is None:",
        "                continue",
        "",
        "            for col in layer.minicolumns.values():",
        "                if col.id not in node_ids:",
        "                    continue",
        "",
        "                # Feedforward connections (to lower layers)",
        "                for target_id, weight in col.feedforward_connections.items():",
        "                    if target_id in node_ids and weight >= min_weight:",
        "                        edge_key = (col.id, target_id, 'feedforward')",
        "                        if edge_key not in edge_set:",
        "                            edge_set.add(edge_key)",
        "                            edges.append({",
        "                                'source': col.id,",
        "                                'target': target_id,",
        "                                'weight': round(weight, 4),",
        "                                'relation_type': 'feedforward',",
        "                                'confidence': 1.0,",
        "                                'source_type': 'structure',",
        "                                'edge_type': 'cross_layer',",
        "                                'color': '#4CAF50'  # Green",
        "                            })",
        "",
        "                # Feedback connections (to higher layers)",
        "                for target_id, weight in col.feedback_connections.items():",
        "                    if target_id in node_ids and weight >= min_weight:",
        "                        edge_key = (col.id, target_id, 'feedback')",
        "                        if edge_key not in edge_set:",
        "                            edge_set.add(edge_key)",
        "                            edges.append({",
        "                                'source': col.id,",
        "                                'target': target_id,",
        "                                'weight': round(weight, 4),",
        "                                'relation_type': 'feedback',",
        "                                'confidence': 1.0,",
        "                                'source_type': 'structure',",
        "                                'edge_type': 'cross_layer',",
        "                                'color': '#9C27B0'  # Purple",
        "                            })",
        "",
        "    # Add edges from semantic relations if provided",
        "    if semantic_relations:",
        "        for rel in semantic_relations:",
        "            if len(rel) >= 4:",
        "                t1, rel_type, t2, weight = rel[:4]",
        "                # Find node IDs",
        "                source_id = f\"L0_{t1}\"",
        "                target_id = f\"L0_{t2}\"",
        "                if source_id in node_ids and target_id in node_ids:",
        "                    if weight >= min_weight:",
        "                        edge_key = (source_id, target_id, rel_type)",
        "                        if edge_key not in edge_set:",
        "                            edge_set.add(edge_key)",
        "                            edges.append({",
        "                                'source': source_id,",
        "                                'target': target_id,",
        "                                'weight': round(weight, 4),",
        "                                'relation_type': rel_type,",
        "                                'confidence': 1.0,",
        "                                'source_type': 'semantic',",
        "                                'edge_type': 'semantic',",
        "                                'color': _get_relation_color(rel_type)",
        "                            })",
        "",
        "    # Build graph structure",
        "    graph = {",
        "        'nodes': nodes,",
        "        'edges': edges,",
        "        'metadata': {",
        "            'node_count': len(nodes),",
        "            'edge_count': len(edges),",
        "            'layers': {",
        "                layer_enum.value: {",
        "                    'name': LAYER_NAMES.get(layer_enum, f'Layer {layer_enum.value}'),",
        "                    'color': LAYER_COLORS.get(layer_enum, '#808080'),",
        "                    'node_count': sum(1 for n in nodes if n['layer'] == layer_enum.value)",
        "                }",
        "                for layer_enum in layers.keys()",
        "            },",
        "            'edge_types': _count_edge_types(edges),",
        "            'relation_types': _count_relation_types(edges),",
        "            'format_version': '1.0',",
        "            'compatible_with': ['D3.js', 'Cytoscape.js', 'vis.js', 'Gephi']",
        "        }",
        "    }",
        "",
        "    # Write to file",
        "    with open(filepath, 'w') as f:",
        "        json.dump(graph, f, indent=2)",
        "",
        "    if verbose:",
        "        print(f\"ConceptNet-style graph exported to {filepath}\")",
        "        print(f\"  Nodes: {len(nodes)}\")",
        "        print(f\"  Edges: {len(edges)}\")",
        "        print(f\"  Layers: {list(graph['metadata']['layers'].keys())}\")",
        "        print(f\"  Edge types: {graph['metadata']['edge_types']}\")",
        "",
        "    return graph",
        "",
        "",
        "def _get_relation_color(relation_type: str) -> str:",
        "    \"\"\"Get color for a relation type.\"\"\"",
        "    relation_colors = {",
        "        'IsA': '#E91E63',         # Pink",
        "        'PartOf': '#9C27B0',      # Purple",
        "        'HasA': '#673AB7',        # Deep Purple",
        "        'UsedFor': '#3F51B5',     # Indigo",
        "        'Causes': '#F44336',      # Red",
        "        'HasProperty': '#FF9800', # Orange",
        "        'AtLocation': '#4CAF50',  # Green",
        "        'CapableOf': '#00BCD4',   # Cyan",
        "        'SimilarTo': '#2196F3',   # Blue",
        "        'Antonym': '#795548',     # Brown",
        "        'RelatedTo': '#607D8B',   # Blue Grey",
        "        'CoOccurs': '#9E9E9E',    # Grey",
        "        'DerivedFrom': '#8BC34A', # Light Green",
        "        'DefinedBy': '#FFEB3B',   # Yellow",
        "        'feedforward': '#4CAF50', # Green",
        "        'feedback': '#9C27B0',    # Purple",
        "        'co_occurrence': '#999999',  # Grey",
        "    }",
        "    return relation_colors.get(relation_type, '#808080')",
        "",
        "",
        "def _count_edge_types(edges: list) -> Dict[str, int]:",
        "    \"\"\"Count edges by edge_type.\"\"\"",
        "    counts: Dict[str, int] = {}",
        "    for edge in edges:",
        "        edge_type = edge.get('edge_type', 'unknown')",
        "        counts[edge_type] = counts.get(edge_type, 0) + 1",
        "    return counts",
        "",
        "",
        "def _count_relation_types(edges: list) -> Dict[str, int]:",
        "    \"\"\"Count edges by relation_type.\"\"\"",
        "    counts: Dict[str, int] = {}",
        "    for edge in edges:",
        "        rel_type = edge.get('relation_type', 'unknown')",
        "        counts[rel_type] = counts.get(rel_type, 0) + 1",
        "    return counts"
      ],
      "lines_removed": [
        "    ",
        "        ",
        "    ",
        "    ",
        "    "
      ],
      "context_before": [
        "    ",
        "    return data.get('relations', [])",
        "",
        "",
        "def get_state_summary(",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    documents: Dict[str, str]",
        ") -> Dict:",
        "    \"\"\"",
        "    Get a summary of the current processor state."
      ],
      "context_after": [
        "    Args:",
        "        layers: Dictionary of layers",
        "        documents: Document collection",
        "    Returns:",
        "        Summary statistics",
        "    \"\"\"",
        "    summary = {",
        "        'documents': len(documents),",
        "        'layers': {}",
        "    }",
        "    for layer_enum, layer in layers.items():",
        "        summary['layers'][layer_enum.name] = {",
        "            'columns': len(layer.minicolumns),",
        "            'connections': layer.total_connections(),",
        "            'avg_activation': layer.average_activation(),",
        "            'sparsity': layer.sparsity()",
        "        }",
        "    summary['total_columns'] = sum(",
        "        len(layer.minicolumns) for layer in layers.values()",
        "    )",
        "    summary['total_connections'] = sum(",
        "        layer.total_connections() for layer in layers.values()",
        "    )",
        "    return summary"
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/processor.py",
      "function": "class CorticalTextProcessor:",
      "start_line": 1274,
      "lines_added": [
        "",
        "    def export_conceptnet_json(",
        "        self,",
        "        filepath: str,",
        "        include_cross_layer: bool = True,",
        "        include_typed_edges: bool = True,",
        "        min_weight: float = 0.0,",
        "        min_confidence: float = 0.0,",
        "        max_nodes_per_layer: int = 100,",
        "        verbose: bool = True",
        "    ) -> Dict[str, Any]:",
        "        \"\"\"",
        "        Export ConceptNet-style graph for visualization.",
        "",
        "        Creates a rich graph format with:",
        "        - Color-coded nodes by layer (tokens=blue, bigrams=green, concepts=orange, docs=red)",
        "        - Typed edges with relation types and confidence scores",
        "        - Cross-layer connections (feedforward/feedback)",
        "        - D3.js/Cytoscape-compatible output",
        "",
        "        Args:",
        "            filepath: Output file path (JSON)",
        "            include_cross_layer: Include feedforward/feedback edges",
        "            include_typed_edges: Include typed_connections with relation types",
        "            min_weight: Minimum edge weight to include",
        "            min_confidence: Minimum confidence for typed edges",
        "            max_nodes_per_layer: Maximum nodes per layer (by PageRank)",
        "            verbose: Print progress messages",
        "",
        "        Returns:",
        "            The exported graph data",
        "",
        "        Example:",
        "            >>> processor.extract_corpus_semantics(verbose=False)",
        "            >>> graph = processor.export_conceptnet_json(\"graph.json\")",
        "            >>> # Open graph.json in D3.js or Cytoscape for visualization",
        "        \"\"\"",
        "        return persistence.export_conceptnet_json(",
        "            filepath,",
        "            self.layers,",
        "            semantic_relations=self.semantic_relations,",
        "            include_cross_layer=include_cross_layer,",
        "            include_typed_edges=include_typed_edges,",
        "            min_weight=min_weight,",
        "            min_confidence=min_confidence,",
        "            max_nodes_per_layer=max_nodes_per_layer,",
        "            verbose=verbose",
        "        )",
        ""
      ],
      "lines_removed": [
        "    "
      ],
      "context_before": [
        "        processor = cls()",
        "        processor.layers = layers",
        "        processor.documents = documents",
        "        processor.document_metadata = document_metadata",
        "        processor.embeddings = embeddings",
        "        processor.semantic_relations = semantic_relations",
        "        return processor",
        "    ",
        "    def export_graph(self, filepath: str, layer: Optional[CorticalLayer] = None, max_nodes: int = 500) -> Dict:",
        "        return persistence.export_graph_json(filepath, self.layers, layer, max_nodes=max_nodes)"
      ],
      "context_after": [
        "    def summarize_document(self, doc_id: str, num_sentences: int = 3) -> str:",
        "        if doc_id not in self.documents: return \"\"",
        "        content = self.documents[doc_id]",
        "        sentences = re.split(r'(?<=[.!?])\\s+', content)",
        "        if len(sentences) <= num_sentences: return content",
        "        ",
        "        layer0 = self.layers[CorticalLayer.TOKENS]",
        "        scored = []",
        "        for sent in sentences:",
        "            tokens = self.tokenizer.tokenize(sent)"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_persistence.py",
      "function": "import os",
      "start_line": 6,
      "lines_added": [
        "    get_state_summary,",
        "    export_conceptnet_json,",
        "    LAYER_COLORS,",
        "    LAYER_NAMES"
      ],
      "lines_removed": [
        "    get_state_summary"
      ],
      "context_before": [
        "import json",
        "import sys",
        "sys.path.insert(0, '..')",
        "",
        "from cortical import CorticalTextProcessor, CorticalLayer",
        "from cortical.persistence import (",
        "    save_processor,",
        "    load_processor,",
        "    export_graph_json,",
        "    export_embeddings_json,"
      ],
      "context_after": [
        ")",
        "from cortical.embeddings import compute_graph_embeddings",
        "",
        "",
        "class TestSaveLoad(unittest.TestCase):",
        "    \"\"\"Test save and load functionality.\"\"\"",
        "",
        "    def test_save_and_load(self):",
        "        \"\"\"Test saving and loading processor state.\"\"\"",
        "        processor = CorticalTextProcessor()"
      ],
      "change_type": "modify"
    },
    {
      "file": "tests/test_persistence.py",
      "function": "class TestGetStateSummary(unittest.TestCase):",
      "start_line": 329,
      "lines_added": [
        "class TestExportConceptNetJSON(unittest.TestCase):",
        "    \"\"\"Test ConceptNet-style graph export.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        \"\"\"Set up processor with sample data.\"\"\"",
        "        cls.processor = CorticalTextProcessor()",
        "        cls.processor.process_document(\"doc1\", \"\"\"",
        "            Neural networks are a type of machine learning model.",
        "            Deep learning uses neural networks for pattern recognition.",
        "        \"\"\")",
        "        cls.processor.process_document(\"doc2\", \"\"\"",
        "            Machine learning algorithms process data efficiently.",
        "            Pattern recognition is used for image classification.",
        "        \"\"\")",
        "        cls.processor.compute_all(verbose=False)",
        "        cls.processor.extract_corpus_semantics(verbose=False)",
        "",
        "    def test_export_conceptnet_json_creates_file(self):",
        "        \"\"\"Test that export creates a JSON file.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            export_conceptnet_json(filepath, self.processor.layers, verbose=False)",
        "            self.assertTrue(os.path.exists(filepath))",
        "",
        "    def test_export_conceptnet_json_structure(self):",
        "        \"\"\"Test exported JSON structure.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(filepath, self.processor.layers, verbose=False)",
        "",
        "            self.assertIn('nodes', result)",
        "            self.assertIn('edges', result)",
        "            self.assertIn('metadata', result)",
        "",
        "            # Check metadata",
        "            self.assertIn('node_count', result['metadata'])",
        "            self.assertIn('edge_count', result['metadata'])",
        "            self.assertIn('layers', result['metadata'])",
        "            self.assertIn('edge_types', result['metadata'])",
        "            self.assertIn('relation_types', result['metadata'])",
        "",
        "    def test_export_conceptnet_json_node_structure(self):",
        "        \"\"\"Test node structure in exported JSON.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(filepath, self.processor.layers, verbose=False)",
        "",
        "            for node in result['nodes']:",
        "                self.assertIn('id', node)",
        "                self.assertIn('label', node)",
        "                self.assertIn('layer', node)",
        "                self.assertIn('layer_name', node)",
        "                self.assertIn('color', node)",
        "                self.assertIn('pagerank', node)",
        "                # Color should be valid hex",
        "                self.assertTrue(node['color'].startswith('#'))",
        "",
        "    def test_export_conceptnet_json_edge_structure(self):",
        "        \"\"\"Test edge structure in exported JSON.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(filepath, self.processor.layers, verbose=False)",
        "",
        "            for edge in result['edges']:",
        "                self.assertIn('source', edge)",
        "                self.assertIn('target', edge)",
        "                self.assertIn('weight', edge)",
        "                self.assertIn('relation_type', edge)",
        "                self.assertIn('edge_type', edge)",
        "                self.assertIn('color', edge)",
        "",
        "    def test_export_conceptnet_json_layer_colors(self):",
        "        \"\"\"Test that nodes have correct layer colors.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(filepath, self.processor.layers, verbose=False)",
        "",
        "            for node in result['nodes']:",
        "                layer = CorticalLayer(node['layer'])",
        "                expected_color = LAYER_COLORS.get(layer, '#808080')",
        "                self.assertEqual(node['color'], expected_color)",
        "",
        "    def test_export_conceptnet_json_with_semantic_relations(self):",
        "        \"\"\"Test export with semantic relations included.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(",
        "                filepath,",
        "                self.processor.layers,",
        "                semantic_relations=self.processor.semantic_relations,",
        "                verbose=False",
        "            )",
        "",
        "            # Should have edges",
        "            self.assertGreater(len(result['edges']), 0)",
        "",
        "    def test_export_conceptnet_json_cross_layer_edges(self):",
        "        \"\"\"Test that cross-layer edges are included when requested.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(",
        "                filepath,",
        "                self.processor.layers,",
        "                include_cross_layer=True,",
        "                verbose=False",
        "            )",
        "",
        "            edge_types = result['metadata'].get('edge_types', {})",
        "            # May have cross_layer edges if there are feedforward/feedback connections",
        "            self.assertIsInstance(edge_types, dict)",
        "",
        "    def test_export_conceptnet_json_no_cross_layer(self):",
        "        \"\"\"Test export without cross-layer edges.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(",
        "                filepath,",
        "                self.processor.layers,",
        "                include_cross_layer=False,",
        "                verbose=False",
        "            )",
        "",
        "            # No cross_layer edges should be present",
        "            cross_layer_count = result['metadata'].get('edge_types', {}).get('cross_layer', 0)",
        "            self.assertEqual(cross_layer_count, 0)",
        "",
        "    def test_export_conceptnet_json_max_nodes(self):",
        "        \"\"\"Test limiting nodes per layer.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(",
        "                filepath,",
        "                self.processor.layers,",
        "                max_nodes_per_layer=5,",
        "                verbose=False",
        "            )",
        "",
        "            # Count nodes per layer",
        "            layer_counts = {}",
        "            for node in result['nodes']:",
        "                layer = node['layer']",
        "                layer_counts[layer] = layer_counts.get(layer, 0) + 1",
        "",
        "            # Each layer should have at most 5 nodes",
        "            for layer, count in layer_counts.items():",
        "                self.assertLessEqual(count, 5)",
        "",
        "    def test_export_conceptnet_json_min_weight(self):",
        "        \"\"\"Test filtering edges by minimum weight.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = export_conceptnet_json(",
        "                filepath,",
        "                self.processor.layers,",
        "                min_weight=0.5,",
        "                verbose=False",
        "            )",
        "",
        "            for edge in result['edges']:",
        "                self.assertGreaterEqual(edge['weight'], 0.5)",
        "",
        "    def test_layer_colors_constant(self):",
        "        \"\"\"Test that LAYER_COLORS constant is defined.\"\"\"",
        "        self.assertIn(CorticalLayer.TOKENS, LAYER_COLORS)",
        "        self.assertIn(CorticalLayer.BIGRAMS, LAYER_COLORS)",
        "        self.assertIn(CorticalLayer.CONCEPTS, LAYER_COLORS)",
        "        self.assertIn(CorticalLayer.DOCUMENTS, LAYER_COLORS)",
        "",
        "    def test_layer_names_constant(self):",
        "        \"\"\"Test that LAYER_NAMES constant is defined.\"\"\"",
        "        self.assertIn(CorticalLayer.TOKENS, LAYER_NAMES)",
        "        self.assertEqual(LAYER_NAMES[CorticalLayer.TOKENS], 'Tokens')",
        "        self.assertEqual(LAYER_NAMES[CorticalLayer.BIGRAMS], 'Bigrams')",
        "",
        "    def test_processor_export_conceptnet_json(self):",
        "        \"\"\"Test processor-level export method.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            filepath = os.path.join(tmpdir, \"conceptnet.json\")",
        "            result = self.processor.export_conceptnet_json(filepath, verbose=False)",
        "",
        "            self.assertIn('nodes', result)",
        "            self.assertIn('edges', result)",
        "            self.assertTrue(os.path.exists(filepath))",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "",
        "    def test_get_state_summary_empty(self):",
        "        \"\"\"Test summary for empty processor.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "",
        "        summary = get_state_summary(processor.layers, processor.documents)",
        "",
        "        self.assertEqual(summary['documents'], 0)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main(verbosity=2)"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 0,
  "day_of_week": "Wednesday",
  "seconds_since_last_commit": -480023,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}