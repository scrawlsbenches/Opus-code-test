{
  "hash": "4e113e74f0302f263b3736bc66bdba3f04bc6646",
  "message": "Add multi-hop semantic inference (Tasks 25-26)",
  "author": "Claude",
  "timestamp": "2025-12-10 00:14:21 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "TASK_LIST.md",
    "cortical/processor.py",
    "cortical/query.py",
    "tests/test_processor.py"
  ],
  "insertions": 521,
  "deletions": 23,
  "hunks": [
    {
      "file": "TASK_LIST.md",
      "function": "semantic_edges = col.get_connections_by_source('semantic')",
      "start_line": 809,
      "lines_added": [
        "**Files:** `cortical/query.py`, `cortical/processor.py`",
        "**Status:** [x] Completed",
        "**Solution Applied:**",
        "1. Added `VALID_RELATION_CHAINS` constant to `query.py` defining valid relation chain patterns with validity scores:",
        "   - Transitive hierarchies: IsA→IsA (1.0), PartOf→PartOf (1.0), IsA→HasProperty (0.9)",
        "   - Association chains: RelatedTo→RelatedTo (0.6), SimilarTo→SimilarTo (0.7)",
        "   - Causal chains: Causes→Causes (0.8), Causes→HasProperty (0.7)",
        "   - Invalid chains: Antonym→IsA (0.1) - contradictory",
        "2. Added `score_relation_path()` function to compute path validity scores",
        "3. Added `expand_query_multihop()` function (~90 lines) implementing:",
        "   - BFS-style expansion with hop tracking",
        "   - Weight decay by hop distance: `weight *= decay_factor ** hop`",
        "   - Path validity filtering with `min_path_score` threshold",
        "   - Configurable parameters: `max_hops`, `max_expansions`, `decay_factor`, `min_path_score`",
        "4. Added `expand_query_multihop()` method to processor with fallback to regular expansion",
        "**Files Modified:**",
        "- `cortical/query.py` - Added `VALID_RELATION_CHAINS`, `score_relation_path()`, `expand_query_multihop()` (~150 lines)",
        "- `cortical/processor.py` - Added processor wrapper method (~45 lines)",
        "- `tests/test_processor.py` - Added 18 tests for multi-hop inference and path scoring",
        "",
        "**Usage:**",
        "# Extract semantic relations first",
        "processor.extract_corpus_semantics()",
        "",
        "# Multi-hop expansion (finds 2-hop away terms)",
        "expanded = processor.expand_query_multihop(\"neural\", max_hops=2)",
        "",
        "# Custom parameters",
        "expanded = processor.expand_query_multihop(",
        "    \"neural\",",
        "    max_hops=3,           # Follow up to 3 hops",
        "    decay_factor=0.6,     # Slower weight decay",
        "    min_path_score=0.3,   # Filter low-validity paths",
        "    max_expansions=20     # More expansion terms",
        ")",
        "**Files:** `cortical/query.py`",
        "**Status:** [x] Completed (implemented with Task 25)",
        "**Solution Applied (with Task 25):**",
        "1. Added `VALID_RELATION_CHAINS` dict defining allowed transitions with validity scores:",
        "   - Transitive: (IsA, IsA)=1.0, (PartOf, PartOf)=1.0",
        "   - Property inheritance: (IsA, HasProperty)=0.9, (PartOf, HasProperty)=0.8",
        "   - Association: (RelatedTo, RelatedTo)=0.6, (SimilarTo, SimilarTo)=0.7",
        "   - Invalid: (Antonym, IsA)=0.1",
        "2. Added `score_relation_path()` function that multiplies consecutive pair validities",
        "3. Default validity score of 0.4 for unknown relation pairs",
        "4. Integrated into `expand_query_multihop()` with `min_path_score` parameter",
        "",
        "**Files Modified:**",
        "- `cortical/query.py` - Added constants and scoring function (~50 lines)",
        "- `tests/test_processor.py` - Added 7 tests in `TestMultiHopPathScoring` class",
        "",
        "**Usage:**",
        "```python",
        "from cortical.query import score_relation_path, VALID_RELATION_CHAINS",
        "",
        "# Score a relation path",
        "score = score_relation_path(['IsA', 'IsA'])  # 1.0 (transitive)",
        "score = score_relation_path(['IsA', 'HasProperty'])  # 0.9 (property inheritance)",
        "score = score_relation_path(['Antonym', 'IsA'])  # 0.1 (contradictory)",
        "",
        "# Check valid chain patterns",
        "print(VALID_RELATION_CHAINS[('IsA', 'IsA')])  # 1.0",
        "```"
      ],
      "lines_removed": [
        "**Files:** `cortical/query.py`, `cortical/semantics.py`",
        "**Status:** [ ] Pending",
        "**Implementation Steps:**",
        "1. Add `expand_query_multihop()` function to `query.py`",
        "2. Follow relation chains up to `max_hops` (default: 2)",
        "3. Decay weight by hop distance: `weight *= 0.5 ** hop`",
        "4. Filter by relation path validity (IsA chains are good, random walks less so)",
        "5. Use for enhanced document retrieval",
        "**Example:**",
        "expand_query_multihop(\"neural\", max_hops=2)",
        "**Files:** `cortical/semantics.py`",
        "**Status:** [ ] Pending",
        "**Implementation Steps:**",
        "1. Create `VALID_RELATION_CHAINS` matrix defining allowed transitions",
        "2. Add `score_relation_path()` function",
        "3. Penalize invalid transitions, reward coherent chains",
        "4. Use in multi-hop expansion to filter low-quality paths"
      ],
      "context_before": [
        "edge = col.get_typed_connection(\"L0_network\")",
        "print(f\"{edge.relation_type}: {edge.weight} ({edge.confidence})\")",
        "```",
        "",
        "---",
        "",
        "## ConceptNet Medium Priority",
        "",
        "### 25. Implement Multi-Hop Semantic Inference",
        ""
      ],
      "context_after": [
        "",
        "**Problem:**",
        "Query expansion only follows single-hop connections. ConceptNet enables multi-hop inference:",
        "- \"dog\" → IsA → \"animal\" → HasProperty → \"living\"",
        "- \"car\" → PartOf → \"engine\" → UsedFor → \"transportation\"",
        "",
        "",
        "```python",
        "# Hop 1: networks (co-occur), learning (co-occur), brain (RelatedTo)",
        "# Hop 2: deep (via learning), cortex (via brain), AI (via networks)",
        "```",
        "",
        "---",
        "",
        "### 26. Add Relation Path Scoring",
        "",
        "",
        "**Problem:**",
        "Not all relation paths are equally valid for inference. Need to score paths by semantic coherence.",
        "",
        "**Valid Paths:**",
        "- IsA → IsA (transitive hypernymy): \"poodle\" → \"dog\" → \"animal\" ✓",
        "- PartOf → HasA (part inheritance): \"wheel\" → \"car\" → \"engine\" ✓",
        "- RelatedTo → RelatedTo (association): loose but acceptable",
        "",
        "**Invalid Paths:**",
        "- Antonym → IsA: contradictory",
        "- Random oscillation: low confidence",
        "",
        "",
        "---",
        "",
        "### 27. Implement Concept Inheritance",
        "",
        "**Files:** `cortical/analysis.py`, `cortical/semantics.py`",
        "**Status:** [ ] Pending",
        "",
        "**Problem:**",
        "IsA relations should enable property inheritance. If \"dog IsA animal\" and \"animal HasProperty living\", then \"dog\" should inherit \"living\"."
      ],
      "change_type": "modify"
    },
    {
      "file": "TASK_LIST.md",
      "function": "Semantic bonus is capped at 50% boost (`min(avg_semantic, 0.5)`). This is a reas",
      "start_line": 1014,
      "lines_added": [
        "| Medium | Implement multi-hop semantic inference | ✅ Completed | ConceptNet |",
        "| Medium | Add relation path scoring | ✅ Completed | ConceptNet |",
        "**ConceptNet Enhancement Completion:** 8/12 tasks (67%)",
        "Ran 255 tests in 0.196s",
        "All tests passing as of 2025-12-10.",
        "*Updated from code review on 2025-12-10*"
      ],
      "lines_removed": [
        "| Medium | Implement multi-hop semantic inference | ⏳ Pending | ConceptNet |",
        "| Medium | Add relation path scoring | ⏳ Pending | ConceptNet |",
        "**ConceptNet Enhancement Completion:** 6/12 tasks (50%)",
        "Ran 237 tests in 0.205s",
        "All tests passing as of 2025-12-09.",
        "*Updated from code review on 2025-12-09*"
      ],
      "context_before": [
        "| Medium | Add incremental indexing | ✅ Completed | RAG |",
        "| Low | Document magic numbers | ⏳ Deferred | Documentation |",
        "| Low | Multi-stage ranking pipeline | ✅ Completed | RAG |",
        "| Low | Batch query API | ✅ Completed | RAG |",
        "| **Critical** | **Build cross-layer feedforward connections** | ✅ Completed | **ConceptNet** |",
        "| **Critical** | **Add concept-level lateral connections** | ✅ Completed | **ConceptNet** |",
        "| **Critical** | **Add bigram lateral connections** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Implement relation-weighted PageRank** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Implement cross-layer PageRank propagation** | ✅ Completed | **ConceptNet** |",
        "| **High** | **Add typed edge storage** | ✅ Completed | **ConceptNet** |"
      ],
      "context_after": [
        "| Medium | Implement concept inheritance | ⏳ Pending | ConceptNet |",
        "| Low | Add commonsense relation extraction | ⏳ Pending | ConceptNet |",
        "| Low | Visualize ConceptNet-style graph | ⏳ Pending | ConceptNet |",
        "| Low | Add analogy completion | ⏳ Pending | ConceptNet |",
        "",
        "**Bug Fix Completion:** 7/7 tasks (100%)",
        "**RAG Enhancement Completion:** 8/8 tasks (100%)",
        "",
        "---",
        "",
        "## Test Results",
        "",
        "```",
        "OK",
        "```",
        "",
        "",
        "---",
        ""
      ],
      "change_type": "modify"
    },
    {
      "file": "cortical/processor.py",
      "function": "class CorticalTextProcessor:",
      "start_line": 725,
      "lines_added": [
        "",
        "    def expand_query_multihop(",
        "        self,",
        "        query_text: str,",
        "        max_hops: int = 2,",
        "        max_expansions: int = 15,",
        "        decay_factor: float = 0.5,",
        "        min_path_score: float = 0.2",
        "    ) -> Dict[str, float]:",
        "        \"\"\"",
        "        Expand query using multi-hop semantic inference.",
        "",
        "        Unlike single-hop expansion that only follows direct connections,",
        "        this follows relation chains to discover semantically related terms",
        "        through transitive relationships.",
        "",
        "        Example inference chains:",
        "            \"dog\" → IsA → \"animal\" → HasProperty → \"living\"",
        "            \"neural\" → RelatedTo → \"network\" → RelatedTo → \"deep\"",
        "",
        "        Args:",
        "            query_text: Original query string",
        "            max_hops: Maximum number of relation hops (default: 2)",
        "            max_expansions: Maximum expansion terms to return",
        "            decay_factor: Weight decay per hop (default: 0.5, so hop2 = 0.25)",
        "            min_path_score: Minimum path validity score to include (default: 0.2)",
        "",
        "        Returns:",
        "            Dict mapping terms to weights (original terms get weight 1.0,",
        "            expansions get decayed weights based on hop distance and path validity)",
        "",
        "        Example:",
        "            >>> # Extract semantic relations first",
        "            >>> processor.extract_corpus_semantics()",
        "            >>>",
        "            >>> # Multi-hop expansion",
        "            >>> expanded = processor.expand_query_multihop(\"neural\", max_hops=2)",
        "            >>> for term, weight in sorted(expanded.items(), key=lambda x: -x[1]):",
        "            ...     print(f\"{term}: {weight:.3f}\")",
        "        \"\"\"",
        "        if not self.semantic_relations:",
        "            # Fall back to regular expansion if no semantic relations",
        "            return self.expand_query(query_text, max_expansions=max_expansions)",
        "",
        "        return query_module.expand_query_multihop(",
        "            query_text,",
        "            self.layers,",
        "            self.tokenizer,",
        "            self.semantic_relations,",
        "            max_hops=max_hops,",
        "            max_expansions=max_expansions,",
        "            decay_factor=decay_factor,",
        "            min_path_score=min_path_score",
        "        )"
      ],
      "lines_removed": [],
      "context_before": [
        "        return emb_module.embedding_similarity(self.embeddings, term1, term2)",
        "    ",
        "    def find_similar_by_embedding(self, term: str, top_n: int = 10) -> List[Tuple[str, float]]:",
        "        return emb_module.find_similar_by_embedding(self.embeddings, term, top_n)",
        "    ",
        "    def expand_query(self, query_text: str, max_expansions: int = 10, use_variants: bool = True, verbose: bool = False) -> Dict[str, float]:",
        "        return query_module.expand_query(query_text, self.layers, self.tokenizer, max_expansions=max_expansions, use_variants=use_variants)",
        "    ",
        "    def expand_query_semantic(self, query_text: str, max_expansions: int = 10) -> Dict[str, float]:",
        "        return query_module.expand_query_semantic(query_text, self.layers, self.tokenizer, self.semantic_relations, max_expansions)"
      ],
      "context_after": [
        "    ",
        "    def find_documents_for_query(",
        "        self,",
        "        query_text: str,",
        "        top_n: int = 5,",
        "        use_expansion: bool = True,",
        "        use_semantic: bool = True",
        "    ) -> List[Tuple[str, float]]:",
        "        \"\"\"",
        "        Find documents most relevant to a query."
      ],
      "change_type": "add"
    },
    {
      "file": "cortical/query.py",
      "function": "def expand_query(",
      "start_line": 117,
      "lines_added": [
        "# Valid relation chain patterns for multi-hop inference",
        "# Key: (relation1, relation2) → validity score (0.0 = invalid, 1.0 = fully valid)",
        "VALID_RELATION_CHAINS = {",
        "    # Transitive hierarchies",
        "    ('IsA', 'IsA'): 1.0,           # dog IsA animal IsA living_thing",
        "    ('PartOf', 'PartOf'): 1.0,     # wheel PartOf car PartOf vehicle",
        "    ('IsA', 'HasProperty'): 0.9,   # dog IsA animal HasProperty alive",
        "    ('PartOf', 'HasProperty'): 0.8,  # wheel PartOf car HasProperty fast",
        "",
        "    # Association chains",
        "    ('RelatedTo', 'RelatedTo'): 0.6,",
        "    ('SimilarTo', 'SimilarTo'): 0.7,",
        "    ('CoOccurs', 'CoOccurs'): 0.5,",
        "    ('RelatedTo', 'IsA'): 0.7,",
        "    ('RelatedTo', 'SimilarTo'): 0.7,",
        "",
        "    # Causal chains",
        "    ('Causes', 'Causes'): 0.8,",
        "    ('Causes', 'HasProperty'): 0.7,",
        "",
        "    # Derivation chains",
        "    ('DerivedFrom', 'DerivedFrom'): 0.8,",
        "    ('DerivedFrom', 'IsA'): 0.7,",
        "",
        "    # Usage chains",
        "    ('UsedFor', 'UsedFor'): 0.6,",
        "    ('UsedFor', 'RelatedTo'): 0.5,",
        "",
        "    # Antonym - generally invalid for chaining",
        "    ('Antonym', 'Antonym'): 0.3,   # Double negation, weak",
        "    ('Antonym', 'IsA'): 0.1,       # Contradictory",
        "}",
        "",
        "",
        "def score_relation_path(path: List[str]) -> float:",
        "    \"\"\"",
        "    Score a relation path by its semantic coherence.",
        "",
        "    Args:",
        "        path: List of relation types traversed (e.g., ['IsA', 'HasProperty'])",
        "",
        "    Returns:",
        "        Score from 0.0 (invalid) to 1.0 (fully valid)",
        "    \"\"\"",
        "    if not path:",
        "        return 1.0",
        "    if len(path) == 1:",
        "        return 1.0",
        "",
        "    # Compute score as product of consecutive pair validities",
        "    total_score = 1.0",
        "    for i in range(len(path) - 1):",
        "        pair = (path[i], path[i + 1])",
        "        # Check both orderings",
        "        pair_score = VALID_RELATION_CHAINS.get(pair, 0.4)  # Default: moderate validity",
        "        total_score *= pair_score",
        "",
        "    return total_score",
        "",
        "",
        "def expand_query_multihop(",
        "    query_text: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    tokenizer: Tokenizer,",
        "    semantic_relations: List[Tuple[str, str, str, float]],",
        "    max_hops: int = 2,",
        "    max_expansions: int = 15,",
        "    decay_factor: float = 0.5,",
        "    min_path_score: float = 0.2",
        ") -> Dict[str, float]:",
        "    \"\"\"",
        "    Expand query using multi-hop semantic inference.",
        "",
        "    Unlike single-hop expansion that only follows direct connections,",
        "    this follows relation chains to discover semantically related terms",
        "    through transitive relationships.",
        "",
        "    Example inference chains:",
        "        \"dog\" → IsA → \"animal\" → HasProperty → \"living\"",
        "        \"car\" → PartOf → \"engine\" → UsedFor → \"transportation\"",
        "",
        "    Args:",
        "        query_text: Original query string",
        "        layers: Dictionary of layers (needs TOKENS)",
        "        tokenizer: Tokenizer instance",
        "        semantic_relations: List of (term1, relation, term2, weight) tuples",
        "        max_hops: Maximum number of relation hops (default: 2)",
        "        max_expansions: Maximum expansion terms to return",
        "        decay_factor: Weight decay per hop (default: 0.5, so hop2 = 0.25)",
        "        min_path_score: Minimum path validity score to include (default: 0.2)",
        "",
        "    Returns:",
        "        Dict mapping terms to weights (original terms get weight 1.0,",
        "        expansions get decayed weights based on hop distance and path validity)",
        "",
        "    Example:",
        "        >>> expanded = expand_query_multihop(\"neural\", layers, tokenizer, relations)",
        "        >>> # Hop 1: networks (co-occur), learning (co-occur), brain (RelatedTo)",
        "        >>> # Hop 2: deep (via learning), cortex (via brain), AI (via networks)",
        "    \"\"\"",
        "    tokens = tokenizer.tokenize(query_text)",
        "    layer0 = layers[CorticalLayer.TOKENS]",
        "",
        "    # Start with original terms at full weight",
        "    expanded: Dict[str, float] = {}",
        "    for token in tokens:",
        "        if layer0.get_minicolumn(token):",
        "            expanded[token] = 1.0",
        "",
        "    if not expanded or not semantic_relations:",
        "        return expanded",
        "",
        "    # Build bidirectional neighbor lookup with relation types",
        "    # neighbors[term] = [(neighbor, relation_type, weight), ...]",
        "    neighbors: Dict[str, List[Tuple[str, str, float]]] = defaultdict(list)",
        "    for t1, relation, t2, weight in semantic_relations:",
        "        neighbors[t1].append((t2, relation, weight))",
        "        neighbors[t2].append((t1, relation, weight))",
        "",
        "    # Track expansions with their hop distance, weight, and relation path",
        "    # (term, weight, hop, relation_path)",
        "    candidates: Dict[str, Tuple[float, int, List[str]]] = {}",
        "",
        "    # BFS-style expansion with hop tracking",
        "    # frontier: [(term, current_weight, hop_count, relation_path)]",
        "    frontier: List[Tuple[str, float, int, List[str]]] = [",
        "        (term, 1.0, 0, []) for term in expanded.keys()",
        "    ]",
        "",
        "    visited_at_hop: Dict[str, int] = {term: 0 for term in expanded.keys()}",
        "",
        "    while frontier:",
        "        current_term, current_weight, hop, path = frontier.pop(0)",
        "",
        "        if hop >= max_hops:",
        "            continue",
        "",
        "        next_hop = hop + 1",
        "",
        "        for neighbor, relation, rel_weight in neighbors.get(current_term, []):",
        "            # Skip if already in original query terms",
        "            if neighbor in expanded:",
        "                continue",
        "",
        "            # Check if term exists in corpus",
        "            if not layer0.get_minicolumn(neighbor):",
        "                continue",
        "",
        "            # Skip if we've visited this term at an earlier or equal hop",
        "            if neighbor in visited_at_hop and visited_at_hop[neighbor] <= next_hop:",
        "                continue",
        "",
        "            # Compute new path and its validity",
        "            new_path = path + [relation]",
        "            path_score = score_relation_path(new_path)",
        "",
        "            if path_score < min_path_score:",
        "                continue",
        "",
        "            # Compute weight with decay and path validity",
        "            # weight = base_weight * relation_weight * decay^hop * path_validity",
        "            hop_decay = decay_factor ** next_hop",
        "            new_weight = current_weight * rel_weight * hop_decay * path_score",
        "",
        "            # Update candidate if this path gives higher weight",
        "            if neighbor not in candidates or candidates[neighbor][0] < new_weight:",
        "                candidates[neighbor] = (new_weight, next_hop, new_path)",
        "                visited_at_hop[neighbor] = next_hop",
        "",
        "                # Add to frontier for further expansion",
        "                if next_hop < max_hops:",
        "                    frontier.append((neighbor, new_weight, next_hop, new_path))",
        "",
        "    # Sort candidates by weight and take top expansions",
        "    sorted_candidates = sorted(",
        "        candidates.items(),",
        "        key=lambda x: x[1][0],  # Sort by weight",
        "        reverse=True",
        "    )[:max_expansions]",
        "",
        "    # Add to expanded dict",
        "    for term, (weight, hop, path) in sorted_candidates:",
        "        expanded[term] = weight",
        "",
        "    return expanded",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        key=lambda x: x[1],",
        "        reverse=True",
        "    )[:max_expansions]",
        "    ",
        "    for term, score in sorted_candidates:",
        "        expanded[term] = score",
        "    ",
        "    return expanded",
        "",
        ""
      ],
      "context_after": [
        "def expand_query_semantic(",
        "    query_text: str,",
        "    layers: Dict[CorticalLayer, HierarchicalLayer],",
        "    tokenizer: Tokenizer,",
        "    semantic_relations: List[Tuple[str, str, str, float]],",
        "    max_expansions: int = 10",
        ") -> Dict[str, float]:",
        "    \"\"\"",
        "    Expand query using semantic relations extracted from corpus.",
        "    "
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_processor.py",
      "function": "class TestHierarchicalPageRank(unittest.TestCase):",
      "start_line": 1643,
      "lines_added": [
        "class TestMultiHopSemanticInference(unittest.TestCase):",
        "    \"\"\"Test multi-hop semantic inference query expansion.\"\"\"",
        "",
        "    @classmethod",
        "    def setUpClass(cls):",
        "        \"\"\"Set up processor with documents for multi-hop testing.\"\"\"",
        "        cls.processor = CorticalTextProcessor()",
        "        # Create a corpus with semantic chain potential",
        "        cls.processor.process_document(",
        "            \"doc1\",",
        "            \"Neural networks are a type of machine learning model. \"",
        "            \"Deep learning uses neural networks for complex pattern recognition.\"",
        "        )",
        "        cls.processor.process_document(",
        "            \"doc2\",",
        "            \"Machine learning algorithms process data efficiently. \"",
        "            \"Pattern recognition is important for image classification.\"",
        "        )",
        "        cls.processor.process_document(",
        "            \"doc3\",",
        "            \"Deep learning is part of artificial intelligence research. \"",
        "            \"Image classification improves with more training data.\"",
        "        )",
        "        cls.processor.process_document(",
        "            \"doc4\",",
        "            \"Artificial intelligence systems can learn from examples. \"",
        "            \"Training data is essential for model accuracy.\"",
        "        )",
        "        cls.processor.compute_all(verbose=False)",
        "        cls.processor.extract_corpus_semantics(verbose=False)",
        "",
        "    def test_expand_query_multihop_returns_dict(self):",
        "        \"\"\"Test that expand_query_multihop returns a dictionary.\"\"\"",
        "        expanded = self.processor.expand_query_multihop(\"neural\", max_hops=2)",
        "        self.assertIsInstance(expanded, dict)",
        "",
        "    def test_original_terms_weight_one(self):",
        "        \"\"\"Test that original query terms have weight 1.0.\"\"\"",
        "        expanded = self.processor.expand_query_multihop(\"neural networks\", max_hops=2)",
        "        self.assertEqual(expanded.get(\"neural\"), 1.0)",
        "        self.assertEqual(expanded.get(\"networks\"), 1.0)",
        "",
        "    def test_hop_1_expansions(self):",
        "        \"\"\"Test that single-hop expansions are included.\"\"\"",
        "        expanded = self.processor.expand_query_multihop(\"neural\", max_hops=1)",
        "",
        "        # Should have original term",
        "        self.assertIn(\"neural\", expanded)",
        "",
        "        # Should have some expansions (semantically related terms)",
        "        expansion_count = len([k for k in expanded if k != \"neural\"])",
        "        self.assertGreater(expansion_count, 0, \"Should have at least one expansion\")",
        "",
        "    def test_hop_2_expansions(self):",
        "        \"\"\"Test that two-hop expansions discover more terms.\"\"\"",
        "        expanded_1hop = self.processor.expand_query_multihop(\"neural\", max_hops=1)",
        "        expanded_2hop = self.processor.expand_query_multihop(\"neural\", max_hops=2)",
        "",
        "        # 2-hop should have >= terms than 1-hop",
        "        self.assertGreaterEqual(len(expanded_2hop), len(expanded_1hop))",
        "",
        "    def test_weight_decay_with_hops(self):",
        "        \"\"\"Test that expansion weights decay with hop distance.\"\"\"",
        "        expanded = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, decay_factor=0.5",
        "        )",
        "",
        "        # Original term should have weight 1.0",
        "        self.assertEqual(expanded.get(\"neural\"), 1.0)",
        "",
        "        # All expansions should have weight < 1.0",
        "        for term, weight in expanded.items():",
        "            if term != \"neural\":",
        "                self.assertLess(",
        "                    weight, 1.0,",
        "                    f\"Expansion '{term}' should have weight < 1.0, got {weight}\"",
        "                )",
        "",
        "    def test_custom_decay_factor(self):",
        "        \"\"\"Test that custom decay factor affects weights.\"\"\"",
        "        expanded_slow = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, decay_factor=0.8  # Slower decay",
        "        )",
        "        expanded_fast = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, decay_factor=0.3  # Faster decay",
        "        )",
        "",
        "        # Slower decay should give higher average weights to expansions",
        "        slow_avg = sum(w for t, w in expanded_slow.items() if t != \"neural\")",
        "        fast_avg = sum(w for t, w in expanded_fast.items() if t != \"neural\")",
        "",
        "        # If both have expansions, slow decay should have higher total",
        "        if slow_avg > 0 and fast_avg > 0:",
        "            self.assertGreater(slow_avg, fast_avg)",
        "",
        "    def test_max_expansions_limit(self):",
        "        \"\"\"Test that max_expansions limits the number of expansion terms.\"\"\"",
        "        expanded_3 = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, max_expansions=3",
        "        )",
        "        expanded_10 = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, max_expansions=10",
        "        )",
        "",
        "        # Count expansions (non-original terms)",
        "        expansions_3 = len([k for k in expanded_3 if k != \"neural\"])",
        "        expansions_10 = len([k for k in expanded_10 if k != \"neural\"])",
        "",
        "        self.assertLessEqual(expansions_3, 3)",
        "        self.assertLessEqual(expansions_10, 10)",
        "",
        "    def test_no_semantic_relations_fallback(self):",
        "        \"\"\"Test fallback to regular expansion when no semantic relations.\"\"\"",
        "        processor = CorticalTextProcessor()",
        "        processor.process_document(\"doc1\", \"Neural networks process data.\")",
        "        processor.compute_all(verbose=False)",
        "        # Don't extract semantic relations",
        "",
        "        expanded = processor.expand_query_multihop(\"neural\", max_hops=2)",
        "",
        "        # Should fall back to regular expansion",
        "        self.assertIn(\"neural\", expanded)",
        "",
        "    def test_unknown_query_term(self):",
        "        \"\"\"Test handling of query terms not in corpus.\"\"\"",
        "        expanded = self.processor.expand_query_multihop(\"xyznonexistent\", max_hops=2)",
        "",
        "        # Should return empty dict for unknown terms",
        "        self.assertEqual(len(expanded), 0)",
        "",
        "    def test_min_path_score_filtering(self):",
        "        \"\"\"Test that min_path_score filters low-validity paths.\"\"\"",
        "        expanded_low = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, min_path_score=0.1  # Low threshold",
        "        )",
        "        expanded_high = self.processor.expand_query_multihop(",
        "            \"neural\", max_hops=2, min_path_score=0.8  # High threshold",
        "        )",
        "",
        "        # Low threshold should allow more expansions",
        "        self.assertGreaterEqual(len(expanded_low), len(expanded_high))",
        "",
        "    def test_multihop_integration_with_documents(self):",
        "        \"\"\"Test that multi-hop expansion finds relevant documents.\"\"\"",
        "        # Use multi-hop expansion to find documents",
        "        expanded = self.processor.expand_query_multihop(\"neural\", max_hops=2)",
        "",
        "        # Use expanded terms to score documents",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "        doc_scores = {}",
        "",
        "        for term, weight in expanded.items():",
        "            col = layer0.get_minicolumn(term)",
        "            if col:",
        "                for doc_id in col.document_ids:",
        "                    doc_scores[doc_id] = doc_scores.get(doc_id, 0) + weight * col.tfidf",
        "",
        "        # Should find at least doc1 which contains \"neural\"",
        "        self.assertIn(\"doc1\", doc_scores)",
        "",
        "",
        "class TestMultiHopPathScoring(unittest.TestCase):",
        "    \"\"\"Test relation path scoring for multi-hop inference.\"\"\"",
        "",
        "    def test_score_relation_path_empty(self):",
        "        \"\"\"Test scoring empty path.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        self.assertEqual(score_relation_path([]), 1.0)",
        "",
        "    def test_score_relation_path_single(self):",
        "        \"\"\"Test scoring single-hop path.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        self.assertEqual(score_relation_path(['IsA']), 1.0)",
        "        self.assertEqual(score_relation_path(['RelatedTo']), 1.0)",
        "",
        "    def test_score_isa_chain(self):",
        "        \"\"\"Test that IsA chains get high scores.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        # IsA → IsA is a valid transitive chain",
        "        score = score_relation_path(['IsA', 'IsA'])",
        "        self.assertEqual(score, 1.0)",
        "",
        "    def test_score_mixed_chain(self):",
        "        \"\"\"Test scoring mixed relation chains.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        # IsA → HasProperty is a valid inference",
        "        score = score_relation_path(['IsA', 'HasProperty'])",
        "        self.assertGreater(score, 0.8)",
        "",
        "    def test_score_weak_chain(self):",
        "        \"\"\"Test that weak chains get low scores.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        # Antonym → IsA is contradictory",
        "        score = score_relation_path(['Antonym', 'IsA'])",
        "        self.assertLess(score, 0.3)",
        "",
        "    def test_score_default_relation(self):",
        "        \"\"\"Test scoring unknown relation pairs.\"\"\"",
        "        from cortical.query import score_relation_path",
        "        # Unknown pair should get moderate default score",
        "        score = score_relation_path(['UnknownRel', 'AnotherUnknown'])",
        "        self.assertEqual(score, 0.4)  # Default moderate validity",
        "",
        "    def test_valid_relation_chains_constant(self):",
        "        \"\"\"Test that VALID_RELATION_CHAINS is defined.\"\"\"",
        "        from cortical.query import VALID_RELATION_CHAINS",
        "        self.assertIsInstance(VALID_RELATION_CHAINS, dict)",
        "        self.assertIn(('IsA', 'IsA'), VALID_RELATION_CHAINS)",
        "        self.assertIn(('PartOf', 'PartOf'), VALID_RELATION_CHAINS)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        # Verify that tokens have feedback connections (to bigrams)",
        "        layer0 = self.processor.get_layer(CorticalLayer.TOKENS)",
        "",
        "        has_feedback = any(",
        "            col.feedback_connections",
        "            for col in layer0.minicolumns.values()",
        "        )",
        "        self.assertTrue(has_feedback, \"Tokens should have feedback connections to bigrams\")",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == \"__main__\":",
        "    unittest.main(verbosity=2)"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 0,
  "day_of_week": "Wednesday",
  "seconds_since_last_commit": -480627,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}