{
  "hash": "e619be381b0250c9e975f9e1ddc7f2b8442ef598",
  "message": "Add compound commands and task checkpointing",
  "author": "Claude",
  "timestamp": "2025-12-11 17:20:05 +0000",
  "branch": "claude/multi-index-design-DvifZ",
  "files_changed": [
    "cortical/cli_wrapper.py",
    "tests/test_cli_wrapper.py"
  ],
  "insertions": 321,
  "deletions": 0,
  "hunks": [
    {
      "file": "cortical/cli_wrapper.py",
      "function": "class Session:",
      "start_line": 962,
      "lines_added": [
        "",
        "",
        "# =============================================================================",
        "# Compound Commands (things I actually use)",
        "# =============================================================================",
        "",
        "def test_then_commit(",
        "    test_cmd: Union[str, List[str]] = \"python -m unittest discover -s tests\",",
        "    message: str = \"Update\",",
        "    add_all: bool = True,",
        ") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Run tests, commit only if they pass.",
        "",
        "    Returns (success, [test_result, add_result?, commit_result?])",
        "",
        "    Example:",
        "        ok, results = test_then_commit(message=\"Fix auth bug\")",
        "        if ok:",
        "            print(\"Committed!\")",
        "        else:",
        "            print(f\"Tests failed: {results[0].stderr}\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    # Run tests",
        "    test_result = run(test_cmd)",
        "    results.append(test_result)",
        "",
        "    if not test_result.success:",
        "        return False, results",
        "",
        "    # Add files",
        "    if add_all:",
        "        add_result = run([\"git\", \"add\", \"-A\"], git=True)",
        "        results.append(add_result)",
        "        if not add_result.success:",
        "            return False, results",
        "",
        "    # Commit",
        "    commit_result = run([\"git\", \"commit\", \"-m\", message], git=True)",
        "    results.append(commit_result)",
        "",
        "    return commit_result.success, results",
        "",
        "",
        "def commit_and_push(",
        "    message: str,",
        "    add_all: bool = True,",
        "    branch: Optional[str] = None,",
        ") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Add, commit, and push in one go.",
        "",
        "    Example:",
        "        ok, _ = commit_and_push(\"Fix typo\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    if add_all:",
        "        add_result = run([\"git\", \"add\", \"-A\"], git=True)",
        "        results.append(add_result)",
        "        if not add_result.success:",
        "            return False, results",
        "",
        "    commit_result = run([\"git\", \"commit\", \"-m\", message], git=True)",
        "    results.append(commit_result)",
        "    if not commit_result.success:",
        "        return False, results",
        "",
        "    # Determine branch",
        "    if branch is None:",
        "        branch_result = run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"])",
        "        if branch_result.success:",
        "            branch = branch_result.stdout.strip()",
        "        else:",
        "            branch = \"HEAD\"",
        "",
        "    push_result = run([\"git\", \"push\", \"-u\", \"origin\", branch], git=True)",
        "    results.append(push_result)",
        "",
        "    return push_result.success, results",
        "",
        "",
        "def sync_with_main(main_branch: str = \"main\") -> Tuple[bool, List[ExecutionContext]]:",
        "    \"\"\"",
        "    Fetch and rebase current branch on main.",
        "",
        "    Example:",
        "        ok, results = sync_with_main()",
        "        if not ok:",
        "            print(\"Rebase conflicts - resolve manually\")",
        "    \"\"\"",
        "    results = []",
        "",
        "    fetch_result = run([\"git\", \"fetch\", \"origin\", main_branch])",
        "    results.append(fetch_result)",
        "    if not fetch_result.success:",
        "        return False, results",
        "",
        "    rebase_result = run([\"git\", \"rebase\", f\"origin/{main_branch}\"])",
        "    results.append(rebase_result)",
        "",
        "    return rebase_result.success, results",
        "",
        "",
        "# =============================================================================",
        "# Context Checkpointing (for task switching)",
        "# =============================================================================",
        "",
        "class TaskCheckpoint:",
        "    \"\"\"",
        "    Save/restore context state when switching between tasks.",
        "",
        "    When you're working on Task A and need to switch to Task B,",
        "    checkpoint Task A so you can resume later with context intact.",
        "",
        "    Example:",
        "        checkpoint = TaskCheckpoint()",
        "",
        "        # Working on feature A",
        "        checkpoint.save(\"feature-a\", {",
        "            'branch': 'feature/auth',",
        "            'files_touched': ['auth.py', 'test_auth.py'],",
        "            'notes': 'Need to add token refresh logic',",
        "            'last_test_passed': True,",
        "        })",
        "",
        "        # Switch to urgent bugfix...",
        "        # ...later, resume feature A",
        "        ctx = checkpoint.load(\"feature-a\")",
        "        print(ctx['notes'])  # \"Need to add token refresh logic\"",
        "    \"\"\"",
        "",
        "    def __init__(self, checkpoint_dir: Optional[str] = None):",
        "        if checkpoint_dir:",
        "            self._dir = Path(checkpoint_dir)",
        "        else:",
        "            self._dir = Path('.task_checkpoints')",
        "        self._dir.mkdir(exist_ok=True)",
        "",
        "    def save(self, task_name: str, context: Dict[str, Any]) -> None:",
        "        \"\"\"Save context for a task.\"\"\"",
        "        checkpoint = {",
        "            'task_name': task_name,",
        "            'saved_at': datetime.now().isoformat(),",
        "            'context': context,",
        "        }",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        with open(filepath, 'w') as f:",
        "            json.dump(checkpoint, f, indent=2)",
        "",
        "    def load(self, task_name: str) -> Optional[Dict[str, Any]]:",
        "        \"\"\"Load context for a task. Returns None if not found.\"\"\"",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        if not filepath.exists():",
        "            return None",
        "        with open(filepath, 'r') as f:",
        "            checkpoint = json.load(f)",
        "        return checkpoint.get('context')",
        "",
        "    def list_tasks(self) -> List[str]:",
        "        \"\"\"List all saved task checkpoints.\"\"\"",
        "        return [f.stem for f in self._dir.glob('*.json')]",
        "",
        "    def delete(self, task_name: str) -> bool:",
        "        \"\"\"Delete a checkpoint. Returns True if deleted.\"\"\"",
        "        filepath = self._dir / f\"{task_name}.json\"",
        "        if filepath.exists():",
        "            filepath.unlink()",
        "            return True",
        "        return False",
        "",
        "    def summarize(self, task_name: str) -> Optional[str]:",
        "        \"\"\"Get a one-line summary of a task checkpoint.\"\"\"",
        "        ctx = self.load(task_name)",
        "        if not ctx:",
        "            return None",
        "",
        "        parts = [task_name]",
        "        if 'branch' in ctx:",
        "            parts.append(f\"[{ctx['branch']}]\")",
        "        if 'notes' in ctx:",
        "            notes = ctx['notes']",
        "            if len(notes) > 50:",
        "                notes = notes[:47] + \"...\"",
        "            parts.append(f\"- {notes}\")",
        "",
        "        return ' '.join(parts)"
      ],
      "lines_removed": [],
      "context_before": [
        "        return all(r.success for r in self._results)",
        "",
        "    @property",
        "    def modified_files(self) -> List[str]:",
        "        \"\"\"List of files modified during this session (from git context).\"\"\"",
        "        files = set()",
        "        for r in self._results:",
        "            files.update(r.git.modified_files)",
        "            files.update(r.git.staged_files)",
        "        return list(files)"
      ],
      "context_after": [],
      "change_type": "add"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": "from cortical.cli_wrapper import (",
      "start_line": 26,
      "lines_added": [
        "    test_then_commit,",
        "    commit_and_push,",
        "    sync_with_main,",
        "    TaskCheckpoint,"
      ],
      "lines_removed": [],
      "context_before": [
        "    GitContext,",
        "    HookRegistry,",
        "    HookType,",
        "    CLIWrapper,",
        "    TaskCompletionManager,",
        "    ContextWindowManager,",
        "    create_wrapper_with_completion_manager,",
        "    run_with_context,",
        "    run,",
        "    Session,"
      ],
      "context_after": [
        ")",
        "",
        "",
        "class TestGitContext(unittest.TestCase):",
        "    \"\"\"Tests for GitContext collection.\"\"\"",
        "",
        "    def test_collect_non_repo(self):",
        "        \"\"\"Test collection outside git repo.\"\"\"",
        "        with tempfile.TemporaryDirectory() as tmpdir:",
        "            ctx = GitContext.collect(tmpdir)"
      ],
      "change_type": "add"
    },
    {
      "file": "tests/test_cli_wrapper.py",
      "function": "class TestDecoratorHooks(unittest.TestCase):",
      "start_line": 710,
      "lines_added": [
        "class TestCompoundCommands(unittest.TestCase):",
        "    \"\"\"Tests for compound command functions.\"\"\"",
        "",
        "    def test_test_then_commit_fails_on_test_failure(self):",
        "        \"\"\"Test that test_then_commit stops if tests fail.\"\"\"",
        "        # Use a test command that fails",
        "        ok, results = test_then_commit(",
        "            test_cmd=[\"python\", \"-c\", \"import sys; sys.exit(1)\"],",
        "            message=\"Should not commit\"",
        "        )",
        "",
        "        self.assertFalse(ok)",
        "        self.assertEqual(len(results), 1)  # Only test ran",
        "        self.assertFalse(results[0].success)",
        "",
        "    def test_test_then_commit_returns_results(self):",
        "        \"\"\"Test that results are returned correctly.\"\"\"",
        "        # Use a test that passes",
        "        ok, results = test_then_commit(",
        "            test_cmd=[\"echo\", \"tests pass\"],",
        "            message=\"Test commit\",",
        "            add_all=False  # Don't actually add files",
        "        )",
        "",
        "        # Test passed, so we get test result + commit attempt",
        "        self.assertGreaterEqual(len(results), 1)",
        "        self.assertTrue(results[0].success)  # echo succeeded",
        "",
        "    def test_sync_with_main_returns_tuple(self):",
        "        \"\"\"Test sync_with_main returns proper structure.\"\"\"",
        "        # This will likely fail (no remote) but should return proper tuple",
        "        ok, results = sync_with_main(main_branch=\"nonexistent-branch-xyz\")",
        "",
        "        self.assertIsInstance(ok, bool)",
        "        self.assertIsInstance(results, list)",
        "        self.assertGreater(len(results), 0)",
        "",
        "",
        "class TestTaskCheckpoint(unittest.TestCase):",
        "    \"\"\"Tests for TaskCheckpoint context saving.\"\"\"",
        "",
        "    def setUp(self):",
        "        \"\"\"Create a temporary checkpoint directory.\"\"\"",
        "        self.tmpdir = tempfile.mkdtemp()",
        "        self.checkpoint = TaskCheckpoint(checkpoint_dir=self.tmpdir)",
        "",
        "    def tearDown(self):",
        "        \"\"\"Clean up temporary directory.\"\"\"",
        "        import shutil",
        "        shutil.rmtree(self.tmpdir, ignore_errors=True)",
        "",
        "    def test_save_and_load(self):",
        "        \"\"\"Test saving and loading a checkpoint.\"\"\"",
        "        context = {",
        "            'branch': 'feature/test',",
        "            'notes': 'Working on tests',",
        "            'files': ['test.py'],",
        "        }",
        "",
        "        self.checkpoint.save(\"my-task\", context)",
        "        loaded = self.checkpoint.load(\"my-task\")",
        "",
        "        self.assertEqual(loaded['branch'], 'feature/test')",
        "        self.assertEqual(loaded['notes'], 'Working on tests')",
        "        self.assertEqual(loaded['files'], ['test.py'])",
        "",
        "    def test_load_nonexistent(self):",
        "        \"\"\"Test loading a nonexistent checkpoint returns None.\"\"\"",
        "        result = self.checkpoint.load(\"does-not-exist\")",
        "        self.assertIsNone(result)",
        "",
        "    def test_list_tasks(self):",
        "        \"\"\"Test listing saved tasks.\"\"\"",
        "        self.checkpoint.save(\"task-a\", {'note': 'a'})",
        "        self.checkpoint.save(\"task-b\", {'note': 'b'})",
        "",
        "        tasks = self.checkpoint.list_tasks()",
        "",
        "        self.assertIn(\"task-a\", tasks)",
        "        self.assertIn(\"task-b\", tasks)",
        "",
        "    def test_delete(self):",
        "        \"\"\"Test deleting a checkpoint.\"\"\"",
        "        self.checkpoint.save(\"to-delete\", {'temp': True})",
        "",
        "        # Should exist",
        "        self.assertIsNotNone(self.checkpoint.load(\"to-delete\"))",
        "",
        "        # Delete it",
        "        deleted = self.checkpoint.delete(\"to-delete\")",
        "        self.assertTrue(deleted)",
        "",
        "        # Should be gone",
        "        self.assertIsNone(self.checkpoint.load(\"to-delete\"))",
        "",
        "    def test_delete_nonexistent(self):",
        "        \"\"\"Test deleting nonexistent checkpoint returns False.\"\"\"",
        "        deleted = self.checkpoint.delete(\"never-existed\")",
        "        self.assertFalse(deleted)",
        "",
        "    def test_summarize(self):",
        "        \"\"\"Test one-line summary generation.\"\"\"",
        "        self.checkpoint.save(\"feature-x\", {",
        "            'branch': 'feature/x',",
        "            'notes': 'Need to add validation',",
        "        })",
        "",
        "        summary = self.checkpoint.summarize(\"feature-x\")",
        "",
        "        self.assertIn(\"feature-x\", summary)",
        "        self.assertIn(\"[feature/x]\", summary)",
        "        self.assertIn(\"validation\", summary)",
        "",
        "    def test_summarize_truncates_long_notes(self):",
        "        \"\"\"Test that long notes are truncated.\"\"\"",
        "        long_notes = \"A\" * 100  # 100 chars",
        "",
        "        self.checkpoint.save(\"verbose-task\", {",
        "            'notes': long_notes,",
        "        })",
        "",
        "        summary = self.checkpoint.summarize(\"verbose-task\")",
        "",
        "        # Should be truncated",
        "        self.assertLess(len(summary), 100)",
        "        self.assertIn(\"...\", summary)",
        "",
        ""
      ],
      "lines_removed": [],
      "context_before": [
        "        def on_echo_success(ctx):",
        "            echo_count[0] += 1",
        "",
        "        wrapper.run(\"echo one\")",
        "        wrapper.run(\"echo two\")",
        "        wrapper.run(\"python -c 'print(1)'\")  # Not echo",
        "",
        "        self.assertEqual(echo_count[0], 2)",
        "",
        ""
      ],
      "context_after": [
        "if __name__ == '__main__':",
        "    unittest.main()"
      ],
      "change_type": "add"
    }
  ],
  "hour_of_day": 17,
  "day_of_week": "Thursday",
  "seconds_since_last_commit": -332683,
  "is_merge": false,
  "is_initial": false,
  "parent_count": 1,
  "session_id": null,
  "related_chats": [],
  "ci_result": null,
  "reverted": false,
  "amended": false
}